<head>
	<title>Tutorial 5: Implementing</title>
	<link rel="stylesheet" type="text/css" href="../helpStyle.css">
</head>
<html>
	<body outputFile="tutorial5.html" title="Tutorial 5: Implementing">
		<h1>Tutorial 5: Implementing</h1>
		<p>Once your model has been created and validated, the next step is the implementation of your components and devices and the generation of 
descriptor files and source code. CX makes this possible with its powerful code and descriptor generation functionality.  </p>
		<p>The code and descriptor generation capabilities of CX leverage the complete configuration in the model to determine the optimal code 
	to generate for the applications and the communication between the connected elements. All of the information in the model is analyzed to 
	determine the most optimized way to generate the code.</p>
		<p>In this tutorial, you will:</p>
		<ul>
			<li>define code generation properties</li>
			<li>generate and browse the code</li>
			<li>generate SCA descriptors</li>
		</ul>
		<p>This tutorial assumes you have completed <a href="tutorial1.html">Tutorial 1</a>, <a href="tutorial_2.html">Tutorial 2</a>, <a href="tutorial_3.html">Tutorial 3</a>, 
and <a href="tutorial4.html">Tutorial 4</a>.</p>
		<p>In the <strong>Project Explorer</strong> expand the project and model you defined in <a href="tutorial4.html">Tutorial 4</a>.</p>
		<h2>Define the Build Configuration</h2>
		<p>CX generates the source code once for each component. The build configuration determines the build environment that will be generated 
and this determines how the source code is built. With CX you have the option to create a build configuration or use an existing configuration. 
In your model, a component can have one or more implementations; each of these implementations has a build configuration for a 
specific operating environment. Using the build configuration wizard, you specify General and SCA Domain build options. Each of 
these have Base and Local Values. The Base Values are read only. The Local Values can be overridden for each implementation.</p>
		<p>Before being able to use a Build Configuration in your model you must import one:</p>
		<ol>
			<li>In the <b>Project Explorer</b> select the <b>CXTutorial_Model</b> model.</li>
			<li>Right click and from the pop-up menu select <b>Import Model Library</b></li>
			<li>Select the <b>Deployed Library</b> checkbox.</li>
			<li>Choose the required build configuration from the drop down. For the sake of example, this tutorial will use the 
				<strong>eorb16-linux-gcc-x86</strong> Build Configuration.</li>
		</ol>
		<p>This will add a Package Import element into the model that will make the selected build configuration available for use in your model.</p>
		<ol>
			<li>In the <strong>Project Explorer</strong>, select the <strong>ModemImpl</strong> you created.</li>
			<li>Right-click and from the pop-up menu, select <strong>Build Configuration</strong>.</li>
			<li>Select <strong>General</strong> and from the <strong>Base Build Configuration</strong> drop-down list, select 
				the <strong>eorb16-linux-gcc-x86::eorb16-linux-gcc-x86-build</strong> Build Configuration.</li>
			<p>The base values for this build configuration are loaded and are read only. In this tutorial you will not edit the base values, but you could 
optionally select the <strong>Local Values</strong> tab to configure additional properties for Modem_Impl.</p>
			<li>Click <strong>OK</strong>.</li>
			<li>Repeat this for <strong>AssemblyControllerImpl</strong>, <strong>DecryptorImpl</strong>, 
				and <strong>FilterImpl</strong>, assigning the same Build Configuration to each one.</li>
			<li>Validate your model and correct any errors.</li>
			<li>Save the model.</li>
		</ol>
		<p>Note: for this tutorial it is assumed the CF elements and the CryptoLib binaries are provided to you. So you won't generate 
code for these elements.</p>
		<h2>Define the Make Location</h2>
		<p>If make is not in your path or you use a specific make, you need to specify the make location. The make location specifies 
location of the make application used to build applications. Note that this must be GNU Make version 3.81 or later to work correctly with 
the makefiles generated by Spectra CX.</p>
		<ol>
			<li>Open <strong>Window</strong> &gt; <strong>Preferences</strong> and expand <strong>Spectra CX</strong> &gt; <strong>Modeling</strong>.</li>
			<li>Enter the location of your GNU Make binary into the <strong>Make location</strong> field.</li>
			<li>Click <strong>OK</strong>.</li>
		</ol>
		<h2>Generate Code</h2>
		<p>The application/node determines which components/devices source code needs to be generated for.</p>
		<ol>
			<li>In the <strong>Project Explorer</strong>, select and right-click <strong>TutorialApplication</strong>. From the pop-up menu, select 
<strong>CX Generate</strong> &gt; <strong>SCA Code</strong>. </li>
			<li>In the <strong>Project Explorer</strong> select and right-click <strong>CommunicatorPlatform</strong>. From the pop-up menu, select 
<strong>CX Generate</strong> &gt; <strong>SCA Code</strong>.</li>
		</ol>
		<h2>Browse Generated Code</h2>
		<p>The generated code is added to the Project Explorer in a folder structure that includes the functional, component, target specific, and port code. A new Project
is added to the Project Explorer for this tutorial called <strong>CXTutorial_Model_src</strong>. You can browse this source code in either the Spectra CX or C/C++ perspective.</p>
		<p>To browse the source code, simply navigate the generated source folder and open files and folders.</p>
		<p>The <strong>comps</strong> folder contains the source code for the components in the application.</p>
		<p>The <strong>devs</strong> folder contains the source code for the devices in the application.</p>
		<p>Under each component or device folder there is a worker folder. This contains the code that will hold your functional code.</p>
		<p>The <strong>framework</strong> folder contains generic code used by components, devices and ports.</p>
		<p>The <strong>ports</strong> folder contains the code for uses and provides ports.</p>
		<h2>Edit Worker Code</h2>
		<p>The Worker code is populated from CX and contains gaps where your functional code is inserted. Although you edit the 
			worker code using the CDT source code editor, on the actual source files, CX stores your functional code in the model 
			so that it can always regenerate those source files. Using CX, you can easily edit the Worker code and Worker 
			operations. Note that when you choose to edit any of the fragments of worker code, CX will first generate the source 
			code file to be edited. If the relevant source code file has not been generated previously, CX will generate it for you 
			before opening the CDT editor at the appropriate location in the file.</p>
		<p>Each location in the worker source files that can be edited by the user is marked by special pairs of comments. You 
			must enter your functional code between these marker comments so that CX can distinguish your code from generated code. 
			This enables CX to extract your functional code from these source files and store it in the model. This allows CX to 
			always regenerate the source code from the model. An example of these marker comments is shown below.</p>
		<pre>
	...
	#include "scxData_EncryptedDataPortHandler.h"
	#include "scxData_OpenDataUsesPort.h"

	/* CXGEN-USERREGION-BEGIN platform:/resource/CXTutorial/CXTutorial_Model.emx#_Mi1I0FjzEd-N4KNIfE9jyQ h_Source SCA::SCA_SoftwarePackage::SCAGeneratableComponent */
	<strong>YOUR CODE GOES HERE</strong>
	/* CXGEN-USERREGION-END */

	class scxDecryptorWorker : public scxData_EncryptedDataPortHandler
	{
		...
	</pre>
		<ol>
			<li>Ensure you are in the <strong>Spectra CX</strong> perspective.</li>
			<li>Open the <strong>Decryptor</strong> diagram and select <strong>Decryptor</strong>.</li>
		</ol>
		<p>To edit the Worker.h file:</p>
		<ol>
			<li>Right click <strong>Decryptor</strong> and select <strong>Open Editor</strong> &gt; <strong>Header</strong>.</li>
			<li>This will generate the <strong>scxDecryptorWorker.h</strong> file and open the CDT editor on it, with the cursor placed between the marker comments.</li>
			<li>Add the following: <strong>// worker header comment</strong>. This should be added between the markers, and then save the file.</li>
			<li>When you saved the <strong>scxDecryptorWorker.h</strong> file, Spectra CX captures the changes you had made and stored them in the model.</li>
			<li>Delete the <strong>scxDecryptorWorker.h</strong> file and go back to right click <strong>Decryptor</strong> and select <strong>Open Editor</strong> &gt; <strong>Header</strong> again.</li>
			<li>This will generate the <strong>scxDecryptorWorker.h</strong> file again and open the CDT editor on it again. This time you will see the modification that you previously made, and which Spectra CX has regenerated.</li>
		</ol>
		<p>In addition to the above location, you may also edit code in the Worker.cpp file, using <strong>Open Editor</strong> &gt; <strong>Implementation</strong>, and in the Worker class, using <strong>Open Editor</strong> &gt; <strong>Class</strong>.</p>
		<p>The worker's configure, query and runTest methods should be edited by right clicking on the appropriate <strong>SCA Property</strong> and selecting <strong>Open Editor</strong>.
For example, to edit the Decryptor Worker's DECRYPT_KEY configure method, do the following:</p>
		<ol>
			<li>Select and right-click the Decryptor property <strong>DECRYPT_KEY</strong> and select <strong>Open Editor</strong> &gt; <strong>Configure</strong>.</li>
			<li>Add the following: <strong>execParams_.DECRYPT_KEY = DECRYPT_KEY.in();</strong>, save and close the file.</li>
			<li>Select and right-click the Decryptor property <strong>DECRYPT_KEY</strong> and select <strong>Open Editor</strong> &gt; <strong>Query</strong>.</li>
			<li>Add the following: <strong>DECRYPT_KEY = execParams_.DECRYPT_KEY.c_str();</strong>, save and close the file.</li>
			<li>Right click <strong>Decryptor</strong> and select <strong>CX Generate</strong> &gt; <strong>SCA Code</strong>. This regenerates
 the code for the component.</li>
			<li>Inspect the <strong>scxDecrytporWorker.cpp</strong> file and see the change you made is still there.</li>
		</ol>
		<p>Other methods can be edited directly (i.e. start, stop, initialize, releaseObject). To edit these methods simply select them, right click and select <strong>Open Editor</strong>.</p>
		<p>Every provides port operation is represented by a method in the worker. A port name on a component has to be unique. 
To ensure components can handle multiple provides ports of the same interface type CX names each method &lt;port_name&gt;_&lt;method&gt;.
For example, to edit the Decryptor Worker's provides ports method, select and right-click the <strong>Decryptor::dataIn_pushEncryptedData()</strong> 
method and select <strong>Open Editor</strong>. This method is called when a pushEncryptedData message is received on the dataIn port.</p>
		<p>Save the model.</p>
		<h2>Compile the Source</h2>
		<p>In order to compile the source code, select or open the <strong>Make Targets</strong> view (to open, go to <strong>Window &gt; Show View &gt; Other</strong>).</p>
		<ol>
			<li>In the <strong>Make Targets</strong> view, double click on the <strong>all</strong> target to compile everything.</li><br>The console view allows you to view the build progress. You should see the source code generated and compiled for the IDL, 
ports and the build target. The binaries should appear under subdirectories of the <strong>CXTutorial_Model_src/obj</strong> directory.</ol>
		<h2>Descriptor Generation</h2>
		<p>CX generates SCA-compliant XML descriptor files from the UML 2.0 model that you define. XML can be generated from Applications, 
Nodes, Platforms and individual component structure realizations. CX creates all the XML descriptor files as specified in the Domain Profile.</p>
		<p>To generate the application XML, do the following:</p>
		<ol>
			<li>In the <strong>Project Explorer</strong>, select <strong>TutorialApplication</strong> and from the pop-up menu select <strong>
CX Generate</strong> &gt; <strong>Descriptor(s)</strong>.</li>
			<p>The files are generated and added to the CXTutorial_Model_src/descriptors folder.</p>
		</ol>
		<p>CX generates the Software Assembly Descriptor for the application.  It also generates the Software Component and Software Package 
			Descriptors for each component contained in the application. If you have defined properties for the components, CX generates the 
			Properties Descriptors, as well. </p>
		<p>To generate the platform xml, do the following:</p>
		<ol>
			<li>In the <strong>Project Explorer</strong>, select <strong>CommunicatorPlatform</strong> and from the pop-up menu select 
<strong>CX Generate</strong> &gt; <strong>Descriptor(s)</strong>. </li>
		</ol>
		<p>CX generates the Device Configuration Descriptor for all nodes in the platform. It also generates the Software Component and Software 
Package Descriptors for each device or Core Framework element contained in the node. If you have defined properties for the devices or 
Core Framework entities, CX generates the Property Descriptors, as well. </p>
		<h2>Descriptor Validation</h2>
		<p>Spectra CX can be used to validate SCA XML descriptor files, whether they are generated from a 
			Spectra CX model or not. To validate the SCA descriptors that were just generated off the 
			<strong>CommunicatorPlatform</strong> and <strong>TutorialApplication</strong>, do the following:</p>
		<ol>
			<li>Select the <strong>CXTutorial_Model_src/descriptors</strong> folder.</li>
			<li>Right click and select <strong>Validate</strong>.</li>
		</ol>
		<p>This will result in 8 problem markers being created on some of the descriptor files. Each of these errors
			relates to a <strong>localfile name</strong> attribute referring to a file that does not exist. Each SPD file 
			contains at least one implementation block which in turn references the actual executable or shared 
			library file that it describes. When Spectra CX generates the descriptors and the binaries, it does 
			not currently generate these filename references with full path information, which is why the SCA XML Validation
			raises these errors. These errors will be fixed in the following sections.</p>
		<h2>Packaging Files for Deployment</h2>
		<p>So far, we have generated code, and compiled it, to produce binaries for the following components:</p>
		<ul>
			<li>AssemblyController</li>
			<li>Filter</li>
			<li>Decryptor</li>
			<li>Modem</li>
		</ul>
		<p>It is assumed that the binaries for the other components are pre-existing, either from a Core Framework distribution or elsewhere:</p>
		<ul>
			<li>cryptolib.so</li>
			<li>DomainManager</li>
			<li>DeviceManager</li>
			<li>DomainLog</li>
		</ul>
		<p>This section describes how to model these pre-existing binaries so that they will get copied into the
			<strong>CXTutorial_Model_src</strong> project during generation. To do this we need to associate a 
			<strong>Binary Configuration</strong> with the appropriate Component Implementation elements. A <strong>Binary 
			Configuration</strong> is similar to a <strong>Build Configuration</strong> except instead of specifying 
			how to generate and compile code, to produce the binary for the component, it specifies the location of 
			a pre-existing binary for the component.</p>
		<p>Before doing this we need to create a dummy <strong>cryptolib.so</strong> file. This file is required to 
			satisfy the SPD validation and Core Framework runtime. However, since it only exists in order to demonstrate
			a modeling construct, it doesn't need to be a functional library.</p>
		<ol>
			<li>Right-click on the <strong>CXTutorial</strong> project and select <strong>New &gt; File</strong>.</li>
			<li>In the New File dialog, select the <strong>CXTutorial</strong> project.</li>
			<li>Enter the File Name as <strong>cryptolib.so</strong> and click <strong>Finish</strong>.</li>
		</ol>
		<p>Now create the <strong>Binary Configurations</strong>.</p>
		<ol>
			<li>In the Project Explorer, or on the DomainManager diagram, select the <strong>DomainManagerImpl</strong> element.</li>
			<li>Right click and select <strong>Build Configuration...</strong>.</li>
			<li>In the <strong>Base Build Configuration</strong> drop down, select 
				<strong>eorb16-linux-gcc-x86::eorb16-linux-gcc-x86-build</strong> (or the Build Configuration that 
				describes your pre-existing binary the closest).</li>
			<li>Check the <strong>Use Binary Configuration</strong> check box.</li>
			<li>Click the <strong>Browse</strong> button on the <strong>Binary</strong> field and select your 
				pre-existing <strong>DomainManager</strong> binary. Note you can browse for your binary either in 
				the workspace or in the file system. Using a workspace URI, rather than a native file system URI, 
				makes your model projects more portable between different workspaces.</li>
			<li>Click <strong>OK</strong>.</li>
			<li>Now select the <strong>DomainManager</strong> element, right-click and select <strong>CX Generate &gt; Descriptor(s)</strong>.</li>
			<li>Expand <strong>CXTutorial_Model_src/obj/eorb16-linux-gcc-x86-tools/eorb16-linux-gcc-x86-build</strong> 
				and you will see the generated <strong>DomainManager</strong> directory containing the copied 
				<strong>DomainManager</strong> binary.</li>
		</ol>
		<p>Repeat the above steps for the <strong>DeviceManager</strong>, <strong>DomainLog</strong> and 
			<strong>cryptolib.so</strong> binaries.</p>
		<p>Now that all of the binary files have been either compiled or copied into 
			<strong>CXTutorial_Model_src/obj/...</strong>, the SCA XML validation errors can now be addressed.
			This is done by creating a symbolic link (or copy) of the binaries in the 
			<strong>CXTutorial_Model_src/descriptors</strong> directory.</p>
		<p>Note that in the steps below, the names of the &lt;toolsdir&gt; and 
			&lt;builddir&gt; directories depends on which Build Configuration you have chosen. If you have used 
			the <strong>eorb16-linux-gcc-x86</strong> Build Configuration these directories will be named 
			<strong>eorb16-linux-gcc-x86-tools</strong> and <strong>eorb16-linux-gcc-x86-build</strong>.</p>
		<p>Also, depending on which Build Configuration you have chosen, the binary executable files may have an
			extension such as <strong>.vxe</strong> or <strong>.mod</strong> etc.</p>
		<ol>
			<li>Expand the <strong>CXTutorial_Model_src</strong> project.</li>
			<li>Link or copy the following binary files into the <strong>descriptors</strong> directory:</li>
			<ul>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/AssemblyController/AssemblyController</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/Decryptor/Decryptor</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/Filter/Filter</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/DomainManager/DomainManager</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/DeviceManager/DeviceManager</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/DomainLog/DomainLog</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/CryptoLib/cryptolib.so</strong></li>
			</ul>
		</ol>
		<p>Repeat the steps to validate the <strong>descriptors</strong> directory, and all of the XML errors 
			should now be fixed, indicating that you now have a self consistent set of valid descriptors and binary files.</p>
		<h2>Tutorial Summary</h2>
		<p>In this tutorial you have learned about code and descriptor generation. This final phase of the process shows how the model and its elements can be 
used to implement the principles of COE.</p>
		<div class="runningfooter" id="dochomefooter"><a href="http://www.prismtech.com/contact" shape="rect" target="_blank">Provide feedback</a><br clear="none"><hr>  
			Copyright <sup>©</sup> 2010 Zeligsoft Ltd. All rights reserved.
			
		</div>
	</body>
</html>