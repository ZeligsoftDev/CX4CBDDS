<head>
	<title>Key Concepts</title>
	<link rel="stylesheet" type="text/css" href="../helpStyle.css">
</head>
<html>
	<body outputFile="keyconcepts.html" title="Key Concepts">
		<h1>Key Concepts</h1>
		<p>Use this topic to learn more about CX, COE, SCA, and UML modeling. This topic provides detailed information about the key concepts 
			you need to understand and become familiar with. </p>
		<h2>Application</h2>
		<p>An executable software program that may contain one or more modules. The executable software exhibits pre-determined functionality.
			In COE an application is created by assembling a set of components and providing connections between compatible ports 
			(formal interfaces) on adjacent components. Using Model Driven Design (MDD) techniques, individual components and the overall 
			application model can be validated for correctness at any point in the development process.</p>
		<h2>Application Layer</h2>
		<p>This layer describes the true software customization of the logical platform. This is where the user puts the added value.</p>
		<h2>Assembly</h2>
		<p>An assembly is a structure of communicating components. Parts of an assembly are defined by component interfaces. Connections 
			in the assembly indicate communication between component ports.</p>
		<h2>Attributes</h2>
		<p>An attribute is a property that describes a level of capability available in a device or required by a resource. 
			A significant piece of data owned by a class, often containing values describing each instance of the class. Besides the attribute name 
			and a slot for the attribute value, an attribute may have specified visibility, type, multiplicity, default value, and property-string.</p>
		<h2>Class</h2>
		<p>The primary declarative construct of Object-Oriented Programming; a cohesive unit of attributes and operations; a compile-time 
			template for an Object. This blueprint includes attributes and methods that the created objects all share.</p>
		<h2>Class Diagram</h2>
		<p>A type of static structure diagram that describes the structure of a system by showing the system's classes, their attributes, 
			and the relationships between the classes. 
			The class diagram shows how the different entities relate; in other words, it shows the 
			static structures of the system. A class diagram can be used to display logical classes, which are typically the kinds 
			of things the business people in an organization talk about. Class diagrams can also be used to show implementation classes, which are the 
			things that programmers typically deal with. 
			A class is depicted on the class diagram as a rectangle with three horizontal sections. The upper section shows the class's name; 
			the middle section contains the class's attributes; and the lower section contains the class's operations (or "methods").</p>
		<h2>Component</h2>
		<p><a href="http://www.omg.org/">OMG</a> defines a component as "A modular part of a system that encapsulates its contents and whose 
			manifestation is replaceable
         within its environment.  A component defines its behavior in terms of provided and required interfaces. As such, a component
         serves as a type, whose conformance is defined by these provided and required interfaces (encompassing both their static as
         well as dynamic semantics)." A component is an encapsulated unit of functionality with a well-defined interface that allows it to 
				 connect to other components, and be independently deployed. Component-based applications are defined by assembling components.
				 A component represents a software module (source code, binary code, executable, DLL, etc.) with a well-defined interface. The interface 
				 of a component is represented by one or several interface elements that the component provides. Components are used to 
				 show compiler and run-time dependencies, as well as interface and calling dependencies among software modules. They also 
				 show which components implement a specific class.</p>
		<h2>Component-Oriented Engineering (COE)</h2>
		<p>A software development methodology focused on addressing the challenges of complex embedded systems characterized by distributed 
			applications and heterogeneous multiprocessor platforms. COE derives its key attributes from: Component-Based Development (CBD), Model 
			Driven Development (MDD), and Agile Software Development (ASD). Support for the QoS analysis and validation form an integral part of the 
			methodology and are used throughout the process. From a life cycle perspective, COE focuses on the component-based aspect of the entire 
			product development life cycle, including component definition, system integration, and testing from individual components to 
			integrated systems.</p>
		<h2>Component Interface</h2>
		<p>Defines the provided and required interfaces that the component uses to communicate with its environment. A component interface
			also defines the properties of the component. Properties are the configurable parameters of the component interface, allowing the 
			interface to be configured for a specific use.</p>
		<p>In COE, a component interface can have multiple realizations, hence support multiple different structures to delegate behavior, or 
			different code realizations for different languages.</p>
		<h2>Component Realization</h2>
		<p>This is a modeling entity that ensures that the messages on the ports of the component interface are handled correctly. A 
			component interface is realized by a component realization. A single component interface can be realized by one or more component
			realizations. Component realizations can contain code and behavior.</p>
		<h2>Communication Path</h2>
		<p>A connection between two or more physical elements.</p>
		<h2>Configuration</h2>
		<p><a href="http://www.omg.org/">OMG</a> defines a configuration as "a set of default run-time application options used to customize non-deployment related 
         			application features."</p>
		<h2>Connection</h2>
		<p>A connection is used to describe connections from or to a component port at runtime. A connection is either a communication
         path among the ports of two or more subcomponents allowing them to communicate with each other, or it is a communication path between an assembly's external
         ports and an assembly's subcomponents that delegates the external port's behavior to the subcomponent's ports. The endpoint of a connection may also refer to
         a location outside the assembly.</p>
		<h2>Dependency</h2>
		<p>A relationship that indicates that one component or device depends on a specific property of another component or device.</p>
		<h2>Deployment</h2>
		<p>The deployment brings together the software layer with the platform layer. It models a mapping from software components and the 
			connections between these components to the different platform layers. A deployment can be seen as a model-based representation of
			an "integration". The deployment is 
			the first design element from which code and other related artifacts can be generated for the application and optimized for the 
			allocation decisions.</p>
		<h2>Deployment Specification</h2>
		<p>A deployment specification is essentially a configuration file such as an XML document or a text file that defines how an
         artifact is deployed on a node. </p>
		<h2>Device</h2>
		<p>A device refers to a logical hardware element (typically a module performing a function or set of functions identified in
         its device profile).  A logical device interface is an abstraction of a hardware device that defines the capabilities, attributes, and 
				 interfaces
         for that device.</p>
		<h2>Domain Specialization</h2>
		<p>Customization of the COE development environment is provided by domains, which tailor to the COE framework for platform 
			intelligence and component model frameworks. Domains also include model transformation engines that correspond to the selected 
			component framework. A domain is 
			an entity that encapsulates specific platform knowledge, component framework information and associated transformation engines.</p>
		<h2>Execution Environment</h2>
		<p>In UML modeling, an execution environment is a type of node that represents a particular execution platform, such as an operating
         system. You can use execution environments to describe the context in which the execution of a set of deployed components
         takes place.  The properties of an execution environment for a given node/device type will be different and based on both
         the type and the domain profile in which the execution environment is defined.</p>
		<h2>Implementation</h2>
		<p>Concerns the code that implements a component or device definition or about the components which make up an application. 
         Think of this as the executable or shared library that gets loaded to the target platform.</p>
		<h2>Interface</h2>
		<p>A named set of operations that characterize the behavior of an element. A defined communication boundary.</p>
		<h2>Layer</h2>
		<p>In COE, a layer can represent a layer at the software platform, logical platform, and physical platform layer.</p>
		<h2>Logical Layer</h2>
		<p>Represents the service layer that represents the RTOS, RTOS services, drivers, and middleware layers. It also represents the
			execution environment such as processes, threads, and virtual machines. The logical layer can consist of multiple layers.</p>
		<h2>Monolithic Implementation</h2>
		<p>A component or device's monolithic implementation is an implementation of the component's definition. Usually it is associated with source 
			code or an executable. Instances of either component/device definitions or monolithic implementations are added to an application.</p>
		<h2>Node</h2>
		<p>In UML modeling, nodes are model elements that represent the computational resources of a system, such as personal computers,
         sensors, printing devices, and servers. Nodes can be interconnected by using communication paths to describe network structures.</p>
		<p>A run-time computational resource that only has at least memory and often processing capability. Run-time implementation
         objects and components may reside on nodes.</p>
		<h2>Part</h2>
		<p>An element within an assembly that represents a defined element's part within that assembly.</p>
		<h2>Physical Layer</h2>
		<p>Represents the physical hardware. This layer provides the grounding of the entire model.</p>
		<h2>Platform</h2>
		<p>Typical platform layers include a hardware layer composed of different types of processors (GPP, DSP, FPGA), memory buses, and inter 
			connections, and the RTOS layer and middleware layers that provide services to application components. Similarly to applications, platform 
			layers can be individually defined in a component-based manner.</p>
		<h2>Port</h2>
		<p>A port identifies a source/producer (Provides Port) or a sink/consumer(Uses Port) for data and/or commands. A Port specifies
         the types of data and commands accepted.</p>
		<h2>Property</h2>
		<p>A Property is a variable that contains a value of a specific type. Configuration Properties are parameters to the Configure
         and Query operations. Allocation Properties define the capability levels required of a Device by a Resource.</p>
		<h2>Properties Descriptor</h2>
		<p>A Properties Descriptor is an element of the Profile that contains information about the properties applicable to a software
         package or a device package such as configuration, test, execute, and allocation types.</p>
		<h2>Software Communications Architecture (SCA)</h2>
		<p>Industry specific component frameworks for software defined radio.</p>
		<h2>Structural Realization</h2>
		<p>A structural realization realizes the structural elements of the component. It realizes this in either structure, code (operations),
statemachines, mathematical functions or other concepts as defined in the domain.</p>
		<p>This realization should be platform independent. That is, able to support all intended platforms for a particular design. The component implementation can be
used to add platform specifics if required. </p>
		<h2>CX Component Diagram</h2>
		<p>A CX Component Diagram is created automatically with each model project creation. It is in this diagram that you 
			do your modeling and "work". For ease of use, you may want to create a diagram for each package - this way you can better visually organize 
			your elements.</p>
		<div class="runningfooter" id="dochomefooter"><a href="http://www.prismtech.com/contact" shape="rect" target="_blank">Provide feedback</a><br clear="none"><hr>  
			Copyright <sup>©</sup> 2010 Zeligsoft Ltd. All rights reserved.
			
		</div>
	</body>
</html>