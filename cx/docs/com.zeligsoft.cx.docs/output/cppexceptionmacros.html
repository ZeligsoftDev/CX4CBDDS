<head>
	<title>C++ Portable Exception Layer Macros</title>
	<link rel="stylesheet" type="text/css" href="../helpStyle.css">
</head>
<html>
	<body outputFile="cppexceptionmacros.html" title="C++ Portable Exception Layer Macros">
		<h1>C++ Portable Exception Layer Macros</h1>
		<h2>Description</h2>
		<p>
				The Portable Exception Layer enables seamless cross-platform programming by providing C++-style exception handling on platforms where it is not supported.
				Code written with this layer works on platforms that support true exception handling as well as platforms that do not. Code will be compliant with the C++
				mapping, on either true-exception or non-exception platforms, when these macros are used.
			</p>
		<p>
				Files or modules which make use of the macros must include the scxCorbaExceptionMacros.h header file which is provided by a build configuration. A build
				configuration will support either true-exceptions or non-native exceptions, not both. It is therefore important to use a build configuration which is
				appropriate for the chosen environment.
			</p>
		<p>
			<h3>Example 1 Using Portable Exception Layer Macros</h3>
		</p>
		<pre>
// client
SCX_DECLARE_ENV;

SCX_TRY
{
   myIp-&gt;op (101, SCX_ENV_VARN);
   SCX_CHECK_ENV;
}
SCX_CATCH (myException, me)
{
   cerr &lt;&lt; "caught myException: " &lt;&lt; me.code;
}
SCX_CATCH (CORBA::SystemException, se)
{
   cerr &lt;&lt; "caught CORBA::SystemException: "
   &lt;&lt; se._rep_id () &lt;&lt; ": &lt;&lt; se.minor( ) &lt;&lt; endl;
}
SCX_CATCH_ANY ()
{
   cerr &lt;&lt; "caught some other exception" &lt;&lt; endl;
}
SCX_END_TRY

// server
void myInterface_impl::op (CORBA::Long val SCX_ENV_ARGN)
{
   if (val &gt; 100)
   {
      myException me (val);
      SCX_THROW_RETURN_VOID (me);
   }
}
			</pre>
		<h2>Macro Definitions</h2>
		<h3>SCX_DECLARE_ENV</h3>
		<p>Declares a local <code>CORBA::Environment</code> instance on the stack, for use by the other Portable Exception Layer macros. If building with exceptions, this expands to nothing.</p>
		<p>If a function uses any of the Portable Exception Layer macros, it must either have an <code>SCX_ENV_ARG[1|N]</code> in its signature, or it must use <code>SCX_DECLARE_ENV</code> in its body.</p>
		<p>In the following example, <code>SCX_DECLARE_ENV</code> is required to support the correct operation of the <code>SCX_TRY/CHECK/CATCH</code> macros.</p>
		<pre>
int main (int argc, char **argv)
{
   SCX_DECLARE_ENV;
				
   SCX_TRY
   {
      do_something (SCX_ENV_VAR1);
      SCX_CHECK_ENV;
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      cerr &lt;&lt; "Caught: " &lt;&lt; e-&gt;_rep_id() &lt;&lt; endl;
   }
   SCX_END_TRY
   ...
}
			</pre>
		<p>In the next example, <code>SCX_DECLARE_ENV</code> is not required because the <code>CORBA::Environment</code> is passed into the function by declaring it with <code>SCX_ENV_ARG1</code> in its signature. In this case, it is the responsibility of the caller to create, and pass in the <code>CORBA::Environment</code>.</p>
		<pre>
void func (SCX_ENV_ARG1)
{
   do_something (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;
			
   do_something_else (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;
}
			</pre>
		<h3>SCX_ENV_ARG[1 | N]</h3>
		<p>Declares a <code>CORBA::Environment</code> formal argument in the signature of a function.</p>
		<p>The two forms, ending in either 1 or N, are for use where the signature has no other arguments, or when it does have other arguments, respectively.</p>
		<pre>
void func1 (SCX_ENV_ARG1)
{
   ...
}

void func2 (CORBA::Short arg1 SCX_ENV_ARGN)
{
   ...
}
			</pre>
		<p>Note that in the signature of <code>func2</code>, there is no comma between the last argument and the <code>SCX_ENV_ARGN</code> macro. The macro expansion contains the comma, in the non-exception case, otherwise the macro expands to nothing.</p>
		<h3>SCX_ENV_VAR[1 | N]</h3>
		<p>Passes the current <code>CORBA::Environment</code> as a actual argument to a function call.</p>
		<p>The two forms, ending in either 1 or N, are for use where the signature of the function being called has no other arguments, or when it does have other arguments, respectively.</p>
		<p>The actual <code>CORBA::Environment</code> passed by this macro is picked up from the local scope, using a default name. This local may have been declared within the local scope, using <code>SCX_DECLARE_ENV</code>, or passed into the local scope (function) using <code>SCX_ENV_ARG[1|N]</code>.</p>
		<p>The following example shows the use of <code>SCX_ENV_VAR[1|N]</code>:</p>
		<pre>
void func0 (SCX_ENV_ARG1)
{
   ...
}

void func1 (int arg SCX_ENV_ARGN)
{
   ...
}

void func1 (SCX_ENV_ARG1)
{
   func0 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;

   func1 (1 SCX_ENV_VARN);
   SCX_CHECK_ENV_RETURN_VOID;
   ...
}
			</pre>
		<h3>SCX_TRY</h3>
		<p>Begins a try-catch block.</p>
		<h3>SCX_TRY_LABEL(lbl)</h3>
		<p>Begins a try-catch block with a label to facilitate multiple try-catch blocks within a single function.</p>
		<h3>SCX_THROW (exc)</h3>
		<p>Throws the specified exception, within the context of a try block.</p>
		<p>In true exception handling environments, this macro expands to a simple throw. In a non exception handling environment, it puts the specified exception into the current <code>CORBA::Environment</code> and causes execution to jump immediately to check for and enter an appropriate <code>SCX_CATCH</code> block. If an appropriate <code>SCX_CATCH</code> block cannot be found, execution will continue following the <code>SCX_END_TRY</code>.</p>
		<p>This macro can only be used within an <code>SCX_TRY/CATCH</code> construct.</p>
		<pre>
CORBA::Boolean some_func (SCX_ENV_ARG1)
{
   SCX_TRY
   {
      ...
      SCX_THROW (CORBA::IMP_LIMIT (0, CORBA::COMPLETED_NO));
      ...
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      return 0;
   }
   SCX_END_TRY

   SCX_CHECK_ENV_RETURN (0);
   
   return 1;
}
			</pre>
		<p>Note the use of an <code>SCX_CHECK_ENV_RETURN(0)</code> immediately following the <code>SCX_END_TRY</code>. This ensures that if code within the <code>SCX_TRY</code> block throws an exception that is not caught, execution will return immediately to the caller.</p>
		<h3>SCX_THROW_LABEL (exc, lbl)</h3>
		<p>Throws the specified exception, within the context of an <code>SCX_TRY_LABEL/CATCH</code> construct.</p>
		<p>This macro is identical to <code>SCX_THROW(exc)</code> except that it should be used when in the context of a labelled try-catch block i.e. one which begins with <code>SCX_TRY_LABEL(lbl)</code>. Labelled try-catch blocks are required when more than one try-catch block is used within the same function.</p>
		<pre>
void some_func (SCX_ENV_ARG1)
{
   SCX_TRY
   {
      SCX_TRY_LABEL(a)
      {
         SCX_THROW_LABEL (MyException(), a);
      }
      SCX_CATCH (CORBA::Exception, e)
      {
         cerr &lt;&lt; e._rep_id() &lt;&lt; endl;
      }
      SCX_END_TRY
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      cerr &lt;&lt; e._rep_id() &lt;&lt; endl;
   }
   SCX_END_TRY
}
			</pre>
		<h3>SCX_THROW_RETURN (exc, ret)</h3>
		<p>Throws the specified exception, when not in the context of an <code>SCX_TRY/CATCH</code> construct i.e. where throwing the exception should cause the current function to exit immediately to the caller.</p>
		<p>The ret argument specifies the return value of the function, in the case of a non-exception build.</p>
		<p>This macro should only be used outside of <code>SCX_TRY/CATCH</code> constructs. For example:</p>
		<pre>
CORBA::Boolean some_func (SCX_ENV_ARG1)
{
   ...
   SCX_THROW_RETURN (MyException(), 0);
   ...
			
   return 1;
}
			</pre>
		<h3>SCX_THROW_RETURN_VOID (exc)</h3>
		<p>Throws the specified exception, when not in the context of an <code>SCX_TRY/CATCH</code> construct i.e. where throwing the exception should cause the current function to exit immediately to the caller.</p>
		<p>This macro is identical to <code>SCX_THROW_RETURN(exc,ret)</code> except no return value is involved because it is for use in functions having a void return type.</p>
		<pre>
void some_func (SCX_ENV_ARG1)
{
   ...
   SCX_THROW_RETURN (MyException());
   ...
}
			</pre>
		<h3>SCX_CATCH(type,var)</h3>
		<p>Catches an exception of the specified type whose instance name is specified by var.</p>
		<h3>SCX_CATCH_NOOP(type)</h3>
		<p>Catches an exception of the specified type but does not use the exception instance.</p>
		<p>By not declaring a local variable to hold the exception, this avoids compiler warnings about 'unused local variables'.</p>
		<h3>SCX_CATCH_ANY</h3>
		<p>Catches any exception.</p>
		<h3>SCX_RETHROW_RETURN(ret)</h3>
		<p>Re-throws the exception, from within the context of a catch block, and returns ret in non-exception handling environments.</p>
		<pre>
CORBA::Boolean func (SCX_ENV_ARG1)
{
   SCX_TRY
   {
      another_func (SCX_ENV_VAR1);
      SCX_CHECK_ENV;
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      SCX_RETHROW_RETURN (0);
   }
   SCX_END_TRY

   return 1;
}
			</pre>
		<h3>SCX_RETHROW_RETURN_VOID</h3>
		<p>Re-throws the exception, from within the context of a catch block.</p>
		<pre>
void func (SCX_ENV_ARG1)
{
   SCX_TRY
   {
      another_func (SCX_ENV_VAR1);
      SCX_CHECK_ENV;
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      SCX_RETHROW_RETURN_VOID;
   }
   SCX_END_TRY
}
			</pre>
		<h3>SCX_CHECK_ENV</h3>
		<p>This macro is for use within the context of a try block. Within a try block, each statement which may raise an exception must be immediately followed by an <code>SCX_CHECK_ENV</code>.</p>
		<p>In non exception handling environments, this is the mechanism that transfers control to the appropriate catch block if an exception is 'thrown'.</p>
		<p>In a true exception handling environment, this macro expands to nothing.</p>
		<pre>
void func()
{
   SCX_DECLARE_ENV;

   SCX_TRY
   {
      func1 (SCX_ENV_VAR1);
      SCX_CHECK_ENV;

      func2 (SCX_ENV_VAR1);
      SCX_CHECK_ENV;
   }
   SCX_CATCH_ANY
   {
      cerr &lt;&lt; "ERROR" &lt;&lt; endl;
   }
   SCX_END_TRY
}
			</pre>
		<h3>SCX_CHECK_ENV_LABEL (lbl)</h3>
		<p>This macro is identical to <code>SCX_CHECK_ENV</code> except it is for use within a labelled try block i.e. one which begins with <code>SCX_TRY_LABEL(lbl)</code>.</p>
		<pre>
void func()
{
   SCX_DECLARE_ENV;

   SCX_TRY
   {
      ...
   }
   SCX_CATCH_ANY
   {
      ...
   }
   SCX_END_TRY
			
   SCX_TRY_LABEL(second)
   { 
      func1 (SCX_ENV_VAR1);
      SCX_CHECK_ENV_LABEL(second);
   }
   SCX_CATCH_ANY
   {
      cerr &lt;&lt; "ERROR" &lt;&lt; endl;
   }
   SCX_END_TRY
}
			</pre>
		<h3>SCX_CHECK_ENV_RETURN (ret)</h3>
		<p>This macro is similar to <code>SCX_CHECK_ENV</code>, except it is for use outside the context of a try block i.e. where an exception would cause execution to transfer immediately out of the function, up to its caller.</p>
		<p>In non exception handling environments, this macro simulates stack unwinding by using a return statement. The ret argument of this macro should evaluate to a valid return value for the enclosing function purely to satisfy the compiler. The assumption is that the caller will not actually use this value because of the exception.</p>
		<pre>
CORBA::Long func (SCX_ENV_ARG1)
{
   func1 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN(0);

   func2 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN(0);

   return 32;
}
			</pre>
		<h3>SCX_CHECK_ENV_RETURN_VOID</h3>
		<p>This is identical to the <code>SCX_CHECK_ENV_RETURN(ret)</code> macro except it is for use in functions that have a void return type.</p>
		<pre>
void func (SCX_ENV_ARG1)
{
   func1 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;

   func2 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;
}
			</pre>
		<h3>SCX_END_TRY</h3>
		<p>Declares the end of a try-catch block. This should be placed after the closing bracket of the last catch block.</p>
		<div class="runningfooter" id="dochomefooter"><a href="http://www.prismtech.com/contact" shape="rect" target="_blank">Provide feedback</a><br clear="none"><hr>  
			Copyright <sup>©</sup> 2010 Zeligsoft Ltd. All rights reserved.
			
		</div>
	</body>
</html>