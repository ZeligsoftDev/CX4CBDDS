<head>
	<title>SCA Code Responsibilites</title>
	<link rel="stylesheet" type="text/css" href="../helpStyle.css">
</head>
<html>
	<body outputFile="codegenresp.html" title="SCA Code Responsibilites">
		<h1>SCA Code Responsibilities</h1>
		<p>The Main function is used to start a component or device.  It parses and manages executable parameters.  It creates a CORBA object for the 
component or device and registers the element with the CORBA namingservice.  It also starts the ORB, if required.</p>
		<p>The main CORBA class (zceMyComponentServant) for a component implements <a href="#cf"><code>CF::Resource</code></a>, 
contains <a href="#port">ports</a>, <a href="#prop">properties</a>, and <a href="#int">interfaces</a>.  It also contains the code to manage them, 
including <code>getPort</code>, <code>configure</code>, and <code>query</code>.</p>
		<p>The main CORBA class (zceMyDeviceServant) for a device implements <a href="#cf"><code>CF::Device, CF::LoadableDevice, CF::ExecutableDevice, 
and CF::AggregateDevice</code></a>, 
contains <a href="#port">ports</a>, <a href="#prop">properties</a>, and <a href="#int">interfaces</a>.  It also contains the code to manage them, 
including <code>getPort</code>, <code>configure</code>, and <code>query</code>.</p>
		<p>All the information required to generate the code to implement this functionality is contained in the visual model.</p>
		<h2>SCA Interfaces</h2>
		<p>The CF::Resource defines the external behaviour of an SCA component. For devices, there are four CF interfaces that define the external 
behaviour: <code>CF::Device, CF::LoadableDevice, CF::ExecutableDevice</code>, and <code>CF::AggregateDevice</code>.</p>
		<h3>CF::Resource</h3>
		<p><code>CF::Resource</code> standardizes how a component has to behave, including</p>
		<ul>
			<li>Creation/destruction</li>
			<li>Configure/query</li>
			<li>Start/stop</li>
			<li>Connection</li>
			<li>Built-in test</li>
		</ul>
		<p><code>CF::Resource</code> states nothing about functional code, rather it triggers the functional code.  The servant receives CORBA class for 
the <code>CF::Resource</code> interface and it triggers the functional code through standard C++ function calls.</p>
		<h3>Device CF Interfaces</h3>
		<p>These interfaces standardize how a device behaves, including:</p>
		<ul>
			<li>Creation/destruction</li>
			<li>Configure/query</li>
			<li>Start/stop</li>
			<li>Connection</li>
			<li>Built-in test</li>
		</ul>
		<p>The device interface states nothing about functional code, rather it triggers the functional code.  The servant receives CORBA class for 
the interface and it triggers the functional code through standard C++ function calls.</p>
		<h3>CF::Resource Example</h3>
		<p><code>CF::Resource::start</code> is responsible for starting the processing.  The component code manages the start.  The component code 
then informs the functional code.</p>
		<h5><a name="fig1">Figure 1: CF::Resource Example</a></h5>
		<p><img src="../images/CFResourceExample.gif" width="435" height="358" border="0" alt="CF::Resource Example"></p>
		<h2><a name="#port">Ports</a></h2>
		<p>Ports define how the component or device interacts with the environment and  thus how the functional code communicates.  Ports have specified 
interfaces: Provides ports define incoming operations and Uses ports define outgoing operations. </p>
		<p>The generated code manages the CORBA aspects of both provides and uses ports. Any incoming data from a CORBA call on a provides port is 
passed through C++ calls to the functional code. Any outgoing data is sent through a C++ call to the uses port object and the latter forwards 
to the receiver.</p>
		<h5><a name="fig2">Figure 2: Ports</a></h5>
		<p><img src="../images/Ports.gif" width="734" height="260" border="0" alt="Ports"></p>
		<h2><a name="#prop">Properties</a></h2>
		<p>A component or device can have three types of properties:</p>
		<ul>
			<li>Configure properties define configurable and query-able parameters</li>
			<li>ExecParam properties command line arguments during startup</li>
			<li>Test properties define build-in tests</li>
		</ul>
		<h3>Properties Example</h3>
		<p><code>CF::PropertySet::configure</code> (in Properties configProperties) is responsible for writing values to properties.  It passes a sequence 
of id (string) and value (any).  The component or device code manages the configure, which includes verifying the id and any.   It then forwards 
this data to the functional code through a C++ call to the function <code>config_&lt;propertyname&gt;</code>. The element code has already 
cast the data in the any field to the proper type and this is an input parameter to the <code>config_&lt;propertyname&gt;</code> function on the 
functional code.</p>
		<h5><a name="fig3">Figure 3: Properties</a></h5>
		<p><img src="../images/Properties.gif" width="435" height="358" border="0" alt="Properties"></p>
		<h3><a name="int">Interfaces</a></h3>
		<p>Interfaces are used on ports and supports interfaces.  The IDL needs to be compiled into C++ through the IDL2CPP provided with the ORB.  The 
C++ needs to be compiled through the C++ compiler.  This is all accomplished through the <strong>IDL_to_CPP &gt; GenerateCPP</strong> 
and <strong>IDL_to_CPP &gt; Compile_IDLCPP</strong> steps highlighted earlier.</p>
		<h3>See Also</h3><br><a href="codegenworkflow.html">Code Generation Workflow</a><br><a href="codegenoverview.html">Generation Overview</a><br><a href="runcodegen.html">Running Code Generation</a><br><a href="codegencodepattern.html">Code Pattern</a><div class="runningfooter" id="dochomefooter"><a href="http://www.prismtech.com/contact" shape="rect" target="_blank">Provide feedback</a><br clear="none"><hr>  
			Copyright <sup>©</sup> 2010 Zeligsoft Ltd. All rights reserved.
			
		</div>
	</body>
</html>