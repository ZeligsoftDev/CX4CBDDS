<?xml version="1.0" encoding="UTF-8"?>
<root>
	<!--helpTopics-->
	<helpTopics>
		<!--Introduction-->
		<helpTopic outputFile="splash.html" title="CX">
			<p>
			</p>
			<h1>Spectra CX</h1>
		</helpTopic>
		<helpTopic outputFile="welcome.html" title="CX Online Help">
			<h1>CX Online Help</h1>
			<p>Welcome to the CX online help system. This help system provides detailed overview and instructional 
		information.</p>
			<p>Use the table of contents or search functionality to find the information you are looking for.</p>
			<p>If you are familiar with CX and COE, start with the Modeling section. If you want to learn more about CX, COE and how 
		they work together, start with the Introduction section.</p>
			<p>Please send all comments and feedback to <a href="mailto:support@prismtech.com">support@prismtech.com</a>.</p>
		</helpTopic>
		<helpTopic outputFile="CXHelpOverview.html" title="Introduction">
			<h1>Introduction</h1>
			<p>Copyright 2010  Inc.</p>
			<p>
				<pn>ProductName</pn>
				<sup>TM</sup> is a component-oriented engineering (COE) development tool essential for the design of re-usable software 
			components that take advantage of advanced multiprocessor, multicore and 
			System on Chip (SoC) architectures. CX provides the design, development and maintenance support for system structure, and inter-component 
			communication and control, allowing 
			developers to minimize software complexity and rapidly adapt software to new platforms. CX's powerful visual system representation uses a 
			UML 2.0 interface to give 
			cross-functional and geographically-dispersed team members critical insight into system structure.</p>
			<p>CX is built on top of the IBM Rational Software Modeler (RSM) and utilizes many of its capabilities and functionality.</p>
			<p>CX enables developers to model, configure, integrate, and validate 
			 applications through a <!--<span class="sca">Software Communication Architecture (SCA)-compliant radio platforms and waveform</span>-->
			UML 2.0 interface. CX then automatically verifies your model and generates the complete set of artifacts for your domain, reducing development time from 
			months to just days. <!--<span class="sca">Moreover, CX has runtime  monitoring of applications 
				running on a Core Framework.</span>-->
			</p>
		</helpTopic>
		<helpTopic outputFile="coeanatomy.html" title="Anatomy of Component-Oriented Engineering">
			<h1>Anatomy of Component-Oriented Engineering</h1>
			<p>This topic provides an introduction to the concept of Component-Oriented Engineering.</p>
			<h2>What is Component-Oriented Engineering?</h2>
			<p>Component Oriented Engineering (COE) pulls together a number of different software engineering concepts and combines them with 
			the goal of improving the art of software development. Benefits include improvements in product quality and development 
			times (building better products faster), but also improvements in the run-time properties of a system as for example more 
			data throughput, higher density of calls or reduced processor load, memory footprint or latency.</p>
			<p>One of the benefits of COE is that it can generate code that is perfectly adapted to the environment of a particular system. In 
			many current day projects the software development team has a lot of knowledge as to how to build software for their domain. 
			COE can be customized through domain specific modeling to visualize and automate that knowledge to offload the development team and 
			allow them to make the next jump in software development productivity.</p>
			<h2>COE Concepts</h2>
			<p>The following sections details the COE concepts used to build systems.</p>
			<h3>Components</h3>
			<p>COE is based around structuring applications as assemblies of components. Components have been said to deliver benefits 
			above and beyond what objects promised to deliver in object oriented development. COE uses components to represent 
			all layers of a software-intensive system. Examples of these systems are the nodes in a wireless infrastructure network, 
			the infotainment system in a vehicle, industrial control applications, aerospace and defense applications and many more. </p>
			<h3>Interfaces</h3>
			<p>A component has a purpose -- provides a service  -- and performs that purpose well. A component may need to communicate with other 
			components to provide the service; this required communication is indicated on the interface of the component. </p>
			<p>The interface of a component is indicated through ports that provide and require services. The ports ensure the encapsulation of the 
			component and delegate communication. Ports receive messages for a component; the component performs its behaviour and send responses 
			out to the environment.</p>
			<h3>Layering</h3>
			<p>When COE refers to layers in a system, it refers to the software layers, the logical platform (or service layers) as well as the physical 
			platform layers. Every layer provides services to the layers above and uses services from the layers below.</p>
			<p>Layering is an often-used architectural concept that provides de-coupling between layers. De-coupling allows layers to evolve 
			independently of one-another, which is crucial in large development projects. Evolve independently here means that design, implementation, 
			test, release and maintenance cycles can happen for one layer independently of any other layer.</p>
			<h3>Assemblies</h3>
			<p>The layers in a COE design are built-up as assemblies of components, each component is an independent entity and encapsulates it contents 
			through its well-defined interface. Components can be assembled into larger entities. To this extent components are connected together through 
			connectors. The assembled components represent another, larger component. The final assembly of components is the layer. An assembly does 
			not limit itself to execution on a particular processor or process space.</p>
			<p>The whole nature of an assembly is a set of communicating components. The assembly description is platform independent by nature; 
			deployment (allocation) of parts of the assembly to execution environments is deferred until a later part of the development cycle. 
			This provides support for late-binding, which provides the development team with the option to delay decisions until later in the development 
			process where they have more information to base these decisions on. It also offers the design team the ability to revisit these decisions 
			and make changes easily and unobtrusively.</p>
			<h3>Domain Specialization</h3>
			<p>The concept of a component that we introduced is an example of a domain specific concept. It embodies a well-encapsulated, structural 
			entity that a developer can use to describe part of the behavior of the system in a re-usable container. The entity can then be generated 
			into compiled and executable source code.</p>
			<p>The component concept is but one of many cases where it can be beneficial for the software development team to customize the language 
			they use to conceive, design and build systems - their domain. The ability to customize the software tools for a domain is known as 
			Domain Specific Modeling (DSM) using Domain Specific Languages (DSL) or domain specialization. Some other examples of concepts that can be 
			embodied in Domain Specific Languages are the events and alarms in network infrastructure systems, traffic events in an infotainment device, 
			and configuration of specific paper types in a high-speed printer.</p>
			<p>A DSL is created by the domain experts, it captures the knowledge that the software development team has about the domain that they are 
			building products for. Translation from the domain concepts to implementation concepts is also built by these domain experts. The result 
			is really a development environment with a raised abstraction level, it re-uses the domain knowledge of the development team to increase 
			productivity.</p>
			<h2>Component Details</h2>
			<p>The following sections provide more detail on the ideas and concepts introduced above.</p>
			<h3>Component Interface</h3>
			<p>The component interface defines the provided and required interfaces that the component uses to communicate with its environment. 
			The component interface also defines properties. Properties are configurable parameters of the component interface, it allows the 
			interface to be configured for a specific use. For example, if the component interface describes the interface for a phone switch, 
			a property could describe the maximum number of calls that the component is able to handle. </p>
			<p>The communication a component can perform is done through ports, named and typed elements on the components interface that allow 
			for the receipt and sending of named messages with information. The messages on the port are defined through PortTypes. PortTypes 
			are a set of incoming and outgoing interfaces used for communication.</p>
			<p>Component interfaces are platform independent by definition. The interface describes the communication that a component will be able to 
			provide, and has no relation to the communication technology that will be used in the final implementation.</p>
			<h3>PortTypes and Interfaces</h3>
			<p>Interfaces are a grouping of cohesive operations. That is, operations that are related and are used to achieve a particular purpose. 
			For example a callSetup interface with addCall and removeCall operations, or a locationInformation interface with a currentLocation operation. 
			Interfaces are uni-directional. </p>
			<p>The operations within an interface can be either synchronous or asynchronous, blocking or non-blocking respectively.</p>
			<p>PortTypes define a complete bi-directional collaboration between two parties through a set of incoming and outgoing interfaces. PortTypes 
			are applied to ports.</p>
			<p>Every PortType also has an inverse, which conjugates the incoming and outgoing interfaces. A port based on PortType X can communicate 
			with a port based on the inverse of PortType X. PortType compatibility is defined as the fact that the receiver needs to be able to 
			receive at least those operations that the sender is able to send.</p>
			<h3>Component Realization</h3>
			<p>A component interface is realized by a component realization, the realization is the modeling entity that ensures that the messages on 
			the ports of the component interface are handled. A single component interface can be realized by one or more component realizations.</p>
			<p>A component realization can come in the form of structure, that is, the component contains an assembly of component parts. The messages 
			on the interface of the component are delivered to its parts for processing. The parts within the realization are defined by component 
			interfaces, which themselves have component realizations, thereby allowing for an unlimited level of hierarchical structure.</p>
			<p>A component realization can also come in the form of a behavioural description. This behavioural description can be code in a programming 
			language (C, C++, Java, Ada, Perl, etc), but can also be a description in other modeling paradigms, for example IBM Rational RoseRT or 
			IBM Rational Rhapsody.</p>
			<p>Component realizations can contain a mix of behaviour and structure. Some of the ports on a component interface can be implemented in 
			structure and some of it in behaviour.</p>
			<h3>Component Structure</h3>
			<p>The component realization can be defined through structure, an assembly of component parts connected through connectors. </p>
			<p>A component part defines an instance of a component interface that will be present at run-time, a part is to a component-interface 
			what an attribute is to the class that defines that attribute (in C++ or Java for example). The ports on the parts in a structure can be 
			connected together, only compatible ports can be connected together.</p>
			<h3>Component Implementation</h3>
			<p>As mentioned in the previous section, a component realization can contain behaviour in source code format, either 3GL type or executable 
			languages like executable UML. When a component realization contains behaviour, then it also contains one or more implementation. The 
			reason for the implementation is to represent the platform specific information with relation to the code. These dependencies are settings 
			like compilation flags, libraries, inclusion paths and the like. The implementation also contains code that is specific to a particular
			 operating environment, for example code to handle device level issues if required.</p>
			<p>Platform independence is important in embedded systems. One question to answer when striving for platform independence is what the 
			application needs to be independent of. In COE the separation between Component Interface, Component Realization and Component Implementations 
			provides this flexibility with regards to independence.</p>
			<h2>Physical and Logical Layers</h2>
			<p>The days that an embedded system was just a couple of threads, executing on an embedded processor are past. Today's embedded systems 
			contain multiple process spaces, multiple processors, fast communication busses and so forth.</p>
			<p>COE recognizes this and allows the design team to express these concepts, again, in a domain specific fashion. The logical and physical 
			layers are model-representations of these layers. The layers are usually the responsibility of a 'platforms' or 'HAL' team, though this 
			team has different names in different organizations. The model is there to represent the artifacts that this team has developed.</p>
			<h3>Physical Platform</h3>
			<p>This layer describes the actual processing environment that the software will execute on. In many domains this is an optional layer. 
			The physical layer is important if the design team wants to include real-time considerations in their modeling, for example by using the 
			MARTE  standard.</p>
			<p>Concepts in the physical platform would be the processors used, for example PPC, ARM, or system-on-chip processors like the TIC6488. 
			Systems can be as simple as a single board, or as complex as a multi-card ATCA telecom system.</p>
			<p>The physical platform is typically abstracted through the logical platform.</p>
			<h3>Logical Platform</h3>
			<p>The logical platform describes the places where software can be executed. </p>
			<p>Most embedded systems use the concepts of process, thread and logical communication bus. However, depending on the domain this could be a 
			'logical device' (SCA), CORBA bus, TIPC bus and so forth. Buses can be best effort based, like TCP/IP, or more deterministic, they can 
			send data immediately for low latency, or they can send data in a buffered fashion.</p>
			<p>All these concepts can be described in the DSL that describes this logical layer. The developer can then be presented with multiple 
			different logical layers, one for the current hardware set and some for possible evolutions of the physical hardware sets that 
			the product will need to support.</p>
			<h2>Deployment and Configuration</h2>
			<p>Deployment is a new concept introduced by COE, it brings together the software layers with the platform layers. It models a mapping from 
			software components and the connections between these components to the different platform layers. The deployment can be seen as a 
			model-based representation of something that many teams call 'integration'.</p>
			<p>A deployment can include a configuration. A configuration assigns values to the properties on the component interface. Take, for example a 
			PBX, different configurations of the PBX can exist, with a maximum number of calls and with a maximum number of incoming/outgoing lines. 
			These types of properties can be configured on the Deployment.</p>
			<p>The deployment and configuration is the final step in integrating software on hardware, it describes which software subsystems need to be 
			included, how to configure them and how to map them to the execution environment. </p>
			<p>Once the deployment and configuration has been modeled we have all the information that we need to do efficient and finely tuned code 
			generation. The deployment is where 'the rubber hits the road', the software is assigned to hardware. Any software application can be mapped 
			to many hardware configurations in a number of different ways.</p>
			<p>The deployment and configuration is, as with anything, domain specific. The SCA domain for example abstracts all communication 
			through CORBA and hence mapping of connections to busses is irrelevant, while in a baseband DSP domain this is a major point of concern 
			and optimization is critical.</p>
			<h2>Validation and Transformation</h2>
			<p>Modeling of course is not a goal; it is a means to an end. Modeling is often done primarily for communication and documentation. However, 
			the DSL approach in COE makes the model more powerful, it can now be used to validate designs as well as transforming of designs into 
			high performance executable code.</p>
			<h3>Validation</h3>
			<p>Validation of an existing model evaluates the deployment and flags problems when they are found. Problems could be entirely contained within the 
			software layer, for example incompatible software components that are connected, say component A provides an interface foo, where component 
			B requires interface bar from A. Validation will flag this to the designer and allow him to resolve these issues.</p>
			<p>Validation is something that the design team can use in early design days and express how they think the system will perform. These 
			requirements are part of the model and can be refined during the development of the system. Treating these requirements as first class model 
			entities avoids costly surprises late in the development cycle.</p>
			<p>Validation also allows the team to explore alternate designs and receive immediate feedback on whether certain designs are feasible. The 
			validation provides information on whether timing constraints can be met or not.</p>
			<h3>Transformation</h3>
			<p>Transformation deals with the topic of transforming model elements into executable source code. Executable source code can be in the 3GL 
			category (C, C++, Java), or can be other models (such as IBM Rational RoseRT or IBM Telelogic Rhapsody).</p>
			<p>COE can use both the domain specific information as well the information in the deployment during generation. The domain specific information
			 provides additional information about the type of the model element, as mentioned before, it adds additional levels of abstraction to the 
			 modeling space, abstractions that the generator understands and can use.</p>
			<p>This deployment has the information for all of the usages of a particular entity or component and hence can optimize generation of that 
			entity based on 'global information'. COE also knows how the entity is used within the context of the logical platform and can optimize 
			based on that.</p>
		</helpTopic>
		<helpTopic outputFile="aboutcx.html" title="About CX">
			<h1>About CX</h1>
			<p>CX is the latest product offering in Zeligsoft's Component-Oriented Engineering (COE) methodology-driven suite. CX is built on the 
			Eclipse and Rational Software Modeler development environments. CX has been designed to integrate fully with these development
			environments - taking advantage of key <RSx>RSx</RSx> and Eclipse concepts and capabilities. CX is an extension of this functionality, giving you 
			the benefit of a system-centric software development tool essential for the design of re-usable software components that take advantage of 
			advanced multiprocessor, multicore and 
			System on Chip (SoC) architectures. CX provides the design, development and maintenance support for system structure, and inter-component 
			communication and control, allowing 
			developers to manage software complexity and rapidly adapt software to new platforms. CX's powerful visual system representation is 
			UML 2.0 compliant to give 
			cross-functional and geographically-dispersed team members critical insight into system structure.</p>
			<p>CX is a domain specific modeling environment, as such domain specific information can be installed. Contact Zeligsoft 
			to find out more about domain support. Domains can be specialized within CX to facilitate your use patterns and domain 
			requirements.</p>
		</helpTopic>
		<helpTopic outputFile="keyconcepts.html" title="Key Concepts">
			<h1>Key Concepts</h1>
			<p>Use this topic to learn more about CX, COE, SCA, and UML modeling. This topic provides detailed information about the key concepts 
			you need to understand and become familiar with. </p>
			<h2>Application</h2>
			<p>An executable software program that may contain one or more modules. The executable software exhibits pre-determined functionality.
			In COE an application is created by assembling a set of components and providing connections between compatible ports 
			(formal interfaces) on adjacent components. Using Model Driven Design (MDD) techniques, individual components and the overall 
			application model can be validated for correctness at any point in the development process.</p>
			<h2>Application Layer</h2>
			<p>This layer describes the true software customization of the logical platform. This is where the user puts the added value.</p>
			<h2>Assembly</h2>
			<p>An assembly is a structure of communicating components. Parts of an assembly are defined by component interfaces. Connections 
			in the assembly indicate communication between component ports.</p>
			<h2>Attributes</h2>
			<p>An attribute is a property that describes a level of capability available in a device or required by a resource. 
			A significant piece of data owned by a class, often containing values describing each instance of the class. Besides the attribute name 
			and a slot for the attribute value, an attribute may have specified visibility, type, multiplicity, default value, and property-string.</p>
			<h2>Class</h2>
			<p>The primary declarative construct of Object-Oriented Programming; a cohesive unit of attributes and operations; a compile-time 
			template for an Object. This blueprint includes attributes and methods that the created objects all share.</p>
			<h2>Class Diagram</h2>
			<p>A type of static structure diagram that describes the structure of a system by showing the system's classes, their attributes, 
			and the relationships between the classes. 
			The class diagram shows how the different entities relate; in other words, it shows the 
			static structures of the system. A class diagram can be used to display logical classes, which are typically the kinds 
			of things the business people in an organization talk about. Class diagrams can also be used to show implementation classes, which are the 
			things that programmers typically deal with. 
			A class is depicted on the class diagram as a rectangle with three horizontal sections. The upper section shows the class's name; 
			the middle section contains the class's attributes; and the lower section contains the class's operations (or "methods").</p>
			<h2>Component</h2>
			<p>
				<a href="http://www.omg.org/">OMG</a> defines a component as "A modular part of a system that encapsulates its contents and whose 
			manifestation is replaceable
         within its environment.  A component defines its behavior in terms of provided and required interfaces. As such, a component
         serves as a type, whose conformance is defined by these provided and required interfaces (encompassing both their static as
         well as dynamic semantics)." A component is an encapsulated unit of functionality with a well-defined interface that allows it to 
				 connect to other components, and be independently deployed. Component-based applications are defined by assembling components.
				 A component represents a software module (source code, binary code, executable, DLL, etc.) with a well-defined interface. The interface 
				 of a component is represented by one or several interface elements that the component provides. Components are used to 
				 show compiler and run-time dependencies, as well as interface and calling dependencies among software modules. They also 
				 show which components implement a specific class.</p>
			<h2>Component-Oriented Engineering (COE)</h2>
			<p>A software development methodology focused on addressing the challenges of complex embedded systems characterized by distributed 
			applications and heterogeneous multiprocessor platforms. COE derives its key attributes from: Component-Based Development (CBD), Model 
			Driven Development (MDD), and Agile Software Development (ASD). Support for the QoS analysis and validation form an integral part of the 
			methodology and are used throughout the process. From a life cycle perspective, COE focuses on the component-based aspect of the entire 
			product development life cycle, including component definition, system integration, and testing from individual components to 
			integrated systems.</p>
			<h2>Component Interface</h2>
			<p>Defines the provided and required interfaces that the component uses to communicate with its environment. A component interface
			also defines the properties of the component. Properties are the configurable parameters of the component interface, allowing the 
			interface to be configured for a specific use.</p>
			<p>In COE, a component interface can have multiple realizations, hence support multiple different structures to delegate behavior, or 
			different code realizations for different languages.</p>
			<h2>Component Realization</h2>
			<p>This is a modeling entity that ensures that the messages on the ports of the component interface are handled correctly. A 
			component interface is realized by a component realization. A single component interface can be realized by one or more component
			realizations. Component realizations can contain code and behavior.</p>
			<h2>Communication Path</h2>
			<p>A connection between two or more physical elements.</p>
			<h2>Configuration</h2>
			<p>
				<a href="http://www.omg.org/">OMG</a> defines a configuration as "a set of default run-time application options used to customize non-deployment related 
         			application features."</p>
			<h2>Connection</h2>
			<p>A connection is used to describe connections from or to a component port at runtime. A connection is either a communication
         path among the ports of two or more subcomponents allowing them to communicate with each other, or it is a communication path between an assembly's external
         ports and an assembly's subcomponents that delegates the external port's behavior to the subcomponent's ports. The endpoint of a connection may also refer to
         a location outside the assembly.</p>
			<h2>Dependency</h2>
			<p>A relationship that indicates that one component or device depends on a specific property of another component or device.</p>
			<h2>Deployment</h2>
			<p>The deployment brings together the software layer with the platform layer. It models a mapping from software components and the 
			connections between these components to the different platform layers. A deployment can be seen as a model-based representation of
			an "integration". The deployment is 
			the first design element from which code and other related artifacts can be generated for the application and optimized for the 
			allocation decisions.</p>
			<h2>Deployment Specification</h2>
			<p>A deployment specification is essentially a configuration file such as an XML document or a text file that defines how an
         artifact is deployed on a node. </p>
			<h2>Device</h2>
			<p>A device refers to a logical hardware element (typically a module performing a function or set of functions identified in
         its device profile).  A logical device interface is an abstraction of a hardware device that defines the capabilities, attributes, and 
				 interfaces
         for that device.</p>
			<h2>Domain Specialization</h2>
			<p>Customization of the COE development environment is provided by domains, which tailor to the COE framework for platform 
			intelligence and component model frameworks. Domains also include model transformation engines that correspond to the selected 
			component framework. A domain is 
			an entity that encapsulates specific platform knowledge, component framework information and associated transformation engines.</p>
			<h2>Execution Environment</h2>
			<p>In UML modeling, an execution environment is a type of node that represents a particular execution platform, such as an operating
         system. You can use execution environments to describe the context in which the execution of a set of deployed components
         takes place.  The properties of an execution environment for a given node/device type will be different and based on both
         the type and the domain profile in which the execution environment is defined.</p>
			<h2>Implementation</h2>
			<p>Concerns the code that implements a component or device definition or about the components which make up an application. 
         Think of this as the executable or shared library that gets loaded to the target platform.</p>
			<h2>Interface</h2>
			<p>A named set of operations that characterize the behavior of an element. A defined communication boundary.</p>
			<h2>Layer</h2>
			<p>In COE, a layer can represent a layer at the software platform, logical platform, and physical platform layer.</p>
			<h2>Logical Layer</h2>
			<p>Represents the service layer that represents the RTOS, RTOS services, drivers, and middleware layers. It also represents the
			execution environment such as processes, threads, and virtual machines. The logical layer can consist of multiple layers.</p>
			<h2>Monolithic Implementation</h2>
			<p>A component or device's monolithic implementation is an implementation of the component's definition. Usually it is associated with source 
			code or an executable. Instances of either component/device definitions or monolithic implementations are added to an application.</p>
			<h2>Node</h2>
			<p>In UML modeling, nodes are model elements that represent the computational resources of a system, such as personal computers,
         sensors, printing devices, and servers. Nodes can be interconnected by using communication paths to describe network structures.</p>
			<p>A run-time computational resource that only has at least memory and often processing capability. Run-time implementation
         objects and components may reside on nodes.</p>
			<h2>Part</h2>
			<p>An element within an assembly that represents a defined element's part within that assembly.</p>
			<h2>Physical Layer</h2>
			<p>Represents the physical hardware. This layer provides the grounding of the entire model.</p>
			<h2>Platform</h2>
			<p>Typical platform layers include a hardware layer composed of different types of processors (GPP, DSP, FPGA), memory buses, and inter 
			connections, and the RTOS layer and middleware layers that provide services to application components. Similarly to applications, platform 
			layers can be individually defined in a component-based manner.</p>
			<h2>Port</h2>
			<p>A port identifies a source/producer (Provides Port) or a sink/consumer(Uses Port) for data and/or commands. A Port specifies
         the types of data and commands accepted.</p>
			<h2>Property</h2>
			<p>A Property is a variable that contains a value of a specific type. Configuration Properties are parameters to the Configure
         and Query operations. Allocation Properties define the capability levels required of a Device by a Resource.</p>
			<h2>Properties Descriptor</h2>
			<p>A Properties Descriptor is an element of the Profile that contains information about the properties applicable to a software
         package or a device package such as configuration, test, execute, and allocation types.</p>
			<h2>Software Communications Architecture (SCA)</h2>
			<p>Industry specific component frameworks for software defined radio.</p>
			<h2>Structural Realization</h2>
			<p>A structural realization realizes the structural elements of the component. It realizes this in either structure, code (operations),
statemachines, mathematical functions or other concepts as defined in the domain.</p>
			<p>This realization should be platform independent. That is, able to support all intended platforms for a particular design. The component implementation can be
used to add platform specifics if required. </p>
			<h2>CX Component Diagram</h2>
			<p>A CX Component Diagram is created automatically with each model project creation. It is in this diagram that you 
			do your modeling and "work". For ease of use, you may want to create a diagram for each package - this way you can better visually organize 
			your elements.</p>
		</helpTopic>
		<helpTopic outputFile="contactZeligsoft.html" title="Contact Information">
			<h1>Contact Information</h1>
			<h3>Support</h3>
			<ul>
				<li>
					<strong>email: </strong>
					<a href="mailto:Product Support "><ps>productSupport</ps></a>
				</li>
					<li>
						<strong>North America phone: </strong>(+781-569-5819)
					</li>
					<li>
						<strong>UK phone: </strong>(+44 191 497-9900)
					</li>
				<li>
					<strong>phone hours: </strong>0900-1700 ET</li>
			</ul>
			<h3>Documentation Feedback</h3>
			<p>
				<a href="mailto:Product Support "><ps>productSupport</ps></a>
			</p>
		</helpTopic>
		<!--Working with CX section content-->
		<helpTopic outputFile="workwithcx.html" title="Working with CX">
			<h1>Working with CX</h1>
			<p>This section provides you with a workflow overview and some basic information about the user interface.</p>
			<ul>
				<li>
					<a href="guiConventionsOverview.html">User Interface Conventions</a>
				</li>
				<li>
					<a href="workflow.html">CX SCA Workflow Overview</a>
				</li>
				<li>
					<a href="cxpreferences.html">Preferences</a>
				</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="guiConventionsOverview.html" title="User Interface Conventions">
			<h1>User Interface Conventions</h1>
			<p>
				<pn>ProductName</pn> is built on the Eclipse Workbench and <RSx>RSx</RSx> environments. As a result the CX user interface simply re-uses the conventions
			and containers provided by Eclipse and <RSx>RSx</RSx>.</p>
			<p>For details about the user interface and how to manipulate it, please refer to the Eclipse and <RSx>RSx</RSx> help topics devoted to the user interface. There 
			are a number of tutorials that will help you become familiar with your work environment.</p>
			<p>CX specific capabilities including windows, wizards, and pop-up menus behave the same way as the Eclipse and <RSx>RSx</RSx> elements. Any CX specific 
			user interface elements are highlighted and noted in the appropriate online help topics.</p>
			<h3>Perspectives</h3>
			<p>A window contains one or more "perspectives". A perspective defines the initial set and layout of views in  the window. Each
			perspective provides different functionality to accomplish a specific task with specific resources.</p>
			<p>The CX perspective has views for modeling components and applications and generating code. The debug perspective has
 views of tools for target debug and the 
C/C++ perspective has information about building code.</p>
			<h3>Quick UI Reference</h3>
			<p>The following list provides you with a quick reference overview of the UI:</p>
			<ul>
				<li>The <a href="#pe">Project Explorer</a> view provides access to all model elements.</li>
				<li>Model elements are contained in a collapsible folder tree or "Packages".</li>
				<li>The <a href="#pal">Palette</a> provides new element types for selecting and dropping into a diagram.</li>
				<li>The <a href="#pv">Properties View</a> provides access to details of a selected element.</li>
				<li>The Console view provides status information such as the build progress.</li>
				<li>The Problem view displays problems such as problems with validation or compilation.</li>
				<li>The Outline View shows the entire view of the selected diagram.</li>
			</ul>
			<h3>
				<a name="pe">Project Explorer</a>
			</h3>
			<p>
				<img src="../images/projectexplorer.gif" border="0" alt="Project Explorer"></img>
			</p>
			<h3>
				<a name="pal">Palette</a>
			</h3>
			<p>
				<img src="../images/palette_collapsed.gif" border="0" alt="Palette Collapsed"></img>
			</p>
			<h3>
				<a name="pv">Properties View</a>
			</h3>
			<p>
				<img src="../images/propertiesview.gif" border="0" alt="Properties View"></img>
			</p>
			<p>When you are modeling in CX, you are working in the <pn>ProductName</pn> Perspective. For information about perspectives and views, refer to the Eclipse and <RSx>RSx</RSx> online help.</p>
		</helpTopic>
		<helpTopic outputFile="cxpreferences.html" title="Preferences">
			<h1>Preferences</h1>
			<p>CX preferences are organized into three categories: Modeling, SCA, and Validation.</p>
			<p>The Modeling preferences include:</p>
			<ul>
				<li>Post-fix for Inverse Port Type: allows you to control how the inverse port type is named. By default this attribute is set to Inv.
		</li>
				<li>Make location: location of the make application used to build applications. Type the location or click Browse.</li>
			</ul>
			<p>The SCA preferences include configuring two mandatory attributes (CORBA Version and Repository Version):</p>
			<ul>
				<li>CORBA Version: the default value is 2.2. Ensure this attribute is configured to match your system. This is a mandatory attribute.</li>
				<li>Repository Version Identifier: the default value is 1.0. This is a mandatory attribute.</li>
				<li>Author properties: configure the Name, Company, and Webpage properties. These are optional attributes.</li>
				<li>Component wizard options: configure the default executable file extension for elements created with the Component Creation Wizard.</li>
				<li>SCA 2.2.2 Extension: select when modeling SCA 2.2.2 Extension elements. Enables SCA 2.2.2 Extension DTD files.</li>
			</ul>
			<p>The Validation preferences involve a number of constraints settings. Select a constraint to view the constraint ID and description. 
		This determines which validation tests are run on validation.</p>
			<p>To configure CX preferences, do the following:</p>
			<ol>
				<li>From the <strong>Windows</strong> menu, select <strong>Preferences</strong>.</li>
				<li>In the Preferences window, expand <strong>Zeligsoft</strong>.</li>
				<li>Make your changes and click <strong>Apply</strong>. </li>
				<li>To restore preference settings to the default values, click <strong>Restore Default</strong>.</li>
			</ol>
			<p>To learn more about <RSx>RSx</RSx> preferences, refer to the <RSx>RSx</RSx> online help.</p>
		</helpTopic>
		<!--Getting Started section content-->
		<helpTopic outputFile="workflow.html" title="CX SCA Workflow Overview">
			<h1>CX SCA Workflow Overview</h1>
			<p>Use this workflow overview as a guide when planning your modeling process. Your model may contain other elements and properties, but 
			you can use this as a "loose" guide to help you understand the modeling workflow in CX.</p>
			<h3>Create a new project and model.</h3>
			<p>Open the <pn>ProductName</pn> perspective and create a new SCA model project. The name of the project and the model will appear in the Project 
			Explorer. The CDT Project Name determines the name of the folder source code will be generated to.</p>
			<p>This project can contain one or more SCA models. 
</p>
			<p>When planning your model development, you may want to consider using multiple diagrams to visualize model elements and
			the relationships.</p>
			<h3>Model Waveform</h3>
			<ol>
				<li>Create a new package.</li>
				<p>You can use packages to group or contain common elements and to help you better organize your elements.</p>
				<p>In this workflow example, this package will represent a controller.</p>
				<li>Within this new package, create a Zeligsoft Component Diagram.</li>
				<p>Creating a diagram for each package allows you to manage the visual modeling more easily and to prevent diagrams from becoming 
			cluttered.</p>
				<li>In the Zeligsoft Component Diagram, create the following elements:</li>
				<ul>
					<li>component interface</li>
					<li>component structural realization</li>
					<li>implementation artifact: you can create as many implementations as required by your system. For example, you may want to create an 
implementation for each supported operating system.</li>
					<li>interface realization: shows the relationship between the component interface and the interface it implements (usually CF::Resource interface)</li>
					<li>generalization: shows the relationship between the component structure realization and the component interface </li>
				</ul>
				<p>Note: The component wizard can be used for steps 1, 2, and 3.</p>
				<li>To manage the implementation dependencies such as the operating system, processors, etc. add:</li>
				<ul>
					<li>operating system </li>
					<li>operating system link: connect the implementation artifact and operating system</li>
					<li>processor </li>
					<li>processor link </li>
				</ul>
				<li>Create PortTypes and add ports on the component interface.</li>
				<li>Create other components.</li>
				<br>Create a new package and Zeligsoft Component Diagram to represent your application. In the Zeligsoft Component Diagram: </br>
				<ul>
					<li>create an application and resize it</li>
					<li>drag the component structural realization you created above from the Project Explorer onto the application structure - this creates 
			component parts</li>
					<li>using the connector tool, connect the ports</li>
				</ul>
				<li>Validate your application and components.</li>
			</ol>
			<h3>Elaborate Elements</h3>
			<p>Now that you have created your elements, you can define them by editing the properties, adding property types from the palette, and 
			adding user-defined attributes.</p>
			<p>Use enumeration property type, primitive property type, struct property type, and struct sequence property type to define element properties. 
			As well you can add property dependencies to further define elements and element relationships.</p>
			<h3>Model Platform</h3>
			<ol>
				<li>Create a new package and diagram for the platform.</li>
				<li>Within this package, create a new package and diagram to represent a node.</li>
				<li>Within the platform package, use the Component Wizard to create the device.</li>
				<li>Define attributes for the device.</li>
				<li>Add the device to the node.</li>
				<p>In the Project Explorer, select the device structural realization and drag it onto the node in the Zeligsoft Component Diagram.</p>
				<li>Add a DeviceManager and DomainManager to the Node.</li>
				<li>Validate the Platform, Node, and Devices.</li>
			</ol>
			<h3>Generate Code</h3>
			<ol>
				<li>Select the application and generate the component source code and the XML descriptors. Select the node and generate the device source 
			code and XML descriptors.</li>
				<li>Add user code to the worker methods.</li>
				<li>Compile the source code.</li>
			</ol>
		</helpTopic>
		<!--How to Use CX section content-->
		<helpTopic outputFile="usecx.html" title="Modeling">
			<h1>Modeling</h1>
			<p>Use the topics in this section to learn how to use CX and how to take advantage of the inherited <RSx>RSx</RSx> and Eclipse functionality.</p>
			<p>This section provides detailed "how to" information that will guide you through the process of creating, editing, and managing 
			your model and its elements. Content is organized in a systematic order to help guide you through the workflow process.</p>
			<p>Model elements comprise the model. They include packages, components, devices, CF  elements, applications, nodes, deployments, ports 
			and interfaces and the connections between them. Model elements can have SCA and user-defined attributes. Relationships can be 
			defined between model elements. Most model elements have graphical representations.</p>
			<h3>Modeling Best Practices</h3>
			<p>When defining your model it is key to remember that the source and target have important implications - think about who depends on what:</p>
			<ol>
				<li>Does my definition need a property from another definition?</li>
				<li>Does my definition need a property from an implementation?</li>
				<li>Does my implementation need a property from a definition?</li>
				<li>Does my implementation need a property of an implementation?</li>
			</ol>
		</helpTopic>
		<helpTopic outputFile="PlatformModeling.html" title="Application and Platform Modeling">
			<h1>Application and Platform Modeling</h1>
			<h2>Components</h2>
			<p>Components encompass discrete responsibilities within the system, each with a behavioral and structural aspect. CX allows you to completely 
			describe the external interface of components using abstractions, including method calls and data transportation</p>
			<h2>Applications</h2>
			<p>CX permits the expression of a clear separation between application and platform model elements with comprehensive application and  
			logical platform modeling capabilities. UML 2 based modeling techniques are used to organize and visually represent the system structure. 
			The system level complexity (for a single or multiple applications) is managed through organizing software through decomposition and multiple 
			views.</p>
			<p>Application and platform dependencies are clearly expressed in the CX modeling environment. The functional aspects of a component are defined separately from its control and 
			communications aspects, which results in easy-to-manage, re-usable software components that are interconnected and assembled into applications. These applications are easily 
			ported to other platforms, and combined with other software applications.</p>
			<p>Visual representation ensures that component dependencies are explicit and easy to manage. Dependencies such as a 
component requiring another component, a service or specific hardware are depicted through visible and programmable elements accessible by all team members, regardless of location.</p>
			<p>CX allows you to represent multiple layers of the architecture, regardless of the complexity of each layer or dependencies present from layer to layer. As such, CX 
			scales from very simple applications and platforms to the most complex of systems, with powerful component design techniques supporting the reuse of design elements at 
			whatever layer you want.</p>
			<p>The model can be verified, at any level, for correctness against standard modeling rules.</p>
			<h2>Logical Platform</h2>
			<p>A platform model describes a set of technical concepts representing its constituent elements and the services it provides. It also 
			specifies constraints on the use of these elements and services by other parts of the system. Platform Modeling lets you model logical 
			platforms. CX lets users fully specify the platforms that their applications will be deployed to.</p>
			<p>CX enables designers to specify complete component-based software architectures that represent the system from multiple perspectives,
 multiple view-points, and multiple levels.</p>
			<p>Modeling a logical platform allows you to specify the system's logical aspects, covering the execution environment, services, and 
			higher-level communication mechanisms available on the platform. </p>
			<p>At the logical platform level, services whether security, logging, inter-process, or intra-process communications required by application 
components are provided through ports with interfaces that capture the service access methods. The service could represent a timer, a driver, or 
similar concept.</p>
			<p>By first modeling the services, CX can then generate optimized service access and communication code for the target system, freeing you from 
having to write this code and enabling you to focus on the behavioral aspects of the component. CX provides out-of-the-box model element 
definitions for the most common services and embedded system execution environments, such as RTOSs, communications middleware, and encryption and 
security layers.</p>
			<p>CX supports design flows beginning with any part of the system. You can begin defining at any level, moving up to application or down to the 
logical layer.</p>
		</helpTopic>
		<helpTopic outputFile="introInterface.html" title="IDL Modeling, Import, and Generation">
			<h1>IDL Modeling, Import, and Generation</h1>
			<p>CX can be used to model new IDL or import existing IDL and generate IDL.</p>
			<p>An IDL interface is a set of operations and attributes used for CORBA communication. Ports on components are a realization of these 
interfaces and are used to allow the component to communicate with its environment and the environment to communicate with the component.
</p>
			<p>The component does not know who is using its interface nor does the environment know about the internals of the component. All communication 
			must go through the component's ports. This facilitates reuse of interface-based components in multiple applications.</p>
			<h2>Modeling IDL</h2>
			<ol>
				<li>In the <strong>Palette</strong>, open the <strong>CORBA</strong> drawer and select <strong>IDL File</strong>.</li>
				<li>Drop the <strong>IDL File</strong> onto your diagram and draw the element quite large.</li>
				<li>In the element, click the small arrow/triangle so that it is open or pointing down.</li>
				<p>This enables you to add elements to the <strong>IDL File</strong> element.</p>
				<li>In the <strong>Palette</strong>, select <strong>Module</strong>.</li>
				<li>Drop the <strong>Module</strong> onto the <strong>IDL File</strong> in the compartment you opened.</li>
				<li>In the <strong>Module</strong>, click the small arrow/triangle so that it is open or pointing down.</li>
				<p>This enables you to add elements to the <strong>Module</strong> element.</p>
				<li>In the <strong>Palette</strong>, select <strong>Interface</strong>.</li>
				<li>Drop the <strong>Interface</strong> onto the <strong>Module</strong> in the compartment you opened.</li>
				<li>Using the <strong>Properties View</strong> &gt; <strong>Attributes</strong> tab you can add and 
			define CORBA attributes on this interface.</li>
				<p>To show the attributes in the diagram, select the <strong>Appearance</strong> tab and enable 
			<strong>Show Attributes</strong>.</p>
				<p>If you added attributes to the interface, you need to ensure the correct stereotype is applied. In the 
			<strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab, click <strong>Apply Stereotype</strong> 
			and select <strong>CORBAAttribute</strong>.</p>
				<p>Using the <strong>Properties View</strong> &gt; <strong>Operations</strong> tab, you can add operations to the 
			interface. Ensure you apply the <strong>CORBAOperation</strong> stereotype to the operation.</p>
				<li>To add a CORBA Exception to the module, in the <strong>Palette</strong>, select <strong>Exception</strong> and 
			drop the element into the compartment on the module. To show the exception, use the <strong>Appearance</strong> 
			tab in the <strong>Properties View</strong>.</li>
				<li>A CORBA Constant can be added at the interface or module level. To add a CORBA Constant at the 
			interface level, add an attribute and set the <strong>Stereotypes</strong> to <strong>CORBAConstant</strong>. 
			To add a CORBA Constant at the module level, in the <strong>Palette</strong>, select <strong>Constant</strong> and 
			drop this onto the module.</li>
			</ol>
			<p>Using the <strong>UML Properties</strong> option on the right-click pop-up menu you can do the following:</p>
			<ul>
				<li>control the order of elements in the generated IDL file: select <strong>Package Element</strong> and use the 
			arrows to control the element order.</li>
				<li>define an exception on an operation on an interface: select <strong>RaisedException</strong> and then select 
			the exception.</li>
			</ul>
			<h2>IDL Import</h2>
			<p>CX IDL import will merge external IDL changes into existing IDL elements in the CX model. All model references to the 
			IDL elements are maintained in the model. Because of this CX supports iterative workflows where IDL is changed outside the 
			CX and re-imported. </p>
			<p>To import the IDL into your model do the following:</p>
			<ol>
				<li>Copy and paste the IDL file into your project folder in <strong>Project Explorer</strong>.</li>
				<li>In the <strong>Project Explorer</strong> select the <strong>Model</strong> and using the <strong>CTRL key</strong>, select 
				the <strong>IDL files or folder</strong>. </li>
				<li>With both elements selected, right-click and from the context menu select <strong>Import</strong>. Select  
<strong>Spectra CX</strong> and select <strong>IDL</strong>. The Import window will open. </li>
				<li>Browse to the Source folder and select the IDL to import. </li>
				<li>Browse to the SCA model where the IDL is to be imported to. </li>
				<li>Add any <strong>include directories</strong> and <strong>defines</strong> that are necessary for the IDL. </li>
				<li><strong>Files to exclude</strong>. This is used to exclude IDL files from IDL import. This could be IDL files that are 
				referenced by the IDL to be imported. An example where this is useful is when importing IDL that references the SCA CF.idl. 
				This IDL is already present in the SCA model in a read only library. Since this element is read only, if this file is not 
				excluded from the import, a new CF element will be created in the model. If the file is excluded, the existing CF element 
				will be referenced in the model</li>
				<li>Click <strong>OK</strong>. </li>
			</ol>
			
			<p>After import, the IDL Model Elements should appear in the model in an IDL_Import_Results package. Once all files have been imported, 
			the IDL directory can be deleted from the Spectra CX Project.</p>

			<h2>Generating IDL</h2>
			<p>To generate your IDL file, select and right-click the <strong>IDL File</strong> and from the context menu, select 
			<strong>CX Generate</strong> &gt; <strong> Generate IDL</strong>. </p>
			<p>The generated IDL file is added to the Project Explorer in a folder that is named based on the CDT Project Name you defined 
when you created your model. To view your IDL file, select and double-click the file. This opens the CX editor.</p>
		</helpTopic>
		<helpTopic outputFile="createModel.html" title="Creating Project Models">
			<h1>Creating Project Models</h1>
			<p>
				<!--A default model is provided with the CX installation. This model contains xxxTBDxxx and is located in xxxTBDxxx.--> Models are saved
		in EMX format. A single project can have multiple models - you can use the elements from different models within one project. For example, 
		you can use an element from Model A in Model B. Additionally, you may want to have separate platform and application models.</p>
			<h2>To create a project model</h2>
			<ol>
				<li>From the <strong>File</strong> menu, select <strong>New &gt; SCA 2.2.2 Model Project</strong>.</li>
				<li>In the Zeligsoft Project window, type a <strong>Project Name</strong> and click <strong>Next</strong>.</li>
				<li>Type a <strong>Model Name</strong>.</li>
				<li>Type a <strong>CDT Project Name</strong> and click <strong>Finish</strong>.</li>
				<p>This attribute determines the project to target during code generation. You can use an existing CDT 
		project. If you do not specify a value, the default value of <i>modelname</i>_source is used.</p>
			</ol>
			<p>The model project is displayed in the Project Explorer. This model project folder contains a Diagrams folder and a Models folder.
		The Diagrams folder contains all the diagrams in your model. </p>
			<p>The Models folder includes the following folders:</p>
			<ul>
				<li>(CF_IDL): contains the core framework IDL interfaces and port types.</li>
				<li>(IDLPrimitives): contains the CORBA IDL</li>
				<li>(SCA_BuildEnvironments): contains the the default build configuration files required for Zeligsoft code generation</li>
				<li>(SCALibrary): contains PortTypes for CF interfaces and some common SCA DataTypes</li>
				<li>(UMLPrimitiveTypes): contains the UML primitive types</li>
			</ul>
			<p>A <strong>modelConfiguration</strong> entry is displayed in the Project Explorer. Use this entry to view and edit the model configuration.</p>
			<p>You can create multiple models within one model project. The elements created for one model within a model project 
		can be re-used in another model in the same project model. To create a model, do the following:</p>
			<ol>
				<li>In the Project Explorer, select the Model Project in which you want to create the model.</li>
				<li>From the <strong>File</strong> menu, select <strong>New &gt; SCA 2.2.2 Model</strong>.</li>
				<li>Type a <strong>Model Name</strong>. The default model name is SCA Model.</li>
				<li>Type a <strong>CDT Project Name</strong>.</li>
				<p>This attribute determines the project to target during code generation. You can use an existing CDT 
		project. If you do not specify a value, the default value of <i>modelname</i>_source is used.</p>
				<li>Select a Destination Folder, by default the model project you selected is displayed.</li>
				<li>Click <strong>Finish</strong>.</li>
			</ol>
			<p>The model is added to the Models folder for the model project and a corresponding Zeligsoft Component Diagram is added to the 
		diagrams folder.</p>
			<p>To define and view model capabilities, select the <strong>Capabilities</strong> tab in the <strong>Properties View</strong>. The 
		enabled and available capabilities are displayed, allowing you to add or remove UML capabilities.</p>
		</helpTopic>
		<!--Elements section-->
		<helpTopic outputFile="addelement.html" title="Elements">
			<h1>Elements</h1>
			<p>This section explains how to create, edit, view, delete, and work with elements. In CX, you do your model development in the 
			Zeligsoft Component Diagram. Use the Project Explorer to see how your elements relate. Use the Palette to create elements.</p>
			<ul>
				<li>
					<a href="createelement.html">Creating Elements</a>
				</li>
				<li>
					<a href="workelements.html">Working with Elements</a>
				</li>
				<li>
					<a href="editviewelement.html">Editing and Viewing Elements</a>
				</li>
				<li>
					<a href="deleteelement.html">Deleting Elements</a>
				</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="createelement.html" title="Creating Elements">
			<h1>Creating Elements</h1>
			<p>This topic assumes you have created a project model. If you have not created a project model, read <a href="createModel.html">
		Creating Project Models</a>.</p>
			<p>To create elements, complete the following steps:</p>
			<ol>
				<li>In the <strong>Palette</strong>, open the <strong>SCA Application</strong>, <strong>SCA Platform</strong>, or <strong>CORBA</strong> drawer.</li>
				<p>The element options are displayed. Some common elements are contained within a drawer.</p>
				<li>In the <strong>Palette</strong>, select an element such as: Component and click in the 
		<strong>Zeligsoft Component Diagram</strong>. </li>
				<p>You can control the dimensions of the element. The Properties View for the element displays the element's properties. To learn about Properties, read <a href="property.html">Properties</a>. The element is also displayed in the 
		Project Explorer.</p>
				<p>There is no limit to the number of elements you can add to the model. </p>
			</ol>
			<p>To learn how to work with elements and further define your model, read <a href="workelements.html">Working with Elements</a>.</p>
			<p>Where applicable, additional information and procedures are detailed on the element-specific topic.</p>
			<h3>See Also</h3>
			<br>
				<a href="workelements.html">Working with Elements</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="property.html">Properties</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="workelements.html" title="Working with Elements">
			<h1>Working with Elements</h1>
			<p>This section includes information on further defining, connecting, and managing elements within CX. This topic assumes you have created a 
		<a href="createModel.html">project model</a> and <a href="createelement.html">created elements</a>.</p>
			<p>Use the links below to learn more about elements:</p>
			<p>
				<strong>SCA Application</strong>
			</p>
			<ul>
				<li>
					<a href="aboutpackage.html">Packages</a>
				</li>
				<li>
					<a href="aboutapp.html">Applications</a>
				</li>
				<li>
					<a href="aboutconnector.html">Connectors</a>
				</li>
				<li>
					<a href="aboutcompint.html">Component Interfaces</a>
				</li>
				<li>
					<a href="aboutcomp.html">Components</a>
				</li>
				<li>
					<a href="aboutimpartifact.html">Implementation Artifacts</a>
				</li>
				<li>
					<a href="aboutlib.html">Libraries</a>
				</li>
				<li>
					<a href="aboutscaportlib.html">SCA Port Libraries</a>
				</li>
				<li>
					<a href="aboutresfactory.html">Resource Factories</a>
				</li>
				<li>
					<a href="aboutgen.html">Generalizations</a>
				</li>
				<li>
					<a href="aboutintreal.html">Interface Realizations</a>
				</li>
				<li>
					<a href="aboutproptype.html">Property Types</a>
				</li>
				<li>
					<a href="aboutdep.html">Dependencies</a>
				</li>
				<li>
					<a href="aboutport.html">Ports</a>
				</li>
				<li>
					<a href="aboutfsp.html">Free Standing FindBy Ports </a>
				</li>
				<li>
					<a href="aboutfspdevice.html">FSP DTLTCR and DUBTCR</a>
				</li>
				<li>
					<a href="aboutusedev.html">Uses Devices</a>
				</li>
				<li>
					<a href="aboutos.html">Operating Systems</a>
				</li>
				<li>
					<a href="aboutproc.html">Processors</a>
				</li>
				<li>
					<a href="aboutprolang.html">Implementation Options</a>
				</li>
			</ul>
			<p>
				<strong>SCA Platform</strong>
			</p>
			<ul>
				<li>
					<a href="aboutpackage.html">Packages</a>
				</li>
				<li>
					<a href="aboutplat.html">Platforms</a>
				</li>
				<li>
					<a href="aboutnode.html">Nodes</a>
				</li>
				<li>
					<a href="aboutconnector.html">Connectors</a>
				</li>
				<li>
					<a href="aboutcompint.html">Component Interfaces</a>
				</li>
				<li>
					<a href="aboutdevice.html">Devices</a>
				</li>
				<li>
					<a href="aboutservice.html">Services</a>
				</li>
				<li>
					<a href="aboutimpartifact.html">Implementation Artifacts</a>
				</li>
				<li>
					<a href="aboutlib.html">Libraries</a>
				</li>

				<li>
					<a href="aboutscaportlib.html">SCA Port Libraries</a>
				</li>
				<li>
					<a href="aboutgen.html">Generalizations</a>
				</li>
				<li>
					<a href="aboutintreal.html">Interface Realizations</a>
				</li>
				<li>
					<a href="aboutproptype.html">Property Types</a>
				</li>
				<li>
					<a href="aboutdep.html">Dependencies</a>
				</li>
				<li>
					<a href="aboutport.html">Ports</a>
				</li>
				<li>
					<a href="aboutfsp.html">Freestanding FindBy Ports</a>
				</li>
				<li>
					<a href="aboutevtchns.html">Event Channels</a>
				</li>
				<li>
					<a href="aboutfspdevice.html">FSP DTLTCR and DUBTCR</a>
				</li>
				<li>
					<a href="aboutusedev.html">Uses Devices</a>
				</li>
				<li>
					<a href="aboutos.html">Operating Systems</a>
				</li>
				<li>
					<a href="aboutproc.html">Processors</a>
				</li>
				<li>
					<a href="aboutprolang.html">Implementation Options</a>
				</li>
				<li>
					<a href="aboutman.html">Managers</a>
				</li>
				<li>
					<a href="aboutdmd.html">DMD</a>
				</li>
			</ul>
			<p>
				<strong>CORBA</strong>
			</p>
			<ul>
				<li>
					<a href="aboutpackage.html">Packages</a>
				</li>
				<li>
					<a href="aboutidlfile.html">IDL Files</a>
				</li>
				<li>
					<a href="aboutmodule.html">Modules</a>
				</li>
				<li>
					<a href="aboutuserdata.html">User-Defined Data Type</a>
				</li>
				<li>
					<a href="aboutunion.html">CORBA Elements</a>
				</li>
				<li>
					<a href="aboutinterface.html">Interfaces</a>
				</li>
				<li>
					<a href="aboutporttypes.html">Port Types</a>
				</li>
				<li>
					<a href="aboutgen.html">Generalizations</a>
				</li>
				<li>
					<a href="aboutintreal.html">Interface Realizations</a>
				</li>
				<!--<li><a href="aboutusage.html">Usage</a></li>-->
			</ul>
		</helpTopic>
		<helpTopic outputFile="scaelements.html" title="SCA Application">
			<h1>SCA Application</h1>
			<p>With the SCA Application drawer in the Palette, you create and model your SCA applications in CX. </p>
			<p>The following elements are available in the SCA Application drawer:</p>
			<ul>
				<li>
					<a href="aboutpackage.html">Packages</a>
				</li>
				<li>
					<a href="aboutapp.html">Applications</a>
				</li>
				<li>
					<a href="aboutconnector.html">Connectors</a>
				</li>
				<li>
					<a href="aboutcompint.html">Component Interfaces</a>
				</li>
				<li>
					<a href="aboutcomp.html">Components</a>
				</li>
				<li>
					<a href="aboutimpartifact.html">Implementation Artifacts</a>
				</li>
				<li>
					<a href="aboutlib.html">Libraries</a>
				</li>
				<li>
					<a href="aboutresfactory.html">Resource Factories</a>
				</li>
				<li>
					<a href="aboutgen.html">Generalizations</a>
				</li>
				<li>
					<a href="aboutintreal.html">Interface Realizations</a>
				</li>
				<li>
					<a href="aboutproptype.html">Property Types</a>
				</li>
				<li>
					<a href="aboutdep.html">Dependencies</a>
				</li>
				<li>
					<a href="aboutport.html">Ports</a>
				</li>
				<li>
					<a href="aboutfsp.html">Freestanding FindBy Ports</a>
				</li>
				<li>
					<a href="aboutfspdevice.html">FSP DTLTCR and DUBTCR</a>
				</li>
				<li>
					<a href="aboutusedev.html">Uses Devices</a>
				</li>
				<li>
					<a href="aboutos.html">Operating Systems</a>
				</li>
				<li>
					<a href="aboutproc.html">Processors</a>
				</li>
				<li>
					<a href="aboutprolang.html">Implementation Options</a>
				</li>
			</ul>
			<h3>SCA Application</h3>
			<p>
				<img src="../images/scaapplication_drawer.gif" alt="SCA Application Drawer"></img>
			</p>
		</helpTopic>
		<helpTopic outputFile="scaplatformelements.html" title="SCA Platform">
			<h1>SCA Platform</h1>
			<p>With the SCA Platform drawer in the Palette, you create and model your SCA platform in CX. </p>
			<p>The following elements are available in the SCA Platform drawer:</p>
			<ul>
				<li>
					<a href="aboutpackage.html">Packages</a>
				</li>
				<li>
					<a href="aboutplat.html">Platforms</a>
				</li>
				<li>
					<a href="aboutnode.html">Nodes</a>
				</li>
				<li>
					<a href="aboutconnector.html">Connectors</a>
				</li>
				<li>
					<a href="aboutcompint.html">Component Interfaces</a>
				</li>
				<li>
					<a href="aboutdevice.html">Devices</a>
				</li>
				<li>
					<a href="aboutservice.html">Services</a>
				</li>
				<li>
					<a href="aboutimpartifact.html">Implementation Artifacts</a>
				</li>
				<li>
					<a href="aboutlib.html">Libraries</a>
				</li>
				<li>
					<a href="aboutgen.html">Generalizations</a>
				</li>
				<li>
					<a href="aboutintreal.html">Interface Realizations</a>
				</li>
				<li>
					<a href="aboutproptype.html">Property Types</a>
				</li>
				<li>
					<a href="aboutdep.html">Dependencies</a>
				</li>
				<li>
					<a href="aboutport.html">Ports</a>
				</li>
				<li>
					<a href="aboutfsp.html">Freestanding FindBy Ports</a>
				</li>
				<li>
					<a href="aboutfspdevice.html">FSP DTLTCR and DUBTCR</a>
				</li>
				<li>
					<a href="aboutusedev.html">Uses Devices</a>
				</li>
				<li>
					<a href="aboutos.html">Operating Systems</a>
				</li>
				<li>
					<a href="aboutproc.html">Processors</a>
				</li>
				<li>
					<a href="aboutprolang.html">Implementation Options</a>
				</li>
				<li>
					<a href="aboutman.html">Managers</a>
				</li>
				<li>
					<a href="aboutdmd.html">DMD</a>
				</li>
			</ul>
			<h3>SCA Platform</h3>
			<p>
				<img src="../images/scaplatform_drawer.gif" alt="SCA Platform Drawer"></img>
			</p>
		</helpTopic>
		<helpTopic outputFile="corbaelements.html" title="CORBA">
			<h1>CORBA</h1>
			<p>With the CORBA drawer in the Palette, you create and model your CORBA environment in CX. </p>
			<p>The following elements are available in the CORBA drawer:</p>
			<ul>
				<li>
					<a href="aboutpackage.html">Packages</a>
				</li>
				<li>
					<a href="aboutidlfile.html">IDL Files</a>
				</li>
				<li>
					<a href="aboutmodule.html">Modules</a>
				</li>
				<li>
					<a href="aboutuserdata.html">User-Defined Data Type</a>
				</li>
				<li>
					<a href="aboutunion.html">CORBA Elements</a>
				</li>
				<li>
					<a href="aboutinterface.html">Interfaces</a>
				</li>
				<li>
					<a href="aboutporttypes.html">Port Types</a>
				</li>
				<li>
					<a href="aboutgen.html">Generalizations</a>
				</li>
				<li>
					<a href="aboutintreal.html">Interface Realizations</a>
				</li>
			</ul>
			<h3>CORBA</h3>
			<p>
				<img src="../images/corba_drawer.gif" alt="CORBA Drawer"></img>
			</p>
		</helpTopic>
		<helpTopic outputFile="aboutunion.html" title="CORBA Elements">
			<h1>CORBA Elements</h1>
			<p>The following CORBA elements can be created using the palette:</p>
			<ul>
				<li>Enumeration</li>
				<li>Array</li>
				<li>Sequence</li>
				<li>Struct</li>
				<li>Typedef</li>
				<li>Union </li>
				<li>Constants </li>
				<li>Exception </li>
			</ul>
			<h2>CORBA Enumeration</h2>
			<p>To model a CORBA Enumeration, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Enumeration</strong>.</li>
				<li>Add this element to an <strong>IDL File</strong>, <strong>Module</strong> or <strong>Interface</strong> in a diagram. </li>
				<li>Name the Enumeration.</li>
				<li>With the Enumeration selected, in the <strong>Properties View</strong> &gt; <strong>Literals</strong> tab, add the literals to the enumeration. </li>
				<br>On the Literals tab, elements can be reordered.</br>
			</ol>
			<h2>CORBA Array</h2>
			<p>To model a CORBA Array, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Array</strong>. </li>
				<li>Add this element to an <strong>IDL File</strong>, <strong>Module</strong> or <strong>Interface</strong> in a diagram. </li>
				<li>Name the Array.</li>
				<li>With the Array selected in the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab set the <strong>index</strong> property.</li>
				<li>With the Array selected, in the <strong>Properties View</strong> &gt; <strong>Attributes</strong> tab, add a <strong>public attribute</strong>
 named <strong>members</strong>. </li>
				<li>Select the <strong>members</strong> attribute and in the <strong>Properties View</strong> &gt; <strong>General</strong> tab set the 
<strong>type</strong>.</li>
			</ol>
			<h2>CORBA Sequence</h2>
			<p>To model a CORBA Sequence, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Sequence</strong>.</li>
				<li>Add this element to an <strong>IDL File</strong>, <strong>Module</strong> or <strong>Interface</strong> in a diagram. </li>
				<li>Name the Sequence.</li>
				<li>With the Sequence selected, in the <strong>Properties View</strong> &gt; <strong>Attributes</strong> tab, add a 
<strong>public attribute</strong> named <strong>members</strong>. </li>
				<li>Select the <strong>members</strong> attribute and in the <strong>Properties View</strong> &gt; <strong>General</strong> tab set the 
<strong>type</strong>.</li>
			</ol>
			<h2>CORBA Struct</h2>
			<p>To model a CORBA Struct, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Struct</strong>.</li>
				<li>Add this element to an <strong>IDL File</strong>, <strong>Module</strong> or <strong>Interface</strong> in a diagram. </li>
				<li>Name the Struct.</li>
				<li>With the Struct selected, in the <strong>Properties View</strong> &gt; <strong>Attributes</strong> tab, add a 
<strong>public attribute</strong> named <strong>members</strong>. </li>
				<li>Select the <strong>members</strong> attribute and in the <strong>Properties View</strong> &gt; <strong>General</strong> tab set the 
<strong>type</strong>.</li>
				<br>On the Attributes tab, elements can be reordered.</br>
			</ol>
			<h2>CORBA Typedef</h2>
			<p>To model a CORBA Typedef, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Typedef</strong>. </li>
				<li>Add this element to an <strong>IDL File</strong>, <strong>Module</strong> or <strong>Interface</strong> in a diagram. </li>
				<li>Name the Typedef.</li>
				<li>Add the <strong>data type</strong> the Typedef represents.</li>
				<li>From the CORBA drawer in the Palette, select <strong>Generalization</strong> and draw a link from the <strong>Typedef</strong>
 to the <strong>data type</strong>.</li>
			</ol>
			<h2>CORBA Union</h2>
			<p>To model a CORBA Union, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Union</strong>. </li>
				<li>Add this element to an <strong>IDL File</strong>, <strong>Module</strong> or <strong>Interface</strong> in a diagram. </li>
				<li>Name the Union.</li>
				<li>Add a new attribute called switchType to the Union and set the type to the data type you which to do the switch() on.</li>
				<li>Create public attributes for each case statement. Set the Stereotype for these attributes to <strong>CORBACase</strong>. </li>
				<li>Select each attribute other than switchType, open the <strong>Properties View</strong> &gt; <strong>General</strong> tab and set the 
<strong>name</strong> property. </li>
				<br>The name represents the attribute name inside the case statement.</br>
				<li>Select each attribute other than switchType and open the <strong>Properties View</strong> &gt; <strong>General</strong> tab and set the 
<strong>type</strong> property.</li>
				<br>The type represents the attribute type inside the case statement.</br>
				<li>Select each attribute other than switchType and open the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and set the 
<strong>label</strong> property to the value for the case. </li>
				<br>The label represents the value of the case. For example, if the label is set to BLUE, case BLUE: will be generated.</br>
			</ol>
			<h2>CORBA Constants</h2>
			<p>The following procedure details how to group constants together. These constants can then be moved anywhere inside the IDL File.</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Constants</strong>. </li>
				<li>Add this element to an <strong>IDL File</strong>, <strong>Module</strong> or <strong>Interface</strong> in a diagram. </li>
				<li>Name the element.</li>
				<li>Add public attributes to the element.</li>
				<li>For each attribute open the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and set the <strong>stereotype</strong>
 to <strong>CORBAConstant</strong>.</li>
				<li>For each attribute open the <strong>Properties View</strong> &gt; <strong>General</strong> tab and set the 
<strong>type</strong> property.</li>
				<br>To reorder the attributes: right click the Exception element, select UML Properties and then click OwnedAttributes.</br>
			</ol>
			<p>A constant may be added directly to an interface without the Constants element specified above.</p>
			<ol>
				<li>Add a public attribute to a <strong>CORBA Interface</strong> and name the attribute.</li>
				<li>Select the attribute, open the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and set the <strong>stereotype</strong>
 to <strong>CORBAConstant</strong>.</li>
				<li>Select the attribute, open the <strong>Properties View</strong> &gt; <strong>General</strong> tab and set the 
<strong>type</strong> and <strong>value</strong> properties.</li>
			</ol>
			<h2>CORBA Exception</h2>
			<p>To model a CORBA Exception, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Exception</strong>.</li>
				<li>Add this element to an <strong>IDL File</strong>, <strong>Module</strong> or <strong>Interface</strong> in a diagram. </li>
				<li>Name the element.</li>
			</ol>
			<p>To add attributes to the Exception:</p>
			<ol>
				<li>Add public attributes to the Exception element.</li>
				<li>For each attribute, select the attribute, open the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and 
set the <strong>stereotype</strong>
 to <strong>CORBAConstant</strong>.</li>
				<li>For each attribute open the open the <strong>Properties View</strong> &gt; <strong>General</strong> tab and set the 
<strong>type</strong>. </li>
				<br>To reorder the attributes: right click the Exception element, select UML Properties and then click OwnedAttributes.</br>
			</ol>
			<p>To seta CORBA Interface operation to raise an Exception:</p>
			<ol>
				<li>Right click the <strong>CORBA Interface operation</strong> and select <strong>UML Properties</strong>.</li>
				<li>Click  <strong>RaisedException</strong> and add an exiting Exception.</li>
			</ol>
			<p>To model a CORBA Union, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Union</strong>.</li>
				<li>Add this element to a <strong>Module</strong>.</li>
				<li>With the <strong>Union</strong> selected, in the <strong>Properties View</strong> &gt; <strong>Attributes</strong> tab.</li>
				<li>Add a new attribute called <strong>switchType</strong> to the Union and set the <strong>type</strong> to <strong>CORBALong</strong>.</li>
				<li>For each case statement you want to generate, you must add an attribute to the Union and apply the <strong>CORBACase</strong> stereotype to the 
		attribute. To control the ordering of the case statements, right-click and select <strong>UML Properties</strong>, select <strong>
		ownedAttributes</strong> and use the arrows.</li>
			</ol>
			<p>A CORBA Constant can be added at the interface or module level. To add a CORBA Constant at the 
			interface level, add an attribute and set the <strong>Stereotype</strong> to <strong>CORBAConstant</strong>. 
			To add a CORBA Constant at the module level, in the <strong>Palette</strong>, select <strong>Constant</strong> and 
			drop this onto the module.</p>
			<h3>See Also</h3>
			<br>
				<a href="introInterface.html">IDL Generation and Import</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutresfactory.html" title="Resource Factories">
			<h1>Resource Factories</h1>
			<p>The resource factory element is used to model the dynamic creation and tear down of resources. This element is responsible for the 
		creation and tear down.</p>
			<p>A resource factory component implements the resource factory interface. A resource factory can be created using 
		the Component Creation Wizard.</p>
			<p>To create a ResourceFactory component, do the following:</p>
			<ol>
				<li>To open the <strong>Component Wizard</strong>, right-click a <strong>Model</strong> or <strong>Package</strong> and select 
<strong>Add Zeligsoft</strong> &gt; <strong>Component</strong>. </li>
				<li>Type a <strong>Component Name</strong> and from the <strong>Type</strong> drop-down list, select <strong>ResourceFactory</strong>.</li>
				<li>Click <strong>Finish</strong>.</li>
			</ol>
			<p>Create relationships from the ResourceFactory structure realization to the Component types it creates. This defines all the 
component types the ResourceFactory can create. Do the following:</p>
			<ol>
				<li>Drag the <strong>component structure realization</strong> for each component controlled by the ResourceFactory, onto the <strong>ResourceFactory diagram</strong>.</li>
				<li>In the <strong>Palette</strong>, open the <strong>SCA Application</strong> drawer and select <strong>SCAResourceFactoryDependency</strong>.</li>
				<li>Use the <strong>SCAResourceFactoryDependency</strong> to connect the <strong>ResourceFactory</strong> to each <strong>component 
structure realization</strong>.</li>
			</ol>
			<p>In the application specify which Resource component instances the ResourceFactory will create. This will be a subset of the components 
that were added to the ResourceFactory diagram above. Do the following:</p>
			<ol>
				<li>In the <strong>application</strong> select each component controlled by the ResourceFactory.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and select the <strong>resourcefactoryref</strong>
 property. Browse to the <strong>ResourceFactory part</strong> in the application.</li>
			</ol>
		</helpTopic>
		<helpTopic outputFile="aboutdmd.html" title="DMD">
			<h1>DMD</h1>
			<h2>Domain</h2>
			<p>The Domain element in the SCA Platform palette drawer maps to the Domain Manager Descriptor file. The 
		Domain Manager Descriptor describes which services the Domain Manager connects to during startup. The elements include:</p>
			<ul>
				<li>Domain: specifies the properties of the Domain Manager Definition.</li>
				<li>Domain Dependency link: used to link the Domain Manager structure realization to the Domain element.</li>
			</ul>
			<p>To create a Domain:</p>
			<ol>
				<li>Open the diagram that has a <strong>Domain Manager</strong>.</li>
				<li>In the <strong>Palette</strong>, select <strong>Domain</strong> and drop it onto the diagram. </li>
				<li>In the <strong>Palette</strong>, select <strong>Domain Dependency</strong> and draw a link from the <strong>Domain</strong> to the <strong>DomainManager structure 
realization</strong>.</li>
			</ol>
			<h2>DMD Service</h2>
			<p>The DMD Service elements include:</p>
			<ul>
				<li>DMD Service: specifies the services the Domain Manager connects to.</li>
				<li>DMD Service Link: used to link the Domain element to one or more DMD Service elements. </li>
			</ul>
			<p>To create a DMD service:</p>
			<ol>
				<li>Open the diagram that has a <strong>Domain Manager</strong>.</li>
				<li>In the <strong>Palette</strong>, select <strong>DMD Service</strong> and drop it onto the diagram. Name the DMD Service.</li>
				<li>Select <strong>DMD Service</strong> and in the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab, set the options for 
the DMD Service.</li>
				<li>In the <strong>Palette</strong>, select <strong>DMD Service Link</strong> and draw a link from the <strong>Domain</strong>
 element to the <strong>DMD Service</strong> element.</li>
				<li>Repeat for each additional service.</li>
			</ol>
		</helpTopic>
		<helpTopic outputFile="aboutconnector.html" title="Connectors">
			<h1>Connectors</h1>
			<p>A connection determines how components communicate act with one another. It specifies the relationship between the provider of an interface and the user of an interface. 
		</p>
			<p>A connector is a communication link between two ports or a port and a supports interface. The ports are compatible if:</p>
			<ul>
				<li>Both ports realize the same interface or the provides port interface is a subclass of the uses port interface.</li>
				<li>One port's conjugation is the inverse of the other.</li>
			</ul>
			<p>To define a connection in CX, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, click <strong>Connector</strong>.</li>
				<li>In the <strong>Zeligsoft Component Diagram</strong>, select the first element in the relationship. If this is not a valid 
		selection, a circle with a strike-through is displayed.</li>
				<li>In the <strong>Zeligsoft Component Diagram</strong>, click and drag the connector to the second element in the relationship.</li>
				<p>Edit the name of the connector. You can also edit the connector properties in the Properties View.</p>
			</ol>
			<p>To ensure that descriptor generation works for connections to supported interfaces, make sure you are connecting
		directly to the component. </p>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutport.html" title="Ports">
			<h1>Ports</h1>
			<p>A port identifies a source/producer (Uses Port) or a sink/consumer(Provides Port) for data and/or commands. A Port is defined by the Port Type.
		The port realizes all interfaces that the port type realizes and uses all the interfaces that the port type uses. In the SCA, a port type 
		can only realize or use one interface and is unidirectional.</p>
			<p>CX uses UML 2 notation to indicate the port interface direction. The interface's direction is called its "conjugation".</p>
			<p>If you are creating a port on an application, an SCAExternal Port is created. If you are creating a port on any SCA component interface, 
		an SCAPort is created. Note that nodes cannot have ports defined on the element border.</p>
			<p>To create a Port Type, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select your model or package, right-click and from the pop-up menu select <strong>Add Zeligsoft</strong> &gt; <strong>PortType</strong>.</li>
				<li>In the <strong>Name</strong> field, type a name for the port type.</li>
				<br>The Inverse Name is automatically completed.</br>
				<li>Select a <strong>Provides Interface</strong> from the list.</li>
				<li>Click <strong>Finish</strong>.</li>
			</ol>
			<p>To create an interface during Port Type creation, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select your model, right-click and from the pop-up menu select <strong>Add Zeligsoft</strong> &gt; <strong>PortType</strong>.</li>
				<li>Click <strong>Create Interface</strong> and type an <strong>Interface Name</strong>.</li>
				<li>Click <strong>Finish</strong>.</li>
			</ol>
			<p>To create a port on a component interface, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Port</strong>.</li>
				<li>In the <strong>Zeligsoft Component Diagram</strong>, click the border of  the component interface to which you want to add a port.</li>
				<li>From the pop-up menu, select <strong>Select Existing Element</strong>.</li>
				<li>Search for or Browse to the PortType and click <strong>Finish</strong>.</li>
				<p>If you change the name of the port, the associated worker functions are updated with the new port name.</p>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab, and set the <strong>Kind</strong> property.</li>
			</ol>
			<p>To create a Free Standing Port (FSP) do the following:</p>
			<ol>
				<li>In the Palette, select the appropriate FSP Port element. </li>
				<li>Drop the element onto an Application or Node structure in a Zeligsoft Component Diagram. </li>
				<li>From the pop-up menu, select <strong>Select Existing Element</strong>. </li>
				<li>Search for or Browse to the <strong>PortType</strong> and click <strong>OK</strong>.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab, and set the properties that apply to the FSP type. </li>
			</ol>
			<p>To create an external port, do the following:</p>
			<ol>
				<li>Create a <strong>port</strong> on an <strong>application</strong> border.</li>
				<li>From the pop-up menu, select <strong>Select Existing Element</strong>. </li>
				<li>Search for or Browse to the <strong>PortType</strong> and click <strong>OK</strong>. </li>
			</ol>
			<p>With the external port configured, you can then generate an external port tag in the SAD. To ensure a description is displayed 
		in the SAD, configure the description property on the port.</p>
			<p>To invert the port conjugation, in the Zeligsoft Component Diagram, right-click the port and select the Inverse Port Type.</p>
			<p>Once a port has been created, you can change it's PortType simply by dragging another PortType onto the port existing on the component interface.</p>
			<h3>See Also</h3>
			<br>
				<a href="portprop.html">Port Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutproptype.html" title="Property Types">
			<h1>Property Types</h1>
			<p>The following property type options are available in this drawer:</p>
			<ul>
				<li>Enumeration Property Type</li>
				<li>Primitive Property Type</li>
				<li>Struct Property Type </li>
				<li>Struct Sequence Property Type</li>
				<li>Test Property Type</li>
			</ul>
			<p>Use these property types to create and define SCA properties that are referenced from component SCA attributes in CX. </p>
			<p>In the SCA, a property has a name and this property has the potential to be re-used across multiple devices and/or components. 
		For example, MAX_THROUGHPUT or DECRYPT_KEY can be created and make the re-use of properties simpler and more convenient.</p>
			<ol>
				<li>Create a new <strong>Property</strong> on a Zeligsoft Component Diagram.</li>
				<li>Select the property and in the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and set the <strong>kind</strong>
 and <strong>type</strong>. For allocation properties, set the <strong>action</strong>.</li>
				<li>In a Zeligsoft Component Diagram, select an element, such as a component interface or component structure realization.</li>
				<li>Right click the element and select <strong>Add SCA</strong> &gt; <strong>SCA Property</strong>. This creates a component attribute 
with a stereotype of SCAProperty.</li>
				<li>Select the attribute. In the <strong>Properties View</strong> &gt; <strong>General</strong> tab click <strong>Select Type</strong>
 and browse for the property you created. Click <strong>OK</strong>. </li>
				<li>Use the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab to set the necessary properties such as mode.</li>
				<p>If the attribute is not displayed in the Zeligsoft Component Diagram, right-click the 
		component and from the pop-up menu choose <strong>Filters &gt; Show/Hide Compartment &gt; Attribute Compartment</strong>.</p>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="propertytypeprop.html">Property Type Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutfsp.html" title="Freestanding FindBy Ports">
			<h1>Freestanding FindBy Ports</h1>
			<p>A Free Standing Port (FSP) models a port or a service that is dynamically discovered during runtime. The SCA uses dynamic port discovery in some of its connection 
		specifications (findby, deviceusedbythiscomponentref, devicethatloadedthiscomponentref). The information on the port is used by the SCA Core 
		Framework to locate an instance (component, device, core framework or service) or a port on an instance that adheres to the information on 
		the FSP. This port is then used in the connection.</p>
			<p>FSPs can be used in CX to model these connection specifications elegantly. Actual discovery of the ports is the responsibility of the 
		SCA Core Framework. CX allows you to model all connections that are available according to the SCA standard. An FSP can model a uses or provides 
		port or a supports interface.</p>
			<p>In this drawer the following freestanding port (FSP) element options are available:</p>
			<ul>
				<li>FSP DomainFinder-NamingService</li>
				<li>FSP DomainFinder-Log</li>
				<li>FSP DomainFinder-FileManager</li>
				<li>FSP DomainFinder-EventChannel</li>
				<li>FSP DomainFinder-ServiceName (waveforms only)</li>
				<li>FSP DomainFinder-ServiceType (waveforms only)</li>
			</ul>
			<p>These FSPs can be described as: CX supports all connection types as 
		given in the SCA, including the specification of connections via FindBy_DomainFinder as per section D.6.5.1.1.3.2 of the SCA domain profile. The 
		domainfinder element is used to indicate to the CF ApplicationFactory the necessary information to find an object reference that is of 
		specific type and may also be known by an optional name within the domain. The valid type attributes 
		are filemanager, log, eventchannel, namingservice, servicename and servicetype. If a name attribute is not supplied, then the component reference 
		returned is the CF DomainManager's FileManager or Naming Service corresponding to the type attribute provided. If a name attribute is not 
		supplied and the type attribute has a value of log, then a null reference is returned. The type attribute value of eventchannel is used to 
		specify the event channel to be used in the OE's CORBA Event Service for producing or consuming events. If the name attribute is not 
		supplied and the type attribute has a value of eventchannel then the Incoming Domain Management event channel is used.</p>
			<p>To create an FSP do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select the <strong>FSP</strong> that you want to create.</li>
				<li>Drop the <strong>FSP</strong> onto the appropriate element in the <strong>Zeligsoft Component Diagram</strong>.</li>
				<li>From the pop-up menu, select <strong>Select Existing Element</strong> and Search or Browse for the
		<strong>Port Type</strong> you want to use.</li>
				<li>Click <strong>OK</strong>.</li>
			</ol>
			<p>Note: When modeling FSP DomainFinder-ServiceName or FSP DomainFinder-ServiceType the SCA 2.2.2 Extension preference must be set in <strong>Windows</strong> &gt; <strong>Preferences</strong> &gt; <strong>Zeligsoft</strong> &gt; <strong>SCA</strong>.</p>
			<h3>See Also</h3>
			<br>
				<a href="fspprop.html">Freestanding FindBy Ports Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
   			<br>
				<a href="aboutevtchns.html">Event Channels</a>
			</br>
		</helpTopic>


    <helpTopic outputFile="aboutevtchns.html" title="Connecting to Event Channels">
			<h1>Event Channels</h1>
			<p>The SCA states that two event channels be present, Incoming DomainManager (IDM)
and Outgoing DomainManager (ODM). Users can also create their own event
channels. The instructions below describe how to connect to the IDM in a CX
model.</p>
	

<p>  SCA devices should write to the IDM when certain events happen (i.e. the device
changes state). To model the device connected to the IDM, do the following:  </p>
<ol>
<li> Import CosEventComm.idl into the model. This IDL is provided by the ORB
supplier. </li>

<li> Create a PortType based on the CosEventComm/PushConsumer interface. </li>

<li> Add a uses port to the Device Component Interface based on the uses
PushConsumer PortType. Set the port kind to data. </li>

<li> From the palette, add a "FSP DomainFinder-EventChannel" based on the
provides PushConsumer PortType to the node.   </li>

<li> Select the Free Standing Port (FSP). Select the Properties view, SCA tab.
Set FindBy Type to FindBy. Set the Findby Element Name and Name to IDM_Channel.</li> 

<li> Connect the Device uses port to the IDM_Channel FSP.     </li>

<li> Validate SCA and generate. </li>
</ol>

			<h3>See Also</h3>
			<br>
				<a href="fspprop.html">Freestanding FindBy Ports Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>



		<helpTopic outputFile="aboutfspdevice.html" title="FSP DTLTCR and DUBTCR">
			<h1>FSP DTLTCR and DUBTCR</h1>
			<p>In the SCA Application drawer there are two options: FSP Device that Loaded or FSP Device Used By.</p>
			<p>FSP Device that Loaded: the DeviceThatLoadedThisComponentRef (DTLTCR) is a type of FSP. A component port connects to the freestanding port. This kind of 
		connection allows the Core Framework to locate the device that participates in the connection. Can be used to model a uses or provides port. 
		The DTLTCR FSP provides information on how to discover a port at runtime by indicating which device loaded a specific component instance.</p>
			<p>FSP Device Used By: the DeviceUsedByThisComponentRef (DUBTCR) is used a type of FSP. A component port connects to the freestanding port. This kind of 
		connection allows the Core Framework to locate the device that participates in the connection. Can be used to model a uses or provides port. 
		The DUBCTR FSP provides information on how to discover a port at runtime using the UsesDevice relationship. This connection is necessary for 
		dynamic connections to devices that are not loadable.</p>
			<p>To create an FSP Device do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select the <strong>FSP Device</strong> that you want to create.</li>
				<li>Drop the <strong>FSP Device</strong> onto the appropriate element in the <strong>Zeligsoft Component Diagram</strong>.</li>
				<li>From the pop-up menu, select <strong>Select Existing Element</strong> and Search or Browse for the
		<strong>Port Type</strong> you want to use.</li>
				<li>Click <strong>OK</strong>.</li>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="fspdeviceprop.html">FSP DTLTCR and DUBTCR Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutcompint.html" title="Component Interfaces">
			<h1>Component Interfaces</h1>
			<p>An SCA Component Interface maps to a SCD.xml file. A component interface can realize interfaces. Doing so implies the component 
		will implement the behavior for these interfaces. The SCA specifies interfaces for a set of specialized components that provide the 
		infrastructure for an SCA system domain.</p>
			<p>Ports can be added to Component interfaces. Adding a provides port means the component will implement the behavior for the provides 
port interface.</p>
			<p>To add a component interface that realizes a Resource interface, do the following:</p>
			<ol>
				<li>In the Palette, select <strong>Component Interface</strong> and drag onto the Zeligsoft Component Diagram. </li>
				<li>Type a Name for the element. </li>
				<li>Add the Resource interface to the Zeligsoft Component Diagram. </li>
				<li>Connect the Component Interface to the Resource interface with an Interface Realization.</li>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="componentintprop.html">Component Interface Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutcomp.html" title="Components">
			<h1>Components</h1>
			<p>A component represents a software module (source code, binary code, executable, library, etc.) with a well-defined interface. 
		The interface of a component is represented by its ports and supports interfaces. Component implementations show compiler and 
		run-time dependencies and represent a binary for a particular build environment.</p>
			<p>Use the Component Wizard to create components. </p>
			<h3>Component Wizard</h3>
			<p>
				<img src="../images/newcompwizard.gif" alt="Component Wizard"></img>
			</p>
			<p>To create a component, do the following:
</p>
			<ol>
				<li>To open the <strong>Component Wizard</strong>, right-click a <strong>Model</strong> or <strong>Package</strong> and select <strong>Add Zeligsoft</strong> &gt; <strong>Component</strong>.</li>
				<li>Type a <strong>Component Name</strong> and from the <strong>Type</strong> drop-down list, select an option.</li>
				<p>All other fields in the wizard are optional but enabled. </p>
				<p>The wizard will create a corresponding Package, Component Interface, Component Structure Realization, Implementation with Executable 
		File Name, and Diagram with the appropriate relationships for the component. 
		Using the <strong>Type</strong> drop-down list you can create the following: Resource, Resource Factory, Device, 
		LoadableDevice, ExecutableDevice, AggregateDevice, Device Manager, and Domain Manager. To create a component without a 
		supported interface, select <strong>None</strong> from the <strong>Type</strong> drop-down list. If you create an AggregateDevice, the 
		provides port is automatically created and added to the diagram.</p>
				<p>By default a suffix is appended to the component name for each element you create with the wizard. To disable this, deselect <strong>Use default</strong>.
		To edit the default values, select <strong>Windows</strong> &gt; <strong>Preferences</strong> &gt; <strong>Zeligsoft</strong> &gt; <strong>SCA</strong>.</p>
				<p>When you create a Component, the appropriate worker functions are added to the component structure realization. 
		The worker function visibility is set to private. The component implementation Executable File Name is displayed when you 
		select the code attribute in the Properties View for the Implementation.</p>
				<li>Click <strong>OK</strong>.</li>
			</ol>
			<p>A component implementation link between the component implementation and the component structure realization is automatically created. 
		A generalization is created between the component structure realization and the component interface.</p>
			<p>The SCA requires that an Assembly Controller be identified. Any SCA compliant component instance can be the assembly controller. To 
		create an assembly controller, do the following:</p>
			<ol>
				<li>Create a component named <strong>Controller</strong> and add this element to the application structure.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotype</strong> tab.</li>
				<li>Configure the <strong>Controller</strong> property on the application structure.</li>
			</ol>
			<p>You can edit the component worker operations: right-click the worker operation and select <strong>Open Editor</strong>.</p>
			<p>To edit the configure_body and query_body attributes, do the following:</p>
			<ol>
				<li>Select the component and then select the property, for example DECRYPT_KEY:Key.</li>
				<li>To edit the configure method for DECRYPT_KEY, right click on the property and select <strong>Open Editor</strong> &gt; <strong>Configure</strong>.</li>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="componentprop.html">Component Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutdevice.html" title="Devices">
			<h1>Devices</h1>
			<p>The following device elements are available:</p>
			<ul>
				<li>Executable Device: according to the SCA (v 2.2.2) an executable device extends the LoadableDevice interface by adding execute and terminate behavior to a Device.</li>
				<li>Loadable Device: according to the SCA (v 2.2.2) a loadable device extends the Device interface by adding software loading and unloading behavior to a Device.</li>
				<li>Device: according to the SCA (v 2.2.2) a device is a type of Resource within the domain and has the requirements as stated in the Resource interface. This interface defines additional 
		capabilities and attributes for any logical Device in the domain. A logical Device is a functional abstraction for a set (e.g., zero or more) of hardware devices</li>
				<li>Aggregate Device: according to the SCA (v 2.2) an aggregate device provides aggregate behavior that can be used to add and remove Devices from an aggregate Device. This interface can be 
		provided via inheritance or as a provides port for any Device that is capable of an aggregate relationship. Aggregated Devices use this interface to add or remove themselves from composite 
		Devices when being created or torn-down.</li>
			</ul>
			<p>The author attribute must be configured for all devices. The os_name and processor_name attributes must be configured for executable devices.</p>
			<ol>
				<li>In the Zeligsoft Component Diagram, select the device.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab.</li>
				<li>Configure the appropriate attribute: author, os_name, or processor_name.</li>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="deviceprop.html">Device Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutservice.html" title="Services">
			<h1>Services</h1>
			<p>The following Service Model elements are available:</p>
			<ul>
				<li>Log Service : log service.</li>
				<li>Service: according to the SCA (v 2.2.2) a service can be use for SCA and non-SCA services.</li>
			</ul>
			<p>The Component Wizard can be used to create a service. However the RepositoryId must be set manually.</p>
			<ol>
				<li>Right click on a package and select <strong>Add CX</strong> &gt; <strong>Component</strong>.</li>
				<li>Select type <strong>Service</strong> from the drop down list.</li>
			</ol>
			<p>Service can be created from the palette.</p>
			<ol>
				<li>Open a <strong>Component Diagram</strong>.</li>
				<li>From the palette's Platform drawer select <strong>Service</strong> and drop it on the diagram.</li>
				<li>Add Component Interface, implementation, ... the same as for a component or device.</li>
			</ol>
			<p>Note: When modeling Services the SCA 2.2.2 Extension preference must be set in <strong>Windows</strong> &gt; <strong>Preferences</strong> &gt; <strong>Zeligsoft</strong> &gt; <strong>SCA</strong>.</p>
		</helpTopic>
		<helpTopic outputFile="aboutapp.html" title="Applications">
			<h1>Applications</h1>
			<p>An executable software program may contain one or more modules. The executable software exhibits pre-determined functionality.
			In COE an application is created by assembling a set of components and providing connections between compatible ports 
			(formal interfaces) on adjacent components. Using Model Driven Design (MDD) techniques, individual components and the overall 
			application model can be validated for correctness at any point in the development process.</p>
			<p>An application is a set of components in a communicating architecture. An SCA application can have an unlimited number of component instances.</p>
			<p>To create an SCA Application, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong> select <strong>Application</strong> from the <strong>SCA Application</strong> drawer
			 and drop it onto a Zeligsoft Component Diagram.</li>
				<li>Select the Structure compartment on the Application and resize. </li>
				<li>Component structure realizations can be dragged from the Project Explorer to the Application structure to create component instances (parts).</li>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="applicationprop.html">Application Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutnode.html" title="Nodes">
			<h1>Nodes</h1>
			<p>A node consists of one device manager and a set of one or more hardware devices. A node contains one or more logical 
		abstractions of physical hardware elements. A node can contain one or more devices and their connections. One of these devices needs to be 
		an executable device. The content of the node defines the information in the DCD.</p>
			<p>In UML modeling, nodes are model elements that represent the computational resources of a system, such as personal computers,
         sensors, printing devices, and servers. Nodes can be interconnected by using communication paths to describe network structures.</p>
			<p>A node can be visualized as the logical abstraction of a hardware board that can be added or removed from the system.</p>
			<p>You must define the device manager for each node. Using the Palette, create a device manager and then in Project Explorer, drag the 
			device manager on to the node. Optionally, you can configure a file manager and SCAlog for the node.</p>
			<p>Once you have created a node, use the Properties View to define the <strong>namingservice</strong> property for the node. Set this 
			property to the <strong>Domain Manager</strong> you created.</p>
			<h3>See Also</h3>
			<br>
				<a href="nodeprop.html">Node Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutplat.html" title="Platforms">
			<h1>Platforms</h1>
			<p>A platform is a set of nodes under the control of a single domain manager. A platform can contain one or more nodes, one of these nodes
		 needs to contain a domain manager. The content of the platform is generated into 
the complete device profile</p>
			<p>A platform is a modeling entity introduced by CX. The SCA equivalent of the platform is the entire set of DCDs that comprise 
the Domain.</p>
			<p>Typical platform layers include a hardware layer composed of different types of processors (GPP, DSP, FPGA), memory buses, and inter 
			connections, and the RTOS layer and middleware layers that provide services to application components. Similarly to applications, platform 
			layers can be individually defined in a component-based manner.</p>
			<p>You must define the domain manager for each platform. Using the Palette or Component Wizard, create a domain manager and then in Project 
			Explorer, drag the 
			domain manager on to the platform. Optionally, you can configure a file manager and SCAlog for the platform.</p>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutman.html" title="Managers">
			<h1>Managers</h1>
			<p>There are two elements available: Device Manager and Domain Manager.</p>
			<p>According to the SCA (v. 2.2.2), a device manager is used to manage a set of logical devices and services. The device manager is 
		responsible for the creation of logical devices and launching service applications on these logical devices. There is one device manager per DCD.</p>
			<p>According to SCA (v. 2.2.2), a domain manager manages the software applications, applicationfactories, hardware devices (represented by 
		software devices) and device managers within the system. Device are allocated to one or more hardware devices by the domain manager. There is one domain manager in the system.</p>
			<p>You can use the Component Wizard to automatically create Device Managers and Domain Managers. In the wizard, use the <strong>Type</strong> 
		drop-down list to select the appropriate element.</p>
			<p>To define the DMD elements, do the following:</p>
			<ol>
				<li>Select the <strong>Domain</strong> element and drop it onto the <strong>Zeligsoft Component 
Diagram</strong>. </li>
				<li>Name the element.</li>
				<li>In the Palette, select the <strong>Domain Dependency</strong> and link from the <strong>Domain</strong> to
the <strong>Domain Manager</strong> element.</li>
				<li>In the Palette, select the <strong>DMD Service</strong> and drop this element onto the <strong>Zeligsoft Component 
Diagram</strong>. </li>
				<li>Name this element. </li>
				<li>In the Palette, select the <strong>DMD Service Link</strong> and link from <strong>Domain</strong> to <strong>DMD Service</strong>. </li>
				<li>In the Palette, select the <strong>Component Implementation</strong> and link from <strong>Domain Manager</strong> to <strong>DMD Service</strong>. </li>
				<li>In the diagram, select <strong>DMD Service</strong>. </li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and configure the following mandatory properties: 
findbyName to DMD_Serv, findbyType to 0-NamingService, and usesidentifier. </li>
				<li>Save the model. </li>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="managerprop.html">Manager Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutusedev.html" title="Uses Devices">
			<h1>Uses Devices</h1>
			<p>This element is used to specify dynamic connections using DUBTCR FindBy ports. This element is needed because not all devices are loadable or executable. </p>
			<p>A Uses Device is a requirement of something from a device - it documents that a component needs the device. 
This is different then 'depends on device'. This relationship can later be used to configure connections.</p>
			<p>The source for this element is a definition or implementation. The element target is an allocation property.</p>
			<p>A Uses Device can be defined on a component or device definition or implementation and points to one or more allocation properties on a 
definition or implementation.</p>
			<p>To create a uses device, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Platform</strong> drawer and select <strong>UsesDevice</strong>.</li>
				<li>Drop the element onto the diagram and name the element.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and set the 
<strong>type</strong>.</li>
				<li>Create an <strong>Implementation Artifact</strong> and name the element.</li>
				<li>In the <strong>Palette</strong>, select <strong>UsesDevice Dependency</strong> and in the 
diagram, connect the <strong>Component structure realization </strong> or <strong>Implementation Artifact</strong> to the <strong>UsesDevice</strong>.</li>
				<li>Add one or more allocation properties to the diagram.</li>
				<li>Draw a Property Dependency from a UsesDevice to the allocation property</li>
				<li>Set the value for the Property Dependency</li>
			</ol>
			<h2>Uses Device Dependency</h2>
			<p>This element is used to specify dependencies between a UsesDevice element and one or more allocation properties.</p>
			<p>To define a uses device dependency, do the following:</p>
			<ol>
				<li>Add a <strong>UsesDevice</strong> to the <strong>Zeligsoft Component Diagram</strong>. </li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and configure the <strong>Type</strong> property. </li>
				<li>In the <strong>Palette</strong>, select <strong>UsesDevice Dependency</strong> and connect either a component structure realization or an implementation to the UsesDevice element.</li>
				<li>Add one or more allocation property references to the diagram. </li>
				<li>For each allocation property, add a Property Dependency from a UsesDevice element to the allocation property.</li>
				<li>Set a value for each <strong>Property Dependency</strong>.</li>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutimpartifact.html" title="Implementation Artifacts">
			<h1>Implementation Artifacts</h1>
			<p>Artifacts represent elements such as: executable files, libraries, and databases. The implementation artifact concerns the binary code 
		that represents a component or device for a specific operating environment. Think of this as the executable or shared library that gets 
		loaded to the target platform.</p>
			<p>To create a monolithic implementation, do the following:</p>
			<ol>
				<li>In the <strong>Palette</strong>, select <strong>Implementation Artifact</strong> and drop the element 
		onto the Zeligsoft Component Diagram.</li>
				<li>In the <strong>Palette</strong>, select <strong>Component Implementation</strong> and connect the <strong>component implementation</strong>
		 to the <strong>component structure realization</strong>.</li>
				<li>Configure the implementation properties such as Programming Language, Code, Compiler, and Run-Time.</li>
				<li>The implementation artifact requires at least one of the following dependencies to be defined: Operating System, Processor, SoftPkgRef or PropertyReferenceDependency.</li>
			</ol>
			<h3>Component Implementation</h3>
			<p>Used to connect a component implementation to a component structure realization. A component structure realization may be 
		referenced by more than one component realization.  </p>
			<h3>See Also</h3>
			<br>
				<a href="artifactprop.html">Implementation Artifact Properties</a>
			</br>
			<br>
				<a href="aboutdep.html">Dependencies</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>





<helpTopic outputFile="aboutscaportlib.html" title="SCA Port Libraries">
			<h1>SCA Port Libraries</h1>
			<p>Shared libraries are used when the build configuration specifies options for shared libraries. So instead of creating static libraries for each Port, framework, etc, a shared library is created and the executable is linked with these. This means that the shared libraries have to be on the library path for the given target platform.</p>

			<p>
			SCAPortLibraries can be modeled in CX and then referenced as a software package reference dependency. This specifies a Software Package Dependency (SPD) to the shared library. 
			</p>

			<p>
			For example, create a SCAPortLibrary component named SCAPortLibrary with an implementation for Linux:
			</p>

			<p>
			<ol>
			<li> Create a package named SharedLibraries.</li>
			  <li>Right click on the SharedLibraries package and select Add Diagram > Zeligsoft  
				   Component Diagram Name the diagram SharedLibaries_Diag. </li>
			  <li> In the Application Palette, select Port Library and drop this element onto 
				   SharedLibaries _Diag.</li>
			  <li> Name the element SCAPortLibrary. </li>
			 <li> In the Properties View > SCA tab, deselect SCA Compliant.</li>
			 <li> Add an Implementation Artifact to the SharedLibaries_Diag and name it 
				   SCAPortLibrary_linux. Draw a Component Implementation link from the 
				   implementation to the SCAPortLibrary. </li>
			 <li> Select the implementation. In the Properties View > SCA tab open the Code and 
				   name the file libScaPortLibrary.so. Note that the Port Library file name must have 
				   the appropriate extension.</li>
			  <li> Right click on the implementation and select a build configuration for shared 
				   libraries (i.e. linux_x86_gcc_zcf100_sca22_omni410_build_sharedlibs)</li>
			  <li> Add any necessary dependencies to the SharedLibaries_Diag and draw the 
				   appropriate dependency links from the SCAPortLibrary_linux implementation to the dependencies.</li>
			  <li> SCA validate. </li>
			</ol>
			</p>
			<p>
			To use the shared library draw Resource Dependency from one or more component or device implementations to the SCAPortLibrary. The SCAPortLibrary requires an implementation that uses the same build configuration as the source of the Resource Dependency. 
			</p>
			<p>
			<ol>
			<li> Open a component or device diagram and drag the SCAPortLibrary onto the 
				  diagram. </li>
			<li> Draw a Resource Dependency from the component or device implementation to the 
				  SCAPortLibrary. </li>
			<li> Generate Source. </li>
			</ol>
			</p>
			<p>
			The SCAPortLibrary will contain the ports and interfaces needed by all devices and components that reference the SCAPortLibrary and have an implementation that matches the SCAPortLibrary implementation.
			</p>
		</helpTopic>






		<helpTopic outputFile="aboutlib.html" title="Libraries">
			<h1>Libraries</h1>
			<p>Libraries can be modeled in CX and then referenced as a software package reference dependency. This specifies a dependency to a 
		Software Package (SPD) to the library.</p>
			<p>For example, create a SoftPkg library component named CryptoLib:</p>
			<ol>
				<li>Create a package named <strong>Libraries</strong>.</li>
				<li>Right click on the <strong>Libraries</strong> package and select <strong>Add Diagram</strong> &gt; <strong>Zeligsoft 
		Component Diagram</strong> Name the diagram <strong>Libaries_Diag</strong>.</li>
				<li>In the <strong>Palette</strong>, select <strong>Library</strong> and drop this element onto <strong>Libraries_Diag</strong>. </li>
				<li>Name the element <strong>CryptoLib</strong>.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and set <strong>isSCACompliant</strong> to 
<strong>False</strong>.</li>
				<li>In the <strong>Palette</strong>, select <strong>Component Interface</strong> and drop this element onto Libaries_Diag. Name the 
element <strong>CryptoLib_CI</strong>.</li>
				<li>Draw a <strong>Generalization</strong> from <strong>CryptoLib</strong> to <strong>CryptoLib_CI</strong>.</li>
				<li>In the <strong>Palette</strong>, select <strong>Implementation Artifact</strong> and drop this element onto the diagram. 
Name this element <strong>CryptoLib_Linux</strong>.</li>
				<li>Select <strong>CryptoLib_Linux</strong> and in the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab. 
Set <strong>code values file</strong> to <strong>cryptolib.so</strong> and <strong>type</strong> to <strong>SharedLibrary</strong>.</li>
				<li>Use the <strong>Palette</strong> to draw a <strong>Component Implementation</strong> link from the <strong>CryptoLib_Linux implementation</strong>
 to the  <strong>CryptoLib component</strong>.</li>
				<li>From the <strong>Palette</strong>, add <strong>OS</strong> and <strong>Processor</strong> elements to the <strong>Libraries_Diag</strong>
 diagram.</li>
				<li>Add <strong>OS</strong> and <strong>Processor</strong> links.</li>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="libraryprop.html">Library Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutdep.html" title="Dependencies">
			<h1>Dependencies</h1>
			<p>There are four dependency options available: Operating System, Processor, Property Dependency and Resource Dependency.</p>
			<p>An Operating System dependency states that an implementation needs a certain Operating System.</p>
			<ol>
				<li>From the Palette select <strong>Operating System</strong> and drop it onto a SCA Component Diagram.</li>
				<li>Name the Operating System element and in the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab set the 
<strong>OS version</strong>. This element can be created once and reused.</li>
				<li>Drag the Operating System element from the Project Explorer onto a SCA Component Diagram containing a component implementation.</li>
				<li>From the Palette draw an <strong>OS Link</strong> from the <strong>component implementation</strong> to the <strong>Operating System</strong>
 element.</li>
			</ol>
			<p>A Processor dependency states that an implementation needs a certain Processor.</p>
			<ol>
				<li>From the Palette select <strong>Processor</strong> and drop it onto a SCA Component Diagram. </li>
				<li>Name the Processor element. This element can be created once and reused.</li>
				<li>Drag the Processor element from the Project Explorer onto a SCA Component Diagram containing a component implementation.</li>
				<li>From the Palette draw a <strong>Processor Link</strong> from the <strong>component implementation</strong> to the <strong>
Processor</strong> element.</li>
			</ol>
			<p>Use Property Dependency to represent a PropertyRef dependency. The Property Dependency is used to express a need from an implementation 
		artifact to an allocation property. To add a Property Dependency, do the following:</p>
			<ol>
				<li>In the Zeligsoft Component Diagram, create a <strong>Primitive Property Type</strong>.</li>
				<br>Allocation properties can only be primitive types.</br>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab and set the <strong>kind</strong> property to 
		<strong>allocation</strong>.</li>
				<li>Open a Zeligsoft Component Diagram containing an <strong>Implementation Artifact</strong>.</li>
				<li>In the Palette select <strong>Property Dependency</strong> and draw a link from the <strong>Implementation Artifact</strong>
		 to the <strong>Primitive Property Type</strong> allocation property. </li>
			</ol>
			<p>Use Resource Dependency to represent a softpkgref dependency. The Resource Dependency is used to specify a dependency to a software 
		package. To add a Resource Dependency, do the following:</p>
			<ol>
				<li>In the Zeligsoft Component Diagram, create a <strong>Library</strong>.</li>
				<br>Add an implementation and any necessary dependencies. </br>
				<li>Open a Zeligsoft Component Diagram containing a Component Implementation Artifact.</li>
				<li>Drag the Library structure realization onto the diagram.</li>
				<li>In the <strong>Palette</strong>, select <strong>Resource Dependency</strong>.</li>
				<li>Draw a connection from the the <strong>Implementation Artifact</strong> to the <strong>Library</strong>.</li>
				<p>Optionally in the Properties View &gt; Stereotypes tab, define the SCAResourceDependency property of implementation to a specific library implementation.</p>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutos.html" title="Operating Systems">
			<h1>Operating Systems</h1>
			<p>Use this element to define the supported operating system(s) in your model. These are then used as Operating System dependencies for 
		your implementations. You can have multiple supported operating systems. Use the OS Link element to connect the component to the operating system.</p>
			<h3>OS Link</h3>
			<p>Use this element to connect the component implementation to the required operating system which defines the implementation dependency.</p>
			<h3>See Also</h3>
			<br>
				<a href="osprop.html">Operating System Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutproc.html" title="Processors">
			<h1>Processors</h1>
			<p>Use this element to define the supported processor(s) in your model. These are then used as Processor dependencies for your 
		implementations. You can have multiple supported processors. </p>
			<h3>Processor Link</h3>
			<p>Use this element to connect the component implementation to the required processor which defines the processor dependency.</p>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutprolang.html" title="Implementation Options">
			<h1>Implementation Options</h1>
			<p>There are three optional elements available from the palette for defining implementations. These elements can be reused and are:</p>
			<ul>
				<li>Programming Language: use this element to define the type of programming language used to build the component implementation. See D.2.1.6.6 in SCA 2.2.2.</li>
				<li>Compiler: use this element to define the compiler used to build the software component being described by the softpkg element. See D.2.1.6.4 in SCA 2.2.2.</li>
				<li>Run-Time: use this element to define the run-time system.</li>
			</ul>
			<h3>Link</h3>
			<p>There are three link options available: Programming Language Link, Compiler Link, and Run-time Link.</p>
			<p>Use these elements to connect the component implementation to the element.</p>
			<p>Implementations also have an optional language option that can be set. This defines the hummanlanguage specified in section D.2.1.6.6 in SCA 2.2. 
To set this property, select the implementation and open the Properties View &gt; Stereotypes tab.</p>
			<h3>See Also</h3>
			<br>
				<a href="programprop.html">Implementation Option Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutidlfile.html" title="IDL Files">
			<h1>IDL Files</h1>
			<p>This element is used to represent the IDL file. Modules and interfaces and other IDL constructs are within these files.</p>
			<p>Each IDL File has an option called location. You need to configure the location of the IDL file if you choose to reference an 
		existing IDL file. If you wish to generate the IDL file from CX or Copy external IDL into the generated source folder, this field is ignored. This applies to both the Core Framework IDL file 
		and user-defined IDL files.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select the IDL file folder.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab.</li>
				<li>Define the <strong>location</strong> property. For example, the CF IDL file element location is set to $(CF_FILE_LOCATION)</li>
				<li>Select <strong>Window</strong> &gt; <strong>Preferences</strong> and expand <strong>General</strong> &gt; <strong>Workspace</strong>
		 &gt; <strong>Linked Resources</strong>. Add a path variable and set the value to the location of the external IDL file.</li>
			</ol>
			<h3>IDL Import</h3>
			<p>This palette element is used to show a relationship between IDL files. It shows that one IDL file is including other IDL files and 
		creates a #include statement when generating the IDL file.</p>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutinterface.html" title="Interfaces">
			<h1>Interfaces</h1>
			<p>Client-server relationships are set up by making connections between component ports. In an SCA-compliant implementation, these connections 
		are made using CORBA interfaces.</p>
			<p>An interface is the subject of an IDL definition. It may have attributes and/or operations. Operations may have parameters and return 
values. An interface may be specified in the SCA or be component-specific. SCA-specific interfaces are classified conceptually as either
 base application, control or service interfaces. The interfaces are used in the definition of supports interfaces and uses and provides ports. </p>
			<p>To add attributes and/or operations to an interface, use the Properties View, select the Attributes or Operations tab, right-click and select Add.
</p>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutmodule.html" title="Modules">
			<h1>Modules</h1>
			<p>This palette element represents a CORBA module, typically contained within an IDL file. A CORBA module can span multiple IDL files and an 
		IDL file can contain more than one CORBA module. These modules are used to create namespaces.</p>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutpackage.html" title="Packages">
			<h1>Packages</h1>
			<p>Packages are used to group model elements. A package can contain multiple different element types. You can use packages to 
			organize your model to enable easier visibility and understanding of model elements. Packages can also be used to model the
			system architecture, with packages representing different layers. Additionally, the use of packages can make it simpler and faster 
			for you to find elements in the Project Explorer. Packages can have an unlimited number of sub-packages.</p>
			<p>Packages are a good way of organizing your model for validation purposes as well. Validating a package also validates everything 
			contained within the package.</p>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutint.html" title="Interfaces">
			<h1>Interfaces</h1>
			<p>The supported interface of an SCA-compliant component must conform to IDL definitions 
		specified in the SCA. The implementation of a supported interface must also behave according to SCA specifications. The supported interface 
		relates to the housekeeping functions of a component. The SCA specifies these "housekeeping" functions for a set of specialized components that 
		provide the infrastructure for an SCA system domain. The SCA constrains the values that the supported interface can have. An interface is 
		typically contained with in a CORBA module.</p>
			<p>The SCA interface is responsible for managing the executable resources:
Resource, ResourceFactory (Port, LifeCycle, TestableObject, PropertySet, PortSupplier), Device, ExecutableDevice, LoadableDevice and AggegrateDevice.</p>
			<h3>See Also</h3>
			<br>
				<a href="corbaintprop.html">Interface Properties</a>
			</br>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutgen.html" title="Generalizations">
			<h1>Generalizations</h1>
			<p>A generalization realizes the structural elements of the component. It realizes this in either structure, code (operations),
statemachines, mathematical functions or other concepts as defined in the domain.</p>
			<p>This generalization should be platform independent. That is, able to support all intended platforms for a particular design. The component implementation can be
used to add platform specifics if required. </p>
			<p>When a generalization is added between a component and a component interface, the methods on the provides port interfaces are 
displayed in the component structure realization. You can edit the default implementations of the worker methods. 
To do this, right-click the function and from the pop-up menu, select <strong>Open Editor</strong> to open an editor. These changes to the 
function will be added to the generated source code. </p>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="aboutintreal.html" title="Interface Realizations">
			<h1>Interface Realizations</h1>
			<p>A component structure realization can realize a component interface. This is used to model interfaces realized by a component interface
		 without using a port. For example, in the SCA we model the Resource interface using an interface realization rather than a port. This implies 
		 the component must realize the behavior for the Resource interface.</p>
			<p>Provides PortTypes realize an interface. These provides ports implement the behavior for the interface which forwards the incoming
 message on to the component worker.
</p>
			<h3>See Also</h3>
			<br>
				<a href="editviewelement.html">Editing and Viewing Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Deleting Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="editviewelement.html" title="Editing and Viewing Elements">
			<h1>Editing and Viewing Elements</h1>
			<p>You can choose to edit and view elements using the Project Explorer, Zeligsoft Component Diagram, and the Properties View.</p>
			<p>To edit or view an element, select the element in the Project Explorer or the Zeligsoft Component Diagram and then edit or view the 
		element properties with the Properties View.</p>
			<h3>See Also</h3>
			<br>
				<a href="property.html">Properties</a>
			</br>
			<br>
				<a href="workelements.html">Working with Elements</a>
			</br>
			<br>
				<a href="deleteelement.html">Delete Elements</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="deleteelement.html" title="Deleting Elements">
			<h1>Deleting Elements</h1>
			<p>To delete an element from a diagram, right-click the element and from the pop-up menu select either: <strong>Delete from Diagram</strong> or 
		<strong>Delete from Model</strong>.</p>
			<p>A confirmation message is not displayed, so ensure you are deleting the correct element.</p>
			<p>Note: from the <strong>Edit</strong> menu, you can select: <strong>Undo Delete from Model</strong> or <strong>Undo Delete from Diagram</strong>.</p>
			<p>You can delete an element from the Project Explorer. However only <strong>Delete from Model</strong> is available from Project Explorer. </p>
		</helpTopic>
		<!--Zeligsoft Elements section-->
		<helpTopic outputFile="package.html" title="Packages">
			<h1>Packages</h1>
			<p>Packages are used to group model elements. A package can contain multiple different element type. You can use packages to 
			organize your model to enable easier visibility and understanding of model elements. Packages can also be used to model the
			system architecture, with packages representing different layers. Additionally, the use of packages can make it simpler and faster 
			for you to find elements in the Project Explorer. Packages can have an unlimited number of sub-packages.</p>
			<p>Packages can be created from two locations: from the Project Explorer and from the Palette.</p>
			<p>When you have created a package, you need to apply a profile and stereotype to the package:</p>
			<ol>
				<li>Select the package in either the Project Explorer or the Zeligsoft Component Diagram.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Profiles</strong> tab.</li>
				<li>Click <strong>Apply Profile</strong>, select <strong>Zeligsoft Base Profile</strong> and click <strong>OK</strong>.</li>
				<li>Select the <strong>Stereotypes</strong> tab, click <strong>Apply Stereotype</strong>, select a stereotype and 
			click <strong>OK</strong>.</li>
			</ol>
			<p>To add elements to a package, you can click and drag the elements within the Project Explorer onto the package or do the same 
			within the Zeligsoft Component Diagram.</p>
			<p>To show package contents, use the triangle symbols in the package to show the content and to navigate the package. The 
			Project Explorer is updated to display package contents.</p>
		</helpTopic>
		<helpTopic outputFile="aboutporttypes.html" title="Port Types">
			<h1>Port Types</h1>
			<p>PortTypes define how an interface will be used on a port. A PortType that uses an interface is assigned to uses ports. A PortType 
			that realizes an interface is assigned to provides ports.</p>
			<p>CX allows you to define the port types you need to effectively model your system. </p>
			<p>To create a port type, do the following:</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select a <strong>package</strong>, right-click and from the pop-up menu select
		 <strong>Add Zeligsoft</strong> &gt; <strong>PortType</strong>.</li>
				<li>In the <strong>Name</strong> field, type a name for the port type.</li>
				<br>The Inverse Name is automatically completed.</br>
				<li>Select a <strong>Provides Interface</strong> from the list.</li>
				<br>You can select 
			 existing interfaces or click Create Interface and type a new interface name.</br>
				<li>Click <strong>OK</strong>.</li>
				<br>When you create ports, you can select the port type you created.</br>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="aboutport.html">Ports</a>
			</br>
			<br>
				<a href="porttypeprop.html">Port Type Properties</a>
			</br>
		</helpTopic>
		<!--Zeligsoft Diagrams section-->
		<helpTopic outputFile="zediagrams.html" title="Zeligsoft Diagrams">
			<h1>Zeligsoft Diagrams</h1>
			<p>This section provides details on Zeligsoft Diagrams and how they are used to model in CX.</p>
			<ul>
				<li>
					<a href="addzediagrams.html">Adding Zeligsoft Diagrams</a>
				</li>
				<li>
					<a href="deletezediagrams.html">Deleting Zeligsoft Diagrams</a>
				</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="addzediagrams.html" title="Adding Zeligsoft Diagrams">
			<h1>Adding Zeligsoft Diagrams</h1>
			<p>Use the Zeligsoft Component Diagram to do your modeling. When you create a project model, a Zeligsoft 
		Component Diagram is created and opened.</p>
			<p>To add a Zeligsoft diagram, follow these steps:</p>
			<ol>
				<li>In the Project Explorer, right click the <strong>Model</strong> or <strong>Package</strong>.</li>
				<li>From the popup menu, select <strong>Add Diagram</strong> and select: <strong>Zeligsoft 
		Component Diagram</strong>.</li>
				<li>Type a logical name for the diagram.</li>
				<p>The diagram is added to the Project Explorer. </p>
			</ol>
			<h3>See also</h3>
			<!--<br><a href="workwithzediagrams.html">Working with Zeligsoft Diagrams</a></br>-->
			<!--<br><a href="editviewzediagrams.html">Editing and Viewing Zeligsoft Diagrams</a></br>-->
			<br>
				<a href="createelement.html">Creating Elements</a>
			</br>
			<br>
				<a href="deletezediagrams.html">Deleting Zeligsoft Diagrams</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="deletezediagrams.html" title="Deleting Zeligsoft Diagrams">
			<h1>Deleting Zeligsoft Diagrams</h1>
			<p>When you delete a Zeligsoft diagram, the elements added to the diagram are not deleted.</p>
			<p>In the <strong>Project Explorer</strong>, right-click the diagram and from the pop-up menu select <strong>Delete from Model</strong>.</p>
			<p>A confirmation message is not displayed, so ensure you are deleting the correct element.</p>
			<p>Note: from the <strong>Edit</strong> menu, you can select: <strong>Undo Delete from Model</strong>.</p>
		</helpTopic>
		<!--Properties Section-->
		<helpTopic outputFile="property.html" title="Properties">
			<h1>Properties</h1>
			<p>This section provides details about configuring element properties in CX. </p>
			<p>Each element is completely customizable to meet the needs of your modeling environment. To define elements, use the 
		Properties View.</p>
			<p>When an element is created or selected, the Properties View is opened. The Properties View includes a number of sections that you use to define, edit and view element properties.
		 These sections are described below.</p>
			<p>Note: Some of the properties are specific to <RSx>RSx</RSx>, for information on these properties, refer to the <RSx>RSx</RSx> online documentation.</p>
			<h3>Properties View</h3>
			<p>
				<img src="../images/propertiesview.gif" border="0" alt="Properties View"></img>
			</p>
			<h3>General</h3>
			<p>Name: specifies the name of the element. This is an editable field.</p>
			<p>Visibility Options: specifies whether the element is public, private, protected, or a package.</p>
			<h3>Attributes</h3>
			<p>This section allows you to customize the element and further define its behavior for your model.</p>
			<p>Using the right-click pop-up menu you can do the following:</p>
			<ul>
				<li>Insert New Attribute</li>
				<li>Delete Attribute from Model</li>
				<li>Move attributes</li>
				<li>Show an attribute in the Project Explorer</li>
			</ul>
			<h3>Operations</h3>
			<p>Using the right-click pop-up menu you can do the following:</p>
			<ul>
				<li>Insert New Operation</li>
				<li>Delete from Model</li>
				<li>Move operations</li>
				<li>Show an operation in the Project Explorer</li>
			</ul>
			<h3>Stereotypes</h3>
			<p>This section displays the assigned stereotype and profile for the element. Additionally, the stereotype properties are displayed.</p>
			<p>You can edit the stereotype properties here. For details on a specific property, refer to the appropriate element topic in this section of the <pn>ProductName</pn> online help.</p>
			<p>In this section you can define, edit, and view SCA, UML, and View properties.</p>
			<p>For details on a specific SCA property, refer to the appropriate element topic in this section of the <pn>ProductName</pn> online help.</p>
			<h3>Documentation</h3>
			<p>Use this section to write notes on the element that are not detailed elsewhere.</p>
			<h3>Constraints</h3>
			<p>Constraints can be added and removed.</p>
			<h3>Relationships</h3>
			<p>Relationships are displayed.</p>
			<h3>SCA</h3>
			<p>This section displays the SCA properties for the selected element. Use this section to define, edit, update, and view 
		the SCA properties for your elements.</p>
			<h3>Appearance</h3>
			<p>Use this section to customize the appearance of the element.</p>
			<h3>Literals</h3>
			<p>Literals can be applied to enumerations using this section.</p>
			<h3>Advanced</h3>
			<p>Use this section to view the SCA and UML properties of the element or model.</p>
		</helpTopic>
		<helpTopic outputFile="definescaprop.html" title="Defining SCA Properties">
			<h1>Defining SCA Properties</h1>
			<p>There are different ways to define the elements in your model using SCA properties. Each element 
		has associated mandatory and optional SCA properties that are configured in the Properties View. These 
		properties are explained in detail in the main Properties section.</p>
			<p>In addition to these mandatory and optional SCA properties, you can also create your own SCA properties 
		for the elements in you model. These can be of configuration or allocation property type and these properties 
		can be re-used in your model. This topic explains the workflow for creating and defining SCA properties.</p>
			<h3>Create a Data Type</h3>
			<ol>
				<li>Create a data type (enumeration, primitive, struct, struct sequence, or test) and define the name.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Stereotypes</strong> tab, set the data type <strong>action</strong>, 
<strong>kind</strong>, and <strong>type</strong>.</li>
				<br>This data type can be referenced by more than one SCA Property.</br>
			</ol>
			<h3>Create an SCA Property</h3>
			<ol>
				<li>Select an element (component, component interface, or component implementation) to which you want to add SCA properties.</li>
				<li>Right-click the element and from the pop-up menu, select <strong>Add SCA</strong> &gt; <strong>SCA Property</strong>.</li>
				<li>A placeholder is added to the element. Type a name for the SCA property.</li>
				<p>Now that the SCA property has been created you can use it to reference data types within your model.</p>
				<li>Create a data type (enumeration, primitive, struct, struct sequence, or test).</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>General</strong> tab click <strong>Type</strong> and then Search for or Browse 
		for the data type you created above.</li>
				<p>This defines the type for the SCA property you created above.</p>
				<li>In the <strong>Properties View</strong> for the data type, select the <strong>General</strong> tab.</li>
				<li>Ensure you set a the <strong>Default Value</strong> for the SCA Property.</li>
				<p>To identify the default value as a literal string, surround the value with " " (double quotes).</p>
			</ol>
			<p>The following SCA properties are created for each SCA property you define:</p>
			<ul>
				<li>
					<strong>configure_body</strong>: use this property to add code to define the behavior of a specific property in the SCA. </li>
				<li>
					<strong>description</strong>: describes the implementation. See D.2.1.6.2 in SCA 2.2.2.</li>
				<li>
					<strong>mode</strong>: from the drop-down menu choose:</li>
				<ul>
					<li>readonly</li>
					<li>readwrite</li>
					<li>writeonly</li>
				</ul>
				<li>
					<strong>query_body</strong>: use this property to add code to define the behaviour of a specific property in the SCA. </li>
				<li>
					<strong>range</strong>: click the ellipse button to specify minimum and maximum values.</li>
				<li>
					<strong>runtest_body</strong>: this property is used when the Test Property Type is used. When you edit the Test source, 
		this attribute is updated with the content.</li>
				<li>
					<strong>units</strong>: this is an informational property, used to define the unit of the property type; for example, MIPS.</li>
			</ul>
			<h3>Override an SCA Property</h3>
			<p>An SCA property can be overridden on an application or a node.</p>
			<ol>
				<li>Add the component or device containing the SCA property to your application or node. </li>
				<li>Select the elements, right-click and from the pop-up menu, select <strong>SCA Properties</strong>. </li>
				<br>The SCA properties for the selected elements are displayed.</br>
				<li>In the Override SCA Properties window, you can override and edit the SCA property values. Simply select the value and make your changes. 
The default value is displayed and is indicated with (default).</li>
				<br>To revert to the default values, clear the value field. Note that you can only override SCA properties on the 
application or node - you cannot define or add new SCA properties.</br>
			</ol>
		</helpTopic>
		<helpTopic outputFile="scaproperties.html" title="SCA Application">
			<h1>SCA Application</h1>
			<p>This section provides SCA property details for each SCA element available in the SCA Application drawer of the Palette.</p>
			<ul>
				<li>
					<a href="applicationprop.html">Applications</a>
				</li>
				<li>
					<a href="componentintprop.html">Component Interfaces</a>
				</li>
				<li>
					<a href="componentprop.html">Components</a>
				</li>
				<li>
					<a href="artifactprop.html">Implementation Artifacts</a>
				</li>
				<li>
					<a href="libraryprop.html">Library</a>
				</li>
				<li>
					<a href="resfactprop.html">Resource Factory</a>
				</li>
				<li>
					<a href="propertytypeprop.html">Property Type</a>
				</li>
				<li>
					<a href="portprop.html">Ports</a>
				</li>
				<li>
					<a href="fspprop.html">Freestanding FindBy Ports</a>
				</li>
				<li>
					<a href="fspdeviceprop.html">FSP DTLTCR and DUBTCR</a>
				</li>
				<li>
					<a href="usedeviceprop.html">Uses Devices</a>
				</li>
				<li>
					<a href="osprop.html">Operating System</a>
				</li>
				<li>
					<a href="programprop.html">Implementation Option</a>
				</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="scaimplementationproperties.html" title="SCA Implementation">
			<h1>SCA Platform</h1>
			<p>This section provides SCA property details for each SCA element available in the SCA Platform drawer of the Palette.</p>
			<ul>
				<li>
					<a href="nodeprop.html">Nodes</a>
				</li>
				<li>
					<a href="componentintprop.html">Component Interfaces</a>
				</li>
				<li>
					<a href="deviceprop.html">Devices</a>
				</li>
				<li>
					<a href="artifactprop.html">Implementation Artifacts</a>
				</li>
				<li>
					<a href="libraryprop.html">Library</a>
				</li>
				<li>
					<a href="propertytypeprop.html">Property Type</a>
				</li>
				<li>
					<a href="portprop.html">Ports</a>
				</li>
				<li>
					<a href="fspprop.html">Freestanding FindBy Ports</a>
				</li>
				<li>
					<a href="usedeviceprop.html">Uses Devices</a>
				</li>
				<li>
					<a href="osprop.html">Operating System</a>
				</li>
				<li>
					<a href="programprop.html">Implementation Options</a>
				</li>
				<li>
					<a href="managerprop.html">Manager</a>
				</li>
				<li>
					<a href="dmdprop.html">DMD</a>
				</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="corbaprop.html" title="CORBA">
			<h1>CORBA</h1>
			<p>This section provides additional property details for the CORBA elements available in the CORBA drawer of the Palette.</p>
			<ul>
				<!--<li><a href="idlfileprop.html">IDL File</a></li>-->
				<!--<li><a href="enumprop.html">Enumeration</a></li>-->
				<li>
					<a href="corbaintprop.html">Interface</a>
				</li>
				<li>
					<a href="porttypeprop.html">Port Type</a>
				</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="dmdprop.html" title="DMD">
			<h1>DMD</h1>
			<p>This topic explains the properties displayed in the Stereotypes section of the Properties View.</p>
			<h3>Domain</h3>
			<p>
				<strong>description</strong>: describes the implementation. See D.2.1.6.2 in SCA 2.2</p>
			<!--<p><strong>dmdservice</strong>: xxxTBDxxx</p>-->
			<p>
				<strong>id</strong>: uniquely identifies a specific implementation of the component and is a DCE UUID value. See D.2.1.6 in SCA 2.2.</p>
			<h3>DMD Service</h3>
			<p>
				<strong>findbyName</strong>: is the name that identifies the domain finder of object of type Type.</p>
			<p>
				<strong>findbyType</strong>: one of filemanager, log, eventchannel, or namingservice. See D.6.5.1.1.3.2.</p>
			<!--<p><strong>usesIdentifier</strong>: xxxTBDxxx</p>-->
		</helpTopic>
		<helpTopic outputFile="corbaintprop.html" title="Interface">
			<h1>Interface</h1>
			<p>This topic explains the properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>isLocal</strong>: defaults to False. Use the drop-down menu to select either True or False.</p>
		</helpTopic>
		<helpTopic outputFile="applicationprop.html" title="Applications">
			<h1>Applications</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>controller</strong>: indicates the application part that is the main CF Resource controller for the assembly.</p>
			<p>
				<strong>description</strong>: used to describe the element.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX. </p>
			<p>
				<strong>version</strong>: application version number. This option is relevant for SCA 2.2.2.</p>
		</helpTopic>
		<helpTopic outputFile="componentintprop.html" title="Component Interfaces">
			<h1>Component Interfaces</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>corbaversion</strong>: is the version of the SCA. The default value is 2.2. This property 
		can be configured system-wide using the <strong>Preferences</strong> window: <strong>Preferences</strong> &gt; <strong>
		Zeligsoft</strong> &gt; <strong>SCA</strong>. This is a mandatory property.</p>
			<p>
				<strong>repositoryId</strong>: specifies the namespace of an IDL symbol.</p>
		</helpTopic>
		<helpTopic outputFile="componentprop.html" title="Components">
			<h1>Components</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>author</strong>: provides information about who worked on a particular element or model. This property 
		can be configured system-wide using the <strong>Preferences</strong> window: <strong>Preferences</strong> &gt; <strong>
		Zeligsoft</strong> &gt; <strong>SCA</strong>. This is a mandatory property.</p>
			<p>
				<strong>class_Source</strong>: use this text field to add code that you want to add to the Worker class in the header file. When the code is 
		generated, the field contents are added to the source file. You can also right click on the component and select Open Editor &gt; Class.</p>
			<p>
				<strong>cpp_Source</strong>: use this text field to add code that you want to add to the Worker cpp file. When the code is generated, 
		the field contents are added to the source file. You can also right click on the component and select Open Editor &gt; Implementation.</p>
			<p>
				<strong>description</strong>: used to describe the element.</p>
			<p>
				<strong>h_Source</strong>: use this text field to add code Worker header file. When the code is generated, the field contents are added to 
		the source file. You can also right click on the component and select Open Editor &gt; Header.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX. </p>
			<p>
				<strong>isSCACompliant</strong>: use the drop-down to set this property to True or False. By default this property is set to True.</p>
			<p>
				<strong>title</strong>: an appropriate title.</p>
			<p>
				<strong>version</strong>: component version number.</p>
		</helpTopic>
		<helpTopic outputFile="portprop.html" title="Ports">
			<h1>Ports</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<!--<p><strong>indirection</strong>: xxxTBDxxx</p>-->
			<p>
				<strong>kind</strong>: The port kind is set on port on the component interface. Click the ellipse button to open the Properties window. 
		Then click the <strong>Insert New
		Enumeration</strong> button and use the drop-down menu to select an enumeration type. A kind may have more than one value. The enumeration 
		type options are:</p>
			<ul>
				<li>data</li>
				<li>control</li>
				<li>responses</li>
				<li>test</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="artifactprop.html" title="Implementation Artifacts">
			<h1>Implementation Artifacts</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>code</strong>: click the ellipse button to open the Properties window. On the Properties window, define the: </p>
			<ul>
				<li>type: indicates the type of file being delivered to the system. Drop-down menu options are: Executable, KernelModule, 
		SharedLibrary, and Driver. </li>
				<li>file: the name of the binary file for a specific implementation of the software component (See D.2.1.6.3 in SCA 2.2). </li>
				<li>stacksize: optional parameter.</li>
				<li>entrypoint: provides the means for providing the name of the entry point of the component implementation being delivered.</li>
				<li>priority: optional parameter.</li>
			</ul>
			<p>
				<strong>description</strong>: describes the implementation.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX. </p>
			<p>
				<strong>isAEPCompliant</strong>: indicates whether the component is compliant with the AEP (Application Environment profile) as defined by 
		the SCA. See SCA 2.2, section 3.1. Use the drop-down menu to select True or False.</p>
			<p>
				<strong>language</strong>: indicates the human language for which the software component was developed. See D.2.1.6.6 in SCA 2.2.</p>
			<h3>Palette Properties</h3>
			<p>Other implementation options are available from the palette. These are options that can be created once and reused by different implementations.</p>
			<p>
				<strong>compiler</strong>: indicates the compiler used to build the software component implementation (See section D.2.1.6.4 in SCA 2.2).</p>
			<ol>
				<li>Select Compiler from the palette and drop it onto a Zeligsoft Component Diagram and set the name.</li>
				<li>In the Properties View &gt; Stereotypes tab set the compiler version.</li>
				<li>Draw a Compiler Link from the implementation to the Compiler element.</li>
				<br>This element appears in the Project explorer and can be used in other diagrams.</br>
			</ol>
			<p>
				<strong>programminglanguage</strong>: indicates the type of programming language used to build the component implementation.</p>
			<ol>
				<li>Select Programming Language from the palette and drop it onto a Zeligsoft Component Diagram and set the name.</li>
				<li>In the Properties View &gt; Stereotypes tab set the Programming Language version.</li>
				<li>Draw a Programming Language Link from the implementation to the Programming Language element.</li>
				<br>This element appears in the Project explorer and can be used in other diagrams.</br>
			</ol>
			<p>
				<strong>runtime</strong>: indicates the type of runtime necessary for the component implementation.</p>
			<ol>
				<li>Select Runtime from the palette and drop it onto a Zeligsoft Component Diagram and set the name.</li>
				<li>In the Properties View &gt; Stereotypes tab set the Programming Language version.</li>
				<li>Draw a Runtime Link from the implementation to the Runtime element.</li>
				<p>This element appears in the Project explorer and can be used in other diagrams.</p>
			</ol>
			<p>
				<strong>Dependencies</strong>:
A component implementation must contain at least one dependency. </p>
		</helpTopic>
		<helpTopic outputFile="datatypeprop.html" title="Data Types">
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX. This value uniquely identifies the component software package.
It is a DCE UUID as required by the SCA.  See SCA, version 2.2, section D.2.1.  The pertinent statements from section D.2.1 are quoted in the 
definition of the term UUID. The format of a DCE UUID is specified in the CDE1.1: Remote Procedure Call specification.</p>
			<p>
				<strong>type</strong>: this allows you to use a property multiple times within your model. For example, if you want to use the 
		DECRYPT_KEY property more than once in the model, you would define this property to allow you to re-use DECRYPT_KEY.</p>
			<!--<p><strong>index</strong>: xxTBDxxx</p>-->
		</helpTopic>
		<helpTopic outputFile="nodeprop.html" title="Nodes">
			<h1>Nodes</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>description</strong>: describes the node. See D.2.1.6.2 in SCA 2.2.</p>
			<p>
				<strong>filesystem</strong>: This optional property specifies filesystems mounted for the device manager's FileManager. Click
		 the ellipse button to open the Properties window. Then click the <strong>Insert New Class</strong> 
		button, click <strong>SCAFilesystem</strong> and specify the <strong>deviceid</strong> and <strong>name</strong>.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX. </p>
			<p>
				<strong>namingservice</strong>: specifies the path where the DomainManager is located in the namingService.</p>
		</helpTopic>
		<helpTopic outputFile="propertytypeprop.html" title="Property Types">
			<h1>Property Types</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<h3>SCAProperty</h3>
			<p>
				<strong>configure_body</strong>: use this property to add code to define the configure behavior of a specific property in the SCA.  </p>
			<p>
				<strong>description</strong>: describes the property.</p>
			<p>
				<strong>mode</strong>: from the drop-down menu choose:</p>
			<ul>
				<li>readonly</li>
				<li>readwrite</li>
				<li>writeonly</li>
			</ul>
			<p>
				<strong>query_body</strong>: : use this property to add code to define the query behavior of a specific property in the SCA. </p>
			<p>
				<strong>range</strong>: click the ellipse button to specify minimum and maximum values.</p>
			<p>
				<strong>units</strong>: this is an informational property, used to define the unit of the property type; for example, MIPS.</p>
			<h3>SCAPrimitive, SCAEnum, SCAStruct and SCASequence</h3>
			<p>
				<strong>action</strong>: this option is for allocation properties only. From  the drop-down menu, select an option:</p>
			<ul>
				<li>external</li>
				<li>lessthanorequal</li>
				<li>greaterthanorequal</li>
				<li>lessthan</li>
				<li>greaterthan</li>
			</ul>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX.</p>
			<p>
				<strong>kind</strong>: from the drop-down menu, select an option:</p>
			<ul>
				<li>allocation</li>
				<li>configure</li>
				<li>configure_and_exec</li>
				<li>test</li>
				<li>exec</li>
				<li>factory</li>
			</ul>
			<p>
				<strong>type</strong>: from the drop-down menu, select an option:</p>
			<ul>
				<li>boolean</li>
				<li>char</li>
				<li>double</li>
				<li>float</li>
				<li>short</li>
				<li>long</li>
				<li>objref</li>
				<li>octet</li>
				<li>string</li>
				<li>ulong</li>
				<li>short</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="fspprop.html" title="Freestanding FindBy Ports">
			<h1>Freestanding FindBy Ports</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>findbyName</strong>: used to connect to a component or a the service as it is registered in the naming service.</p>
			<p>
				<strong>findbyType</strong>: there are three options for this property.</p>
			<ul>
				<li>PORT: This is a freestanding port.</li>
				<li>INTERFACE: This is a freestanding interface.</li>
				<li>FINDBY: This is a freestanding findBy port.</li>
			</ul>
			<p>Note: A FSP can have a name as well. This name displays in the application or node and is for diagrammatical purposes.</p>
		</helpTopic>
		<helpTopic outputFile="fspdeviceprop.html" title="FSP DTLTCR and DUBTCR">
			<h1>FSP DTLTCR and DUBTCR</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<h3>FSP DeviceThatLoadedThisComponentRef (DTLTCR)</h3>
			<p>
				<strong>findbyName</strong>: identifies the port name that must be matched on a device.</p>
			<p>
				<strong>part</strong>: this property points to a component part in an application.</p>
			<h3>FSP DeviceUsedByThisComponentRef (DUBTCR)</h3>
			<p>
				<strong>findbyName</strong>: identifies the port name that must be matched on a device.</p>
			<p>
				<strong>part</strong>: this property points to a component part in an application.</p>
			<p>
				<strong>usesdevice</strong>: describes any uses relationships this component has with a device in the system.</p>
		</helpTopic>
		<helpTopic outputFile="libraryprop.html" title="Library">
			<h1>Library</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>author</strong>: provides information about who worked on a particular element or model. This property 
		can be configured system-wide using the <strong>Preferences</strong> window: <strong>Preferences</strong> &gt; <strong>
		Zeligsoft</strong> &gt; <strong>SCA</strong>. This is a mandatory property.</p>
			<p>
				<strong>class_Source</strong>: use this text field to add code the Worker class in the header file. When the code is generated, the field 
		contents are added to the source file. You can also right click on the component and select Open Editor &gt; Class.</p>
			<p>
				<strong>cpp_Source</strong>: use this text field to add code to the Worker cpp file. When the code is generated, the field 
		contents are added to the source file. You can also right click on the component and select Open Editor &gt; Implementation.</p>
			<p>
				<strong>description</strong>: used to describe the element.</p>
			<p>
				<strong>h_Source</strong>: use this text field to add code Worker header file. When the code is generated, the field contents are added to the 
		source file. You can also right click on the component and select Open Editor &gt; Header.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX.</p>
			<p>
				<strong>isSCACompliant</strong>: use the drop-down to set this property to True or False. By default this property is set to True.</p>
			<p>
				<strong>title</strong>: an appropriate title.</p>
			<p>
				<strong>version</strong>: library version number</p>
		</helpTopic>
		<helpTopic outputFile="osprop.html" title="Operating System">
			<h1>Operating System</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>version</strong>: operating system version number.</p>
		</helpTopic>
		<helpTopic outputFile="programprop.html" title="Implementation Options">
			<h1>Implementation Options</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>version</strong>: programming language version number.</p>
		</helpTopic>
		<helpTopic outputFile="managerprop.html" title="Manager">
			<h1>Manager</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<h3>Device Manager</h3>
			<p>
				<strong>author</strong>: provides information about who worked on a particular element or model. This property 
		can be configured system-wide using the <strong>Preferences</strong> window: <strong>Preferences</strong> &gt; <strong>
		Zeligsoft</strong> &gt; <strong>SCA</strong>. This is a mandatory property.</p>
			<p>
				<strong>description</strong>: used to describe the element.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX.</p>
			<p>
				<strong>isSCACompliant</strong>: use the drop-down to set this property to True or False. By default this property is set to True.</p>
			<p>
				<strong>title</strong>: an appropriate title.</p>
			<p>
				<strong>version</strong>: Device Manager version.</p>
			<h3>Domain Manager</h3>
			<p>
				<strong>author</strong>: provides information about who worked on a particular element or model. This property 
		can be configured system-wide using the <strong>Preferences</strong> window: <strong>Preferences</strong> &gt; <strong>
		Zeligsoft</strong> &gt; <strong>SCA</strong>. This is a mandatory property.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX.</p>
			<p>
				<strong>file</strong>: the name of the PropertyFile.</p>
			<p>
				<strong>isSCACompliant</strong>: use the drop-down to set this property to True or False. By default this property is set to True.</p>
			<p>
				<strong>description</strong>: a description of the Domain Manager descriptor.</p>
			<p>
				<strong>title</strong>: an appropriate title.</p>
			<p>
				<strong>version</strong>: Domain Manager version number</p>
		</helpTopic>
		<helpTopic outputFile="deviceprop.html" title="Devices">
			<h1>Devices</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<h3>Aggregate Device properties</h3>
			<p>
				<strong>author</strong>: provides information about who worked on a particular element or model. This property 
		can be configured system-wide using the <strong>Preferences</strong> window: <strong>Preferences</strong> &gt; <strong>
		Zeligsoft</strong> &gt; <strong>SCA</strong>. This is a mandatory property.</p>
			<p>
				<strong>description</strong>: used to describe the element.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX.</p>
			<p>
				<strong>isSCACompliant</strong>: use the drop-down to set this property to True or False. By default this property is set to True.</p>
			<p>
				<strong>title</strong>: an appropriate title.</p>
			<p>
				<strong>version</strong>: device version number</p>
			<h3>Executable, Loadable and Device properties</h3>
			<p>
				<strong>author</strong>: provides information about who worked on a particular element or model. This property 
		can be configured system-wide using the <strong>Preferences</strong> window: <strong>Preferences</strong> &gt; <strong>
		Zeligsoft</strong> &gt; <strong>SCA</strong>. This is a mandatory property.</p>
			<p>
				<strong>class_Source</strong>: use this text field to add code that you want to add to the Worker Function. When the 
		code is generated, the field contents are added to the source file. You can also right click on the component and select Open Editor &gt; Class.</p>
			<p>
				<strong>cpp_Source</strong>: use this text field to add code that you want to add to the Worker cpp file. When the 
		code is generated, the field contents are added to the source file. You can also right click on the component and select 
		Open Editor &gt; Implementation.</p>
			<p>
				<strong>description</strong>: describes the implementation. See D.2.1.6.2 in SCA 2.2.</p>
			<p>
				<strong>h_Source</strong>: use this text field to add code that you want to add to the Worker header file. When the 
		code is generated, the field contents are added to the source file. You can also right click on the component and select Open Editor &gt; Header</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX.</p>
			<p>
				<strong>isSCACompliant</strong>: use the drop-down to set this property to True or False. By default this property is set to True.</p>
			<p>
				<strong>title</strong>: an appropriate title.</p>
			<p>
				<strong>version</strong>: device version number.</p>
		</helpTopic>
		<helpTopic outputFile="resfactprop.html" title="Resource Factory">
			<h1>Resource Factory</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>author</strong>: provides information about who worked on a particular element or model. This property 
		can be configured system-wide using the <strong>Preferences</strong> window: <strong>Preferences</strong> &gt; <strong>
		Zeligsoft</strong> &gt; <strong>SCA</strong>. This is a mandatory property.</p>
			<p>
				<strong>class_Source</strong>: use this text field to add code that you want to add to the Worker Function. When the 
		code is generated, the field contents are added to the source file. You can also right click on the component and select Open Editor &gt; Class.</p>
			<p>
				<strong>cpp_Source</strong>: use this text field to add code that you want to add to the Worker cpp file. When the 
		code is generated, the field contents are added to the source file. You can also right click on the component and select Open Editor &gt; Implementation.</p>
			<p>
				<strong>description</strong>: used to describe the element.</p>
			<p>
				<strong>h_Source</strong>: use this text field to add code that you want to add to the Worker header file. When the 
		code is generated, the field contents are added to the source file. You can also right click on the component and select Open Editor &gt; Header.</p>
			<p>
				<strong>id</strong>: contains a DCE UUID generated by CX. </p>
			<p>
				<strong>isSCACompliant</strong>: use the drop-down to set this property to True or False. By default this property is set to True.</p>
			<p>
				<strong>title</strong>: an appropriate title.</p>
			<p>
				<strong>version</strong>: resource factory component version number.</p>
		</helpTopic>
		<helpTopic outputFile="usedeviceprop.html" title="Uses Device">
			<h1>Uses Device</h1>
			<p>This topic explains the SCA properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>type</strong>: this is an SCA required attribute. Set it to any string representing the type of Uses Device.</p>
		</helpTopic>
		<helpTopic outputFile="porttypeprop.html" title="Port Type">
			<h1>Port Type</h1>
			<p>This topic explains the properties displayed in the Stereotypes section of the Properties View.</p>
			<p>
				<strong>inverse</strong>: used to define the inverse port type.</p>
		</helpTopic>
		<helpTopic outputFile="addprops.html" title="Default SCA Model Elements">
			<h1>Default SCA Model Elements</h1>
			<p>When you create a new model, four folders are added to the Models folder. These read only folders are:</p>
			<ul>
				<li>(CF_IDL): contains the core framework IDL interfaces and port types</li>
				<li>(IDLPrimitives): contains the CORBA IDL</li>
				<li>(SCA_BuildEnvironments): contains the default build configuration files required for Zeligsoft code generation</li>
				<li>(SCALibrary): contains PortTypes for CF interfaces and some common SCA DataTypes </li>
				<li>(UMLPrimitiveTypes): contains the UML primitive types</li>
			</ul>
			<p>
				<img src="../images/defaultelements.gif" alt="Default SCA Model Elements"></img>
			</p>
			<p>These elements can be dragged from the Project Explorer onto the diagram you are working in and can be used to further define your 
		model elements.</p>
			<p>The default build configuration files are used when you configure build environments for the <pn>ProductName</pn> Code Generator.
</p>
		</helpTopic>
		<!--Deployments-->
		<helpTopic outputFile="deploymentsoverview.html" title="Deployments">
			<h1>Deployments</h1>
			<p>A deployment is the assignment (mapping) of components, component connections, ports, and buses to platform elements. Expressed as 
			Deployment
			Modeling, CX enables developers to map elements to logical layers, and logical layers to physical layers in any combination. </p>
			<p>CX provides a deployment editor to create and edit deployments. </p>
		</helpTopic>
		<helpTopic outputFile="deploymenteditor.html" title="Deployment Editor">
			<h1>Deployment Editor</h1>
			<p>To create a deployment, do the following:</p>
			<ul>
				<li>In the <strong>Project Explorer</strong>, right-click your <strong>model</strong> and from the pop-up menu, select 
<strong>Add Zeligsoft</strong> &gt; <strong>Deployment</strong>.</li>
				<br>The deployment is added to the Project Explorer with the following format: <i>Deploymentnumber</i>. Edit the default name to suit your model.</br>
			</ul>
			<p>To open and view a deployment, in the Deployment Editor, do the following:</p>
			<ul>
				<li>In the <strong>Project Explorer</strong>, right-click a <strong>deployment</strong> and from the pop-up menu, select 
<strong>Open with Deployment Editor</strong>.</li>
				<br>-OR-</br>
				<li>In the <strong>Project Explorer</strong>, double-click a <strong>deployment</strong>.</li>
			</ul>
			<p>The Deployment Editor has two panes: Configure and Deploy.</p>
			<p>
				<img src="../images/deploymentpanes.gif" alt="Deployment Editor"></img>
			</p>
			<p>The Configure pane is used to create deployment parts for a deployment. Deployable source and target elements need to be configured 
using the Configure pane.</p>
			<p>
				<img src="../images/configurepane2.gif" alt="Configure Pane"></img>
			</p>
			<p>Right-click an element to display the following options:</p>
			<ul>
				<li>Expand All: this expands the element to show member elements.</li>
				<li>Show In Project Explorer: this highlights the element in the Project Explorer.</li>
				<li>Delete: this deletes the element from the Deployment Tree Editor.</li>
			</ul>
			<p>To create deployment parts, do the following:</p>
			<ul>
				<li>In the <strong>Project Explorer</strong> select a valid model element and drag it onto the <strong>Configure</strong> pane.</li>
				<br>The element is added to the Configure pane and displayed in the tree and a deployment part is created on the deployment.</br>
				<br>If you try to drag an invalid element onto the Configure pane, it will be disallowed.</br>
			</ul>
			<p>The Deploy pane is used to define allocations (deployed elements).</p>
			<p>
				<img src="../images/deploypane.gif" alt="Deploy Pane"></img>
			</p>
			<p>To deploy an element, do the following:</p>
			<ol>
				<li>In the <strong>Configure</strong> pane, select the deployment target element.</li>
				<li>Drag and drop the selected element onto the <strong>Deploy</strong> pane.</li>
				<li>In the <strong>Configure</strong> pane, select the deployable source element.</li>
				<li>Drag and drop the selected element onto the target element item in the Deploy pane.</li>
				<br>An allocation is added to the deployment model element and it is displayed in the Deploy pane. Allocations are 
displayed in <strong>bold</strong>.</br>
				<br>The Deployment Editor disallows invalid deployments. If you drag an element and hover over an unexpanded element, the tree node 
will automatically expand.</br>
			</ol>
			<p>Right-click an element to display the following options:</p>
			<ul>
				<li>Expand All: this expands the element to show member elements.</li>
				<li>Show In Project Explorer: this highlights the element in the Project Explorer.</li>
				<li>Undeploy: Undeploys the element.</li>
			</ul>
			<p>The deployment model element is contained within a model or package. If that model or package has been edited and is 
therefore marked as dirty, the Deployment Editor is also marked as dirty. A save in the Deployment Editor is the
 equivalent to a save of the container model or package.</p>
			<p>If any of the model elements relevant to the deployment are edited, the deployment is updated to reflect the changes.</p>
			<h2>Filtering Deployment Parts</h2>
			<p>If the Deployment Elements filter is toggled on, the deployment parts of a deployment do not show in the Project Explorer.</p>
			<p>To control the display of deployment parts do the following:</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select the <strong>Deployment</strong>.</li>
				<li>On the tab in the <strong>Project Explorer</strong>, select the <strong>View Menu</strong> arrow.</li>
				<li>Select <strong>Customize View</strong>.</li>
				<li>Enable or disable <strong>Deployment Elements</strong> on the <strong>Filters</strong> tab.</li>
			</ol>
		</helpTopic>
		<helpTopic outputFile="creatingdeployments.html" title="SCA Deployments">
			<h1>SCA Deployments</h1>
			<p>Only configurable elements can be dragged onto the Deployment Editor Configure pane.</p>
			<p>In the SCA domain, the configurable element types are:</p>
			<ul>
				<li>SCAApplication</li>
				<li>SCAPlatform</li>
			</ul>
			<p>
				<img src="../images/scadeployment.gif" alt="SCA Deployment"></img>
			</p>
			<p>Source elements can be deployed to target elements. In the Deployment Editor, source elements on the Configure pane, 
can be dragged/deployed onto target elements on the Deploy pane.</p>
			<p>In the SCA domain, the source elements are:</p>
			<ul>
				<li>SCAComponent</li>
				<li>SCALibary</li>
				<li>SCAResourceFactory</li>
			</ul>
			<p>The target element is:</p>
			<ul>
				<li>SCALoadableDevice</li>
			</ul>
			<p>An SCAComponent, SCALibrary or SCAResourceFactory can be deployed onto an SCALoadableDevice.</p>
		</helpTopic>
		<!--Validation-->
		<helpTopic outputFile="cxvalidation.html" title="Validation">
			<h1>Validation</h1>
			<p>CX has a robust and powerful validation engine. The validation the elements you add to your model are correct.</p>
			<p>CX validation uses a containment hierarchy. That is, if you validate a package in CX, everything contained in the package is also validated.</p>
			<p>CX assists you in ensuring that the generated XML complies with the SCA. The validation that CX performs saves you time since correct 
generation means that all pieces of the puzzle fit. Hence situations where incorrect XML is downloaded to an execution environment are avoided.</p>
			<p>Using the Preferences window, you can disable the built-in validation rules.</p>
		</helpTopic>
		<helpTopic outputFile="validationprocess.html" title="Validation Process">
			<h1>Validation Process</h1>
			<p>Validation can be invoked on a model or model element by selecting the SCA Validation context menu item. </p>
			<p>After initiating validation, you are asked to wait while validation occurs. CX is verifying that the element you are validating is correct. </p>
			<p>Cautions and warnings are displayed in the Problems View. Error and warning messages are fully detailed in the Problems View.</p>
			<h2>Navigating to Error Sources</h2>
			<p>Because CX uses the <RSx>RSx</RSx> validation process, the validation uses a containment hierarchy. With this in mind, ensure you have 
			selected the correct element or model.</p>
			<p>To navigate to the source of any messages, follow these steps:</p>
			<ol>
				<li>In the <strong>Problems View</strong>, right-click the error and from the pop-up menu, select <strong>Go To</strong>.</li>
				<p>CX navigates to the source of the message.</p>
				<p>The Project Explorer displays error icons that indicate the element causing the error.</p>
			</ol>
			<h3>Problems View</h3>
			<p>
				<img src="../images/validation.gif" alt="Problems View"></img>
			</p>
			<h3>See Also</h3>
			<br>
				<a href="runvalidation.html">Activating Validation</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="runvalidation.html" title="Activating Validation">
			<h1>Activating Validation</h1>
			<p>To run CX validation, complete the following steps:</p>
			<ol>
				<li>In the <strong>Project Explorer</strong> or <strong>Zeligsoft Diagram</strong>, right-click the element and from the pop-up menu select <strong>Validate</strong>.</li>
				<p>The validation runs in the background and any errors, warnings, or informational messages are displayed in the Problems View.</p>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="validationprocess.html">Validation Process</a>
			</br>
		</helpTopic>
		<!--Implementing-->
		<helpTopic outputFile="aboutimplement.html" title="Implementing">
			<h1>Implementing</h1>
			<p>Once your model has been created and validated, the next essential step is implementation. CX enables this to operate smoothly with
	its powerful code and descriptor generation functionality. </p>
			<p>The code and descriptor generation capabilities of CX leverage the complete configuration in the model to determine the optimal code 
	to generate for the applications and the communication between the connected elements. All of the information in the model is analyzed to 
	determine the most optimized way to generate the code.</p>
			<p>The use of COE methodology and code generation tools offers a decrease in development time and increase in the ability to re-use work and the 
	associated code.</p>
			<h3>See Also</h3>
			<br>
				<a href="aboutcodegen.html">Code Generation</a>
			</br>
			<br>
				<a href="descriptgen.html">Descriptor Generation</a>
			</br>
		</helpTopic>
		<!--Code Generation-->
		<helpTopic outputFile="aboutcodegen.html" title="Code Generation">
			<h1>Code Generation</h1>
			<p>This section describes the completely customizable, out-of-the-box <pn>ProductName</pn> Code Generator and build environment and how SCA code 
			generation 
works within CX.</p>
			<h2>Component Makeup</h2>
			<p>The complete code base for an SCA-compliant component comprises two major parts: 
the SCA component code and the functional code.  The component 
code manages all the SCA artifacts, ports, and properties through the <code>CF::Resource</code> interface.  The functional code 
contains the signal processing and control behaviour for a component.</p>
			<h2>Device Makeup</h2>
			<p>The complete code base for an SCA-compliant component comprises two major parts: 
the SCA component code and the functional code.  The component 
code manages all the SCA artifacts, ports, and properties through the device interfaces: <code>CF::Device, CF::LoadableDevice, 
CF::ExecutableDevice, and CF::AggregateDevice</code>.  The functional code 
contains the signal processing and control behaviour for a device.</p>
			<h2>CORBA Versus Non-CORBA</h2>
			<p>As shown in <a href="#fig1">Figure 1</a>, the SCA component and device code is the outer shell of a component or device.  It manages any CORBA 
calls that come in.  
It performs as much processing as necessary and passes call to the functional code when needed.</p>
			<p>The functional code is non-CORBA code.</p>
			<h5>
				<a name="fig1">Figure 1: Visualization of a Component</a>
			</h5>
			<p>
				<img src="../images/ComponentVisualization.gif" width="548" height="327" border="0" alt="Component Visualization"></img>
			</p>
			<p>Code generation, as described in this document, means generation of the SCA component and device code, as well as the makefiles required to 
build this code. The functional code can be implemented in a separate workflow within <RSx>RSx</RSx>. The component and device code forwards calls to the functional code for handling where needed.</p>
			<h5>Generation Overview</h5>
			<p>
				<img src="../images/codegen.gif" width="548" height="327" border="0" alt="Generation Overview"></img>
			</p>
			<p>This diagram provides another view of the code generation process.</p>
		</helpTopic>
		<helpTopic outputFile="runcodegen.html" title="Running Code Generation">
			<h1>Running Code Generation</h1>
			<p>This topic explains how to run code generation.</p>
			<ol>
				<li>Configure the <a href="buildconfigsettings.html">Build Configuration</a> settings for the implementation. </li>
				<li>Ensure you have <a href="editsource.html">edited the worker function</a> as necessary.</li>
				<li>In the Zeligsoft Component Diagram or Project Explorer, right-click your application, node, component or device and from the pop-up menu, 
	 select <strong>CX Generate</strong> &gt; 
	 <strong>All</strong>, <strong>SCA Code</strong>, or <strong>Descriptor(s)</strong>. </li>
				<p>Where these options mean:</p>
				<ul>
					<li>All: generates source code and SCA descriptors</li>
					<li>SCA Code: generates SCA code</li>
					<li>Application Code: generates the application code</li>
					<li>Descriptor(s): generates SCA descriptors</li>
				</ul>
				<p>Note:  you can also run the <pn>ProductName</pn> Code Generator from the Deployment Tree Editor. In the <strong>Deploy</strong> pane,
	 select the application, component, resource factory structural realization or device and from the pop-up menu, select <strong>CX Generate</strong> &gt; 
	 <strong>All</strong>, <strong>Application Code</strong>, or <strong>Descriptor(s)</strong>.</p>
				<li>The <strong>Running Transformation</strong> window is displayed. If you are generating a large amount of code, click 
	 <strong>Run in Background</strong> to run the process in the background.</li>
				<p>A folder is added to the Project Explorer named <strong>
						<italic>modelname</italic>_source</strong>. If errors or warnings were detected 
	 during validation, a red x is displayed on the folder. Validation runs automatically when you select CX Generate. Depending on your 
	 generation choice, a number of folders are created that can contain worker code, functional code, application code, and SCA descriptor files.</p>
			</ol>
			<p>To compile the generated code, switch the Perspective to an appropriate programming perspective, for example C/C++ and do the following:</p>
			<ol>
				<li>Open the <strong>Make Target</strong> view.</li>
				<li>Double-click on any of the <strong>Make targets</strong> in the view. </li>
				<br>The Console view shows the build progress. This view can be configured in windows to open automatically each time a build is in progress.</br>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="codegenworkflow.html">Code Generation Workflow</a>
			</br>
			<br>
				<a href="codegenoverview.html">Generation Overview</a>
			</br>
			<br>
				<a href="codegenresp.html">SCA Code Responsibilities</a>
			</br>
			<br>
				<a href="codegencodepattern.html">Code Pattern</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="buildconfigsettings.html" title="Build Configuration">
			<h1>Build Configuration</h1>
			<p>Before generating code, you need to specify a build configuration for each component implementation you wish to generate code for. A 
	 component has one or more implementations, each one with a build configuration specification for a specific platform/operating environment. 
	 You can set general and SCA build options.</p>
			<p>To assign a build configuration to an implementation, do the following:</p>
			<ol>
				<li>In the Zeligsoft Component Diagram or Project Explorer, right-click the <strong>Implementation Artifact</strong> and 
	 from the pop-up menu, select <strong>Build Configuration</strong>.</li>
				<p>The Build Configuration window is displayed. You can configure general and domain-specific values here.</p>
				<li>Select <strong>General</strong> and configure the <strong>Base Build Configuration</strong>.</li>
				<p>From the drop-down list, select: SCA_BuildEnvironments::win32_x86_msvc7_harris26_sca22_tao13a_build or SCA_BuildEnvironments::linux_x86_gcc_zcf100_gcc22_omni410_build.</p>
				<p>Use the Base Values tab and Local Values tab to configure additional properties. The base values cannot be edited.</p>
				<p>On the Local Values tab, you can override base values by enabling <strong>Override</strong>.  
	To copy a setting from the Base Value to the Local Value tab, 
	on the <strong>Local Value</strong> tab,
	  enable <strong>Override</strong> for the appropriate property and then edit the value. You can also add to the Base Values by simply typing in 
		the appropriate field on the 
		Local Values tab, without selecting override. When <strong>Override</strong> is not selected, the Local and Base values are used.</p>
				<li>Select the domain and use the Base and Local tabs to edit the build configuration.</li>
				<p>To copy a property from the Base to the Local tab, enable <strong>Override</strong> and then edit the copied
	 property value.</p>
				<li>Click <strong>OK</strong>.</li>
			</ol>
			<p>Note when an implementation is deleted, the associated build configuration settings are also deleted.</p>
		</helpTopic>
		<helpTopic outputFile="editsource.html" title="Open Editor">
			<h1>Open Editor</h1>
			<p>This topic explains how to edit the header, class, and implementation for components and devices. When you do this 
	 before code generation, your changes to these files will be added to the generated code.</p>
			<ol>
				<li>In the Zeligsoft Component Diagram, right-click the component or device.</li>
				<li>From the right-click menu choose <strong>Open Editor &gt; Implementation</strong>, <strong>Header</strong>, or <strong>Class</strong>.</li>
				<li>Make your changes and click <strong>Save</strong>.</li>
			</ol>
			<ul>
				<li>
					<strong>Open Editor</strong> &gt; <strong>Class</strong>: use this to add code the Worker class in the header file. When the code is 
	 generated, the code is added to the source file. </li>
				<li>
					<strong>Open Editor</strong> &gt; <strong>Implementation</strong>: use this to add code to the Worker cpp file. When the code is generated, 
the code is added to the source file. </li>
				<li>
					<strong>Open Editor</strong> &gt; <strong>Header</strong>: use this to add code Worker header file. When the code is generated, the code is 
added to the source file. </li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="codegenworkflow.html" title="Code Generation Workflow">
			<h1>Code Generation Workflow</h1>
			<p>The following describes a typical workflow for code generation.</p>
			<ol>
				<li>(Optional)Configure the Make Location. In <strong>Windows &gt; Preferences &gt; Zeligsoft &gt; Modeling</strong>. Click <strong>
	 Browse</strong> to navigate to the location of the make application used to build applications.</li>
				<p>If you do not select a default make application, CX uses the default make environment that the CDT environment selects.</p>
				<li>Optionally configure additional variables to the list of Linked Resources. To open the Linked Resources window, 
	 select <strong>Windows &gt; Preferences &gt; General &gt; Workspace &gt; Linked Resources</strong>. This is usually used to instruct CX to use external IDL instead of generating IDL.</li>
				<p>When using a variable in the Build configuration or in the IDL File Location, use 
	 the variable as $(VARIABLE). However, when adding it to the linked resources, it should just be VARIABLE.</p>
				<li>Specify the <a href="buildconfigsettings.html">Build Configuration</a> for each component or device implementation. </li>
				<li>Add Functional Behavior: For each component or device, <a href="editsource.html">open its worker</a> in <RSx>RSx</RSx> and connect your functional code to the generated code. 
This includes adding 
behavior to operations defined for provides ports (incoming) and calling operations defined on uses ports (outgoing).  </li>
				<li>
					<a href="runcodegen.html">Generate Code</a>.</li>
				<br>Right click on an application, node, component or device structure realization and select CX Generate &gt; SCA Code.</br>
				<li>Compile: Compile the generated code from the Make Target view or from the command line. 
				<p><strong>Note:</strong> If IDL File Locations and Linked Resources are used to reference external IDL, these external file locations are passed into make when building from the Make Targets view. When building from the command line, these arguments have to be added to the command line.</p></li>
				<li>Run: Run the application on the intended platform using the generated XML files and the component and device implementations.</li>
				<li>Iteratively evolve the Application: CX generates code where all the user changes should be in the worker files.  Build and test iteratively, so that the 
complexity of the components, devices and overall application can be incrementally increased. </li>
			</ol>
			<h3>See Also</h3>
			<br>
				<a href="runcodegen.html">Running Code Generation</a>
			</br>
			<br>
				<a href="codegenoverview.html">Generation Overview</a>
			</br>
			<br>
				<a href="codegenresp.html">SCA Code Responsibilities</a>
			</br>
			<br>
				<a href="codegencodepattern.html">Code Pattern</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="codegenoverview.html" title="Generation Overview">
			<h1>Generation Overview</h1>
			<p>Code generation works from the component or device definition.  You can generate 100% of the code, including all of the code 
for the CF interface: <code>CF::Resource</code> (for components) or <code>CF::Device, CF::LoadableDevice, CF::ExecutableDevice, or 
CF::AggregateDevice</code> (for devices).  You do not have to modify this code.  You will also generate skeletons for the functional code, which 
you can extend.</p>
			<p>Component code is the code that handles the <code>CF::Resource</code> interface. Device code is the code that handles the 
<code>CF::Device, CF::LoadableDevice, CF::ExecutableDevice, or 
CF::AggregateDevice</code>. The Interface code manages the uses and provides ports. 
The Functional code contains the actual signal processing or control behavior of the component or device. The Code Generator generates an empty 
(but compilable) skeleton for this functional code. You then extends the skeleton with your own code.</p>
			<h5>
				<a name="fig1">Figure 1: Generation Overview</a>
			</h5>
			<p>
				<img src="../images/ComponentVisualization.gif" width="548" height="327" border="0" alt="Generation Overview"></img>
			</p>
			<p>In <a href="#fig1">Figure 1</a>, the functional code (the orange part) can be seen as surrounded by the SCA component code (the grey part). 
The grey part is 100% generated from the Code Generator. You implement the orange part by extending the skeleton code. The same visual image can be applied 
to the SCA device code.</p>
			<h3>Source directory structure</h3>
			<p>The generated source directory structure contains: functional code, component code, target specific code, and port code.</p>
			<p>
				<img src="../images/directory.gif" width="548" height="327" border="0" alt="Directory Structure"></img>
			</p>
			<h3>See Also</h3>
			<br>
				<a href="codegenworkflow.html">Code Generation Workflow</a>
			</br>
			<br>
				<a href="runcodegen.html">Running Code Generation</a>
			</br>
			<br>
				<a href="codegenresp.html">SCA Code Responsibilities</a>
			</br>
			<br>
				<a href="codegencodepattern.html">Code Pattern</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="codegenresp.html" title="SCA Code Responsibilites">
			<h1>SCA Code Responsibilities</h1>
			<p>The Main function is used to start a component or device.  It parses and manages executable parameters.  It creates a CORBA object for the 
component or device and registers the element with the CORBA namingservice.  It also starts the ORB, if required.</p>
			<p>The main CORBA class (zceMyComponentServant) for a component implements <a href="#cf">
					<code>CF::Resource</code>
				</a>, 
contains <a href="#port">ports</a>, <a href="#prop">properties</a>, and <a href="#int">interfaces</a>.  It also contains the code to manage them, 
including <code>getPort</code>, <code>configure</code>, and <code>query</code>.</p>
			<p>The main CORBA class (zceMyDeviceServant) for a device implements <a href="#cf">
					<code>CF::Device, CF::LoadableDevice, CF::ExecutableDevice, 
and CF::AggregateDevice</code>
				</a>, 
contains <a href="#port">ports</a>, <a href="#prop">properties</a>, and <a href="#int">interfaces</a>.  It also contains the code to manage them, 
including <code>getPort</code>, <code>configure</code>, and <code>query</code>.</p>
			<p>All the information required to generate the code to implement this functionality is contained in the visual model.</p>
			<h2>SCA Interfaces</h2>
			<p>The CF::Resource defines the external behaviour of an SCA component. For devices, there are four CF interfaces that define the external 
behaviour: <code>CF::Device, CF::LoadableDevice, CF::ExecutableDevice</code>, and <code>CF::AggregateDevice</code>.</p>
			<h3>CF::Resource</h3>
			<p>
				<code>CF::Resource</code> standardizes how a component has to behave, including</p>
			<ul>
				<li>Creation/destruction</li>
				<li>Configure/query</li>
				<li>Start/stop</li>
				<li>Connection</li>
				<li>Built-in test</li>
			</ul>
			<p>
				<code>CF::Resource</code> states nothing about functional code, rather it triggers the functional code.  The servant receives CORBA class for 
the <code>CF::Resource</code> interface and it triggers the functional code through standard C++ function calls.</p>
			<h3>Device CF Interfaces</h3>
			<p>These interfaces standardize how a device behaves, including:</p>
			<ul>
				<li>Creation/destruction</li>
				<li>Configure/query</li>
				<li>Start/stop</li>
				<li>Connection</li>
				<li>Built-in test</li>
			</ul>
			<p>The device interface states nothing about functional code, rather it triggers the functional code.  The servant receives CORBA class for 
the interface and it triggers the functional code through standard C++ function calls.</p>
			<h3>CF::Resource Example</h3>
			<p>
				<code>CF::Resource::start</code> is responsible for starting the processing.  The component code manages the start.  The component code 
then informs the functional code.</p>
			<h5>
				<a name="fig1">Figure 1: CF::Resource Example</a>
			</h5>
			<p>
				<img src="../images/CFResourceExample.gif" width="435" height="358" border="0" alt="CF::Resource Example"></img>
			</p>
			<h2>
				<a name="#port">Ports</a>
			</h2>
			<p>Ports define how the component or device interacts with the environment and  thus how the functional code communicates.  Ports have specified 
interfaces: Provides ports define incoming operations and Uses ports define outgoing operations. </p>
			<p>The generated code manages the CORBA aspects of both provides and uses ports. Any incoming data from a CORBA call on a provides port is 
passed through C++ calls to the functional code. Any outgoing data is sent through a C++ call to the uses port object and the latter forwards 
to the receiver.</p>
			<h5>
				<a name="fig2">Figure 2: Ports</a>
			</h5>
			<p>
				<img src="../images/Ports.gif" width="734" height="260" border="0" alt="Ports"></img>
			</p>
			<h2>
				<a name="#prop">Properties</a>
			</h2>
			<p>A component or device can have three types of properties:</p>
			<ul>
				<li>Configure properties define configurable and query-able parameters</li>
				<li>ExecParam properties command line arguments during startup</li>
				<li>Test properties define build-in tests</li>
			</ul>
			<h3>Properties Example</h3>
			<p>
				<code>CF::PropertySet::configure</code> (in Properties configProperties) is responsible for writing values to properties.  It passes a sequence 
of id (string) and value (any).  The component or device code manages the configure, which includes verifying the id and any.   It then forwards 
this data to the functional code through a C++ call to the function <code>config_&lt;propertyname&gt;</code>. The element code has already 
cast the data in the any field to the proper type and this is an input parameter to the <code>config_&lt;propertyname&gt;</code> function on the 
functional code.</p>
			<h5>
				<a name="fig3">Figure 3: Properties</a>
			</h5>
			<p>
				<img src="../images/Properties.gif" width="435" height="358" border="0" alt="Properties"></img>
			</p>
			<h3>
				<a name="int">Interfaces</a>
			</h3>
			<p>Interfaces are used on ports and supports interfaces.  The IDL needs to be compiled into C++ through the IDL2CPP provided with the ORB.  The 
C++ needs to be compiled through the C++ compiler.  This is all accomplished through the <strong>IDL_to_CPP &gt; GenerateCPP</strong> 
and <strong>IDL_to_CPP &gt; Compile_IDLCPP</strong> steps highlighted earlier.</p>
			<h3>See Also</h3>
			<br>
				<a href="codegenworkflow.html">Code Generation Workflow</a>
			</br>
			<br>
				<a href="codegenoverview.html">Generation Overview</a>
			</br>
			<br>
				<a href="runcodegen.html">Running Code Generation</a>
			</br>
			<br>
				<a href="codegencodepattern.html">Code Pattern</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="codegencodepattern.html" title="Code Pattern">
			<h1>Code Pattern</h1>
			<p>The following code pattern applies to both component and device code. The component CF Interface is <code>CF::Resource</code>.
The device CF Interfaces are: <code>CF::Device, CF::LoadableDevice, CF::ExecutableDevice</code>, and <code>CF::AggregateDevice</code>.</p>
			<h2>SCA Code Pattern</h2>
			<p>The generated source code follows a strict pattern: </p>
			<ul>
				<li>
					<a href="#m">Main class</a>: Startup</li>
				<li>
					<a href="#s">Servant</a>: CF::Interface</li>
				<li>
					<a href="#w">Worker</a>: Functional</li>
				<li>
					<a href="#p">Ports</a>: Communication objects</li>
			</ul>
			<h5>
				<a name="fig1">Figure 1: Code Pattern</a>
			</h5>
			<p>
				<img src="../images/CodePattern.gif" width="677" height="496" border="0" alt="Code Pattern"></img>
			</p>
			<h2>
				<a name="m">Main Class</a>
			</h2>
			<p>The Main class manages startup, including</p>
			<ul>
				<li>parsing executable parameters</li>
				<li>creating the CORBA object for the component or device</li>
				<li>registering components or devices in the namingservice</li>
				<li>starting the ORB (if required)</li>
			</ul>
			<p>You don't need to modify the Main class.</p>
			<h2>
				<a name="s">Servant Class</a>
			</h2>
			<p>The Servant class manages the following:</p>
			<ul>
				<li>implements all of <code>CF::Interface</code> (inherits from <code>POA_CF::Resource</code>)</li>
				<li>creates the worker</li>
				<li>creates the ports</li>
				<li>forwards calls to the worker when necessary</li>
			</ul>
			<p>You don't need to modify the Servant class.</p>
			<h2>
				<a name="w">Worker Class</a>
			</h2>
			<p>The Worker class manages the following:</p>
			<ul>
				<li>termination of <strong>CF::Interface</strong> operations, including user-defined additions to initialize, releaseObject, start, stop</li>
				<li>runs <code>config_&lt;propertyid&gt;</code>, <code>query_&lt;propertyid&gt;</code>, which are correctly casted from the configure/query methods</li>
				<li>runs test properties using <code>runTest_&lt;id&gt;</code>
				</li>
			</ul>
			<h2>
				<a name="p">Port Class</a>
			</h2>
			<p>The Provides port implements the CORBA servant for the interface defined on the port. It receives CORBA calls and forwards them to the worker 
through C++ calls. The worker inherits from an abstract interface to implement the functionality of the operations on the port. The Port class 
performs no functional processing.  It provides the connection boundary.</p>
			<p>The abstract interface that the worker inherits from is called <code>zceMyModule_MyInterfaceHandle</code>. It has 
operations <code>MyInterface_MyOperation</code> for every operation <code>MyOperation</code> on interface <code>MyInterface</code> in 
module <code>MyModule</code>. The operations have the same parameters as the functions definition in the IDL file, with the addition of 
one parameter (the first in the list), which is an integer <code>portIdentifier</code>.
The <code>portIdentifier</code> parameter allows the user to identify which port a particular function call came in on. This can be done 
through an if-statement or a switch-statement for example. The switch-statement will provide better performance especially with a high volume 
of messages.</p>
			<p>The worker inherits from this port handler class.</p>
			<h3>Provides Port</h3>
			<p>The Provides port has a user interface to the CORBA servant. It receives CORBA calls and forwards them to the worker. The worker method looks at 
the port identifier and then calls the appropriate method &lt;portname&gt;_&lt;method&gt;. This allows the components to support multiple 
provides ports of the same interface.</p>
			<h3>Uses Port</h3>
			<p>The Uses port implements a CORBA client. It receives calls from the worker and forwards them to the CORBA object on the other end of 
the connection. The uses port also implements the <code>CF::Port</code> interface as per the SCA standard. By default, the uses port only 
supports single connections. You need to modify the uses port class if multiple definitions are required.</p>
			<p>The uses port is available as an attribute within the worker class (<code>myPort_</code>).  You can make C++ calls on this object and the
 calls are directly translated into CORBA calls.</p>
			<p>The class for the uses port can be found in <code>&lt;Source Directory&gt;/ports/&lt;Module&gt;_&lt;Interface&gt;</code>.</p>
			<h3>See Also</h3>
			<br>
				<a href="codegenworkflow.html">Code Generation Workflow</a>
			</br>
			<br>
				<a href="codegenoverview.html">Generation Overview</a>
			</br>
			<br>
				<a href="codegenresp.html">SCA Code Responsibilities</a>
			</br>
			<br>
				<a href="runcodegen.html">Running Code Generation</a>
			</br>
		</helpTopic>
		<helpTopic outputFile="cppexceptionmacros.html" title="C++ Portable Exception Layer Macros">
			<h1>C++ Portable Exception Layer Macros</h1>

			<h2>Description</h2>

			<p>
				The Portable Exception Layer enables seamless cross-platform programming by providing C++-style exception handling on platforms where it is not supported.
				Code written with this layer works on platforms that support true exception handling as well as platforms that do not. Code will be compliant with the C++
				mapping, on either true-exception or non-exception platforms, when these macros are used.
			</p>
		
			<p>
				Files or modules which make use of the macros must include the scxCorbaExceptionMacros.h header file which is provided by a build configuration. A build
				configuration will support either true-exceptions or non-native exceptions, not both. It is therefore important to use a build configuration which is
				appropriate for the chosen environment.
			</p>

			<p>
				<h3>Example 1 Using Portable Exception Layer Macros</h3>
			</p>

			<pre>
// client
SCX_DECLARE_ENV;

SCX_TRY
{
   myIp->op (101, SCX_ENV_VARN);
   SCX_CHECK_ENV;
}
SCX_CATCH (myException, me)
{
   cerr &lt;&lt; "caught myException: " &lt;&lt; me.code;
}
SCX_CATCH (CORBA::SystemException, se)
{
   cerr &lt;&lt; "caught CORBA::SystemException: "
   &lt;&lt; se._rep_id () &lt;&lt; ": &lt;&lt; se.minor( ) &lt;&lt; endl;
}
SCX_CATCH_ANY ()
{
   cerr &lt;&lt; "caught some other exception" &lt;&lt; endl;
}
SCX_END_TRY

// server
void myInterface_impl::op (CORBA::Long val SCX_ENV_ARGN)
{
   if (val > 100)
   {
      myException me (val);
      SCX_THROW_RETURN_VOID (me);
   }
}
			</pre>

			<h2>Macro Definitions</h2>

			<h3>SCX_DECLARE_ENV</h3>
		
			<p>Declares a local <code>CORBA::Environment</code> instance on the stack, for use by the other Portable Exception Layer macros. If building with exceptions, this expands to nothing.</p>

			<p>If a function uses any of the Portable Exception Layer macros, it must either have an <code>SCX_ENV_ARG[1|N]</code> in its signature, or it must use <code>SCX_DECLARE_ENV</code> in its body.</p>

			<p>In the following example, <code>SCX_DECLARE_ENV</code> is required to support the correct operation of the <code>SCX_TRY/CHECK/CATCH</code> macros.</p>

			<pre>
int main (int argc, char **argv)
{
   SCX_DECLARE_ENV;
				
   SCX_TRY
   {
      do_something (SCX_ENV_VAR1);
      SCX_CHECK_ENV;
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      cerr &lt;&lt; "Caught: " &lt;&lt; e->_rep_id() &lt;&lt; endl;
   }
   SCX_END_TRY
   ...
}
			</pre>

			<p>In the next example, <code>SCX_DECLARE_ENV</code> is not required because the <code>CORBA::Environment</code> is passed into the function by declaring it with <code>SCX_ENV_ARG1</code> in its signature. In this case, it is the responsibility of the caller to create, and pass in the <code>CORBA::Environment</code>.</p>

			<pre>
void func (SCX_ENV_ARG1)
{
   do_something (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;
			
   do_something_else (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;
}
			</pre>

			<h3>SCX_ENV_ARG[1 | N]</h3>

			<p>Declares a <code>CORBA::Environment</code> formal argument in the signature of a function.</p>

			<p>The two forms, ending in either 1 or N, are for use where the signature has no other arguments, or when it does have other arguments, respectively.</p>

			<pre>
void func1 (SCX_ENV_ARG1)
{
   ...
}

void func2 (CORBA::Short arg1 SCX_ENV_ARGN)
{
   ...
}
			</pre>

			<p>Note that in the signature of <code>func2</code>, there is no comma between the last argument and the <code>SCX_ENV_ARGN</code> macro. The macro expansion contains the comma, in the non-exception case, otherwise the macro expands to nothing.</p>

			<h3>SCX_ENV_VAR[1 | N]</h3>
		
			<p>Passes the current <code>CORBA::Environment</code> as a actual argument to a function call.</p>

			<p>The two forms, ending in either 1 or N, are for use where the signature of the function being called has no other arguments, or when it does have other arguments, respectively.</p>

			<p>The actual <code>CORBA::Environment</code> passed by this macro is picked up from the local scope, using a default name. This local may have been declared within the local scope, using <code>SCX_DECLARE_ENV</code>, or passed into the local scope (function) using <code>SCX_ENV_ARG[1|N]</code>.</p>

			<p>The following example shows the use of <code>SCX_ENV_VAR[1|N]</code>:</p>

			<pre>
void func0 (SCX_ENV_ARG1)
{
   ...
}

void func1 (int arg SCX_ENV_ARGN)
{
   ...
}

void func1 (SCX_ENV_ARG1)
{
   func0 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;

   func1 (1 SCX_ENV_VARN);
   SCX_CHECK_ENV_RETURN_VOID;
   ...
}
			</pre>

			<h3>SCX_TRY</h3>

			<p>Begins a try-catch block.</p>

			<h3>SCX_TRY_LABEL(lbl)</h3>
		
			<p>Begins a try-catch block with a label to facilitate multiple try-catch blocks within a single function.</p>

			<h3>SCX_THROW (exc)</h3>

			<p>Throws the specified exception, within the context of a try block.</p>

			<p>In true exception handling environments, this macro expands to a simple throw. In a non exception handling environment, it puts the specified exception into the current <code>CORBA::Environment</code> and causes execution to jump immediately to check for and enter an appropriate <code>SCX_CATCH</code> block. If an appropriate <code>SCX_CATCH</code> block cannot be found, execution will continue following the <code>SCX_END_TRY</code>.</p>

			<p>This macro can only be used within an <code>SCX_TRY/CATCH</code> construct.</p>

			<pre>
CORBA::Boolean some_func (SCX_ENV_ARG1)
{
   SCX_TRY
   {
      ...
      SCX_THROW (CORBA::IMP_LIMIT (0, CORBA::COMPLETED_NO));
      ...
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      return 0;
   }
   SCX_END_TRY

   SCX_CHECK_ENV_RETURN (0);
   
   return 1;
}
			</pre>

			<p>Note the use of an <code>SCX_CHECK_ENV_RETURN(0)</code> immediately following the <code>SCX_END_TRY</code>. This ensures that if code within the <code>SCX_TRY</code> block throws an exception that is not caught, execution will return immediately to the caller.</p>

			<h3>SCX_THROW_LABEL (exc, lbl)</h3>

			<p>Throws the specified exception, within the context of an <code>SCX_TRY_LABEL/CATCH</code> construct.</p>

			<p>This macro is identical to <code>SCX_THROW(exc)</code> except that it should be used when in the context of a labelled try-catch block i.e. one which begins with <code>SCX_TRY_LABEL(lbl)</code>. Labelled try-catch blocks are required when more than one try-catch block is used within the same function.</p>

			<pre>
void some_func (SCX_ENV_ARG1)
{
   SCX_TRY
   {
      SCX_TRY_LABEL(a)
      {
         SCX_THROW_LABEL (MyException(), a);
      }
      SCX_CATCH (CORBA::Exception, e)
      {
         cerr &lt;&lt; e._rep_id() &lt;&lt; endl;
      }
      SCX_END_TRY
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      cerr &lt;&lt; e._rep_id() &lt;&lt; endl;
   }
   SCX_END_TRY
}
			</pre>

			<h3>SCX_THROW_RETURN (exc, ret)</h3>

			<p>Throws the specified exception, when not in the context of an <code>SCX_TRY/CATCH</code> construct i.e. where throwing the exception should cause the current function to exit immediately to the caller.</p>

			<p>The ret argument specifies the return value of the function, in the case of a non-exception build.</p>

			<p>This macro should only be used outside of <code>SCX_TRY/CATCH</code> constructs. For example:</p>

			<pre>
CORBA::Boolean some_func (SCX_ENV_ARG1)
{
   ...
   SCX_THROW_RETURN (MyException(), 0);
   ...
			
   return 1;
}
			</pre>

			<h3>SCX_THROW_RETURN_VOID (exc)</h3>

			<p>Throws the specified exception, when not in the context of an <code>SCX_TRY/CATCH</code> construct i.e. where throwing the exception should cause the current function to exit immediately to the caller.</p>

			<p>This macro is identical to <code>SCX_THROW_RETURN(exc,ret)</code> except no return value is involved because it is for use in functions having a void return type.</p>

			<pre>
void some_func (SCX_ENV_ARG1)
{
   ...
   SCX_THROW_RETURN (MyException());
   ...
}
			</pre>

			<h3>SCX_CATCH(type,var)</h3>

			<p>Catches an exception of the specified type whose instance name is specified by var.</p>

			<h3>SCX_CATCH_NOOP(type)</h3>

			<p>Catches an exception of the specified type but does not use the exception instance.</p>

			<p>By not declaring a local variable to hold the exception, this avoids compiler warnings about 'unused local variables'.</p>

			<h3>SCX_CATCH_ANY</h3>

			<p>Catches any exception.</p>

			<h3>SCX_RETHROW_RETURN(ret)</h3>

			<p>Re-throws the exception, from within the context of a catch block, and returns ret in non-exception handling environments.</p>

			<pre>
CORBA::Boolean func (SCX_ENV_ARG1)
{
   SCX_TRY
   {
      another_func (SCX_ENV_VAR1);
      SCX_CHECK_ENV;
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      SCX_RETHROW_RETURN (0);
   }
   SCX_END_TRY

   return 1;
}
			</pre>

			<h3>SCX_RETHROW_RETURN_VOID</h3>

			<p>Re-throws the exception, from within the context of a catch block.</p>

			<pre>
void func (SCX_ENV_ARG1)
{
   SCX_TRY
   {
      another_func (SCX_ENV_VAR1);
      SCX_CHECK_ENV;
   }
   SCX_CATCH (CORBA::Exception, e)
   {
      SCX_RETHROW_RETURN_VOID;
   }
   SCX_END_TRY
}
			</pre>

			<h3>SCX_CHECK_ENV</h3>

			<p>This macro is for use within the context of a try block. Within a try block, each statement which may raise an exception must be immediately followed by an <code>SCX_CHECK_ENV</code>.</p>

			<p>In non exception handling environments, this is the mechanism that transfers control to the appropriate catch block if an exception is 'thrown'.</p>

			<p>In a true exception handling environment, this macro expands to nothing.</p>

			<pre>
void func()
{
   SCX_DECLARE_ENV;

   SCX_TRY
   {
      func1 (SCX_ENV_VAR1);
      SCX_CHECK_ENV;

      func2 (SCX_ENV_VAR1);
      SCX_CHECK_ENV;
   }
   SCX_CATCH_ANY
   {
      cerr &lt;&lt; "ERROR" &lt;&lt; endl;
   }
   SCX_END_TRY
}
			</pre>

			<h3>SCX_CHECK_ENV_LABEL (lbl)</h3>

			<p>This macro is identical to <code>SCX_CHECK_ENV</code> except it is for use within a labelled try block i.e. one which begins with <code>SCX_TRY_LABEL(lbl)</code>.</p>

			<pre>
void func()
{
   SCX_DECLARE_ENV;

   SCX_TRY
   {
      ...
   }
   SCX_CATCH_ANY
   {
      ...
   }
   SCX_END_TRY
			
   SCX_TRY_LABEL(second)
   { 
      func1 (SCX_ENV_VAR1);
      SCX_CHECK_ENV_LABEL(second);
   }
   SCX_CATCH_ANY
   {
      cerr &lt;&lt; "ERROR" &lt;&lt; endl;
   }
   SCX_END_TRY
}
			</pre>

			<h3>SCX_CHECK_ENV_RETURN (ret)</h3>

			<p>This macro is similar to <code>SCX_CHECK_ENV</code>, except it is for use outside the context of a try block i.e. where an exception would cause execution to transfer immediately out of the function, up to its caller.</p>

			<p>In non exception handling environments, this macro simulates stack unwinding by using a return statement. The ret argument of this macro should evaluate to a valid return value for the enclosing function purely to satisfy the compiler. The assumption is that the caller will not actually use this value because of the exception.</p>

			<pre>
CORBA::Long func (SCX_ENV_ARG1)
{
   func1 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN(0);

   func2 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN(0);

   return 32;
}
			</pre>

			<h3>SCX_CHECK_ENV_RETURN_VOID</h3>

			<p>This is identical to the <code>SCX_CHECK_ENV_RETURN(ret)</code> macro except it is for use in functions that have a void return type.</p>

			<pre>
void func (SCX_ENV_ARG1)
{
   func1 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;

   func2 (SCX_ENV_VAR1);
   SCX_CHECK_ENV_RETURN_VOID;
}
			</pre>

			<h3>SCX_END_TRY</h3>

			<p>Declares the end of a try-catch block. This should be placed after the closing bracket of the last catch block.</p>
		</helpTopic>
		<!--Descriptor Generation-->
		<helpTopic outputFile="descriptgen.html" title="Descriptor Generation">
			<h1>Descriptor Generation</h1>
			<p>
CX generates SCA-compliant XML descriptor files from the UML 2.0 model that you define. The XML is generated from the modeling elements, their 
connections, and the attributes of these model elements. CX creates all the XML descriptor files as specified in the Domain Profile: 
</p>
			<ul>
				<li>
					<a href="spdOverview.html">Software Package Descriptor (SPD)</a>
				</li>
				<li>
					<a href="dpdOverview.html">Device Package Descriptor (DPD)</a>
				</li>
				<li>
					<a href="prfOverview.html">Properties Descriptor (PRF)</a>
				</li>
				<li>
					<a href="scdOverview.html">Software Component Descriptor (SCD)</a>
				</li>
				<li>
					<a href="sadOverview.html">Software Assembly Descriptor (SAD)</a>
				</li>
				<li>
					<a href="dcdOverview.html">Device Configuration Descriptor (DCD)</a>
				</li>
				<li>
					<a href="dmdOverview.html">DomainManager Configuration Descriptor (DMD)</a>
				</li>
			</ul>
			<p>CX generates the Software Assembly Descriptor for the application.  It also generates the Software Component and Software Package 
			Descriptors for each component contained in the application. If you have defined properties for the components, CX generates the 
			Properties Descriptors, as well. </p>
			<p>CX generates the Device Configuration Descriptor for the node.  It also generates the Software Component and Software Package Descriptors 
			for each device or Core Framework entity contained in the node.  If you have defined properties for the devices or Core Framework entities, 
			CX generates the Property Descriptors, as well. </p>
			<p>The CX user interface is intuitive: model settings are generated into their relevant descriptors. For example, the placement of 
			component instances in an application and the connection of those components is generated into the Software Assembly Descriptor, 
			while the component PackageAttributes are generated into the Software Package Descriptor. </p>
		</helpTopic>
		<helpTopic outputFile="gendescriptgen.html" title="Generating XML Descriptors">
			<h1>Generating XML Descriptors</h1>
			<p>CX can validate and generate XML for all elements including nodes, applications, component and device structure realizations, platforms, and deployments.</p>
			<ol>
				<li>In the <strong>Zeligsoft Component Diagram</strong>, select and right-click the element.</li>
				<li>From the pop-up menu, select <strong>CX Generate</strong> &gt; <strong>Descriptors</strong>.</li>
				<li>The <strong>Running Transformation</strong> window is displayed. If you are generating a large amount of descriptors, click 
	 <strong>Run in Background</strong> to run the process in the background.</li>
				<p>The SCA descriptors are added to the Project Explorer. You can view these files within <RSx>RSx</RSx>.</p>
			</ol>
		</helpTopic>
		<helpTopic outputFile="shareddescriptfiles.html" title="Shared Descriptor Files">
			<h1>Shared Descriptor Files</h1>
			<p>Property-files (PRF) files can be shared by multiple model elements a practice frequently used because it saves time when creating XML files.</p>
			<p>CX allows import of these shared XML files, which results in multiple model elements referring to the same XML files for generation. This 
			results in correct XML if and only if the content of those files (and hence the content of the model elements) is the same. Different 
			content for these model elements may lead to unexpected behavior. CX indicates shared XML files with an error to prevent possible problems.</p>
			<p>As an example, say that after import, component A and B both share a property file. If A and B have the same properties, then this is fine. 
			However, if you add a property to A, then the components generate a different property file. The final content of the XML property file 
			depends on which component was generated last, which is undefined. CX indicates these XML files with an error.</p>
			<p>Zeligsoft does not encourage the use of shared descriptor files. </p>
		</helpTopic>
		<helpTopic outputFile="scadescriptgen.html" title="SCA Descriptors">
			<h1>SCA Descriptors</h1>
			<p>This set of XML files profiles the hardware devices and software components that constitute an SCA-compliant system domain. Collectively 
			they are known as the Domain Profile.</p>
			<p>The Domain Profile is used to deploy communications software into a Software Definable Radio (SDR) device.</p>
			<p>Each descriptor is given a folder in this help documentation.  In its folder, a descriptor is presented in two ways:</p>
			<ul>
				<li>in a hierarchical view called a Link Map where each element and attribute that can take a value is linked to a detailed description</li>
				<li>as a Document Type Definition (DTD)</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="scdOverview.html" title="Software Component Descriptor (SCD)">
			<h1>Software Component Descriptor (SCD)</h1>
			<p>This XML file specifies a component's:</p>
			<ul>
				<li>supports interfaces</li>
				<li>provides ports</li>
				<li>uses ports</li>
			</ul>
			<p>A port is a way to specify access to an interface by way of middleware rather than by a direct call. A provides port is an interface 
			provided by
this component.  A uses port allows a component to make use of an interface without specifying which component will provide the interface.</p>
		</helpTopic>
		<helpTopic outputFile="dpdOverview.html" title="Device Package Descriptor (DPD)">
			<h1>Device Package Descriptor (DPD)</h1>
			<p>This XML file specifies the following:</p>
			<ul>
				<li>hardware device Registration attributes</li>
				<li>hardware configuration and revision information</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="dmdOverview.html" title="DomainManager ConfigurationDescriptor (DMD)">
			<h1>DomainManager ConfigurationDescriptor (DMD)</h1>
			<p>This XML file specifies the following:</p>
			<ul>
				<li>links to SPD files describing devices/core framework</li>
				<li>creation of devices/core framework instances</li>
				<li>creation of connection instances between ports</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="dcdOverview.html" title="Device Configuration Descriptor (DCD)">
			<h1>Device Configuration Descriptor (DCD)</h1>
			<p>This XML file specifies the following:</p>
			<ul>
				<li>what components are started on the Device Manager node; as a minimum a Device Manager is started</li>
				<li>how to obtain the Domain Manager object reference</li>
				<li>how to connect services to the Device Manager and to Devices</li>
				<li>the characteristics of the Device Manager</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="prfOverview.html" title="Property File (PRF)">
			<h1>Property File (PRF)</h1>
			<p>This XML file contains settings for component and device attributes.</p>
			<p>Allocation attributes are used in the allocateCapacity() and deallocateCapacity() operations in the Device interface.  They are used 
			during the checking of dependencies specified in the Software Package Descriptor implementation element.</p>
			<p>Configure attributes are used in the configure() and query() operations of the Resource interface.</p>
			<p>Test attributes are used in the runTest() operation in the TestableObject interface.</p>
			<p>Execparam attributes are used in the execute() operation of the Device interface.</p>
			<p>Factoryparam attributes are used in the createResource() operation of the ResourceFactory interface.</p>
		</helpTopic>
		<helpTopic outputFile="spdOverview.html" title="Software Package Descriptor (SPD)">
			<h1>Software Package Descriptor (SPD)</h1>
			<p>This XML file contains information used to deploy implementations of software components and to manage them within an SCA-compliant 
			architecture.</p>
		</helpTopic>
		<helpTopic outputFile="sadOverview.html" title="Software Assembly Descriptor (SAD)">
			<h1>Software Assembly Descriptor (SAD)</h1>
			<p>This XML file contains the following information about an application that is an assembly of subcomponents:</p>
			<ul>
				<li>requirements for collocation of components</li>
				<li>identity of the assembly controller</li>
				<li>interconnection of subcomponents</li>
				<li>ports visible at the external boundary</li>
			</ul>
		</helpTopic>
		<helpTopic outputFile="deploydescript.html" title="Deployment Descriptor">
			<h1>Deployment Descriptor Overview</h1>
			<p>This XML file contains the DeviceAssignmentSequence that can be passed to the ApplicationFactory create operation.  
</p>
		</helpTopic>
		<!--Domain References-->
		<helpTopic outputFile="domainref.html" title="Domain References">
			<h1>Domain References</h1>
			<p>This section contains domain specific documentation. Use this section to find out about domain specific behaviour and attributes.</p>
			<p>CX supports the SCA domain. </p>
		</helpTopic>
		<!--SCA Domain-->
		<helpTopic outputFile="scadomain.html" title="SCA Domain">
			<h1>SCA Domain</h1>
			<p>This section contains SCA domain specific documentation. For details on creating SCA elements and defining properties - refer to the Modeling
section.</p>
		</helpTopic>
		<!--Domain Profile DTDs-->
		<!--Domain Profile DTDs Overview-->
		<helpTopic outputFile="DomainProfileDtdOverview.html" title="Domain Profile DTDs">
			<h1>Domain Profile DTDs Overview</h1>
			<p>The following topics show the Domain Profile DTDs.  They contain links to the the online help topics to help you better understand their context within CX.</p>
			<ul>
				<li>
					<a href="SoftwarePackageDescriptor.html">Software Package Descriptor</a>
				</li>
				<li>
					<a href="DevicePackageDescriptor.html">Device Package Descriptor</a>
				</li>
				<li>
					<a href="PropertiesDescriptor.html">Properties Descriptor</a>
				</li>
				<li>
					<a href="SoftwareComponentDescriptor.html">Software Component Descriptor</a>
				</li>
				<li>
					<a href="SoftwareAssemblyDescriptor.html">Software Assembly Descriptor</a>
				</li>
				<li>
					<a href="DeviceConfigurationDescriptor.html">Device Configuration Descriptor</a>
				</li>
				<li>
					<a href="DomainManagerConfigurationDescriptor.html">DomainManager Configuration Descriptor</a>
				</li>
			</ul>
		</helpTopic>
		<!--SoftwarePackageDescriptor-->
		<helpTopic outputFile="SoftwarePackageDescriptor.html" title="Software Package Descriptor">
			<h1>Software Package Descriptor DTD</h1>
			<p>The following is the DTD for the SCA Software Package Descriptor.  Click to link to the associated topics in the online help.</p>
			<pre>
&lt;!ELEMENT softpkg
       ( title?
       , author+
       , description?
       , propertyfile?
       , descriptor?
       , implementation+
       , usesdevice*
       )&gt;
&lt;!ATTLIST softpkg
       id          ID   #REQUIRED
       name        CDATA #REQUIRED
       type        (sca_compliant | sca_non_compliant)  "sca_compliant"
       version     CDATA #IMPLIED &gt;

&lt;!ELEMENT propertyfile
       (localfile
       )&gt;
&lt;!ATTLIST propertyfile
       type        CDATA #IMPLIED&gt;

&lt;!ELEMENT localfile EMPTY&gt;
&lt;!ATTLIST localfile
       name        CDATA #REQUIRED&gt;

&lt;!ELEMENT title (#PCDATA)&gt;

&lt;!ELEMENT author
       ( name*
       , company?
       , webpage?
       )&gt;

&lt;!ELEMENT name (#PCDATA)&gt;

&lt;!ELEMENT company (#PCDATA)&gt;

&lt;!ELEMENT webpage (#PCDATA)&gt;

&lt;!ELEMENT descriptor
       (localfile
       )&gt;
&lt;!ATTLIST descriptor
       name        CDATA #IMPLIED&gt;

&lt;!ELEMENT implementation
       ( description?
       , propertyfile?
       , code
       , compiler?
       , programminglanguage?
       , humanlanguage?
       , runtime?
       , ( os
         | processor
         | dependency
         )+
       , usesdevice*
       )&gt;
&lt;!ATTLIST implementation
       id          ID   #REQUIRED
       aepcompliance (aep_compliant | aep_non_compliant) aep_compliant&gt;

&lt;!ELEMENT propertyfile
       (localfile
       )&gt;
&lt;!ATTLIST code propertyfile
       type        CDATA #IMPLIED&gt;

&lt;!ELEMENT description (#PCDATA)&gt;

&lt;!ELEMENT code
       ( localfile
       , entrypoint?
       , stacksize?
       , priority?
       )&gt;
&lt;!ATTLIST code
       type        CDATA #IMPLIED&gt;

&lt;!ELEMENT entrypoint (#PCDATA)&gt;

&lt;!ELEMENT stacksize (#PCDATA)&gt;

&lt;!ELEMENT priority (#PCDATA)&gt;

&lt;!ELEMENT compiler EMPTY&gt;
&lt;!ATTLIST compiler
       name        CDATA #REQUIRED
       version     CDATA #IMPLIED&gt;

&lt;!ELEMENT programminglanguage EMPTY&gt;
&lt;!ATTLIST programminglanguage
       name        CDATA #REQUIRED
       version     CDATA #IMPLIED&gt;

&lt;!ELEMENT humanlanguage EMPTY&gt;
&lt;!ATTLIST humanlanguage
       name        CDATA #REQUIRED&gt;

&lt;!ELEMENT os EMPTY&gt;
&lt;!ATTLIST os
       name        CDATA #REQUIRED
       version     CDATA #IMPLIED&gt;

&lt;!ELEMENT processor EMPTY&gt;
&lt;!ATTLIST processor
       name        CDATA #REQUIRED&gt;

&lt;!ELEMENT dependency
       ( softpkgref
       | propertyref
       )&gt;
&lt;!ATTLIST dependency
       type        CDATA #REQUIRED&gt;

&lt;!ELEMENT softpkgref
       ( localfile
       , implref?
       )&gt;

&lt;!ELEMENT implref EMPTY&gt;
&lt;!ATTLIST implref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT propertyref EMPTY&gt;
&lt;!ATTLIST propertyref
       refid       CDATA #REQUIRED
       value       CDATA #REQUIRED&gt;

&lt;!ELEMENT runtime EMPTY&gt;
&lt;!ATTLIST runtime
       name        CDATA #REQUIRED
       version     CDATA #IMPLIED&gt;

&lt;!ELEMENT  usesdevice
       ( propertyref+
       )&gt;
&lt;!ATTLIST usesdevice
       id          ID   #REQUIRED
       type        CDATA #REQUIRED&gt;
</pre>
		</helpTopic>
		<!--DevicePackageDescriptor-->
		<helpTopic outputFile="DevicePackageDescriptor.html" title="Device Package Descriptor">
			<h1>Device Package Descriptor DTD</h1>
			<p>The following is the DTD for the SCA Device Package Descriptor.  Click to link to the associated topics in the online help.</p>
			<pre>
&lt;!ELEMENT devicepkg
	( title?
	, author+
	, description?
	, hwdeviceregistration
	)&gt;
&lt;!ATTLIST devicepkg
	id	ID	#REQUIRED
	name	CDATA #REQUIRED
	version	CDATA #IMPLIED&gt;

&lt;!ELEMENT title (#PCDATA)&gt;

&lt;!ELEMENT author
	( name*
	, company?
	, webpage?
	)&gt;

&lt;!ELEMENT name (#PCDATA)&gt;

&lt;!ELEMENT company (#PCDATA)&gt;

&lt;!ELEMENT webpage (#PCDATA)&gt;

&lt;!ELEMENT description (#PCDATA)&gt;

&lt;!ELEMENT hwdeviceregistration
	( propertyfile?
	, description
	, manufacturer
	, modelnumber
	, deviceclass
	, childhwdevice*
     )&gt;
&lt;!ATTLIST hwdeviceregistration
	id	ID	#REQUIRED
	name	CDATA #REQUIRED
	version	CDATA #IMPLIED&gt;

&lt;!ELEMENT propertyfile
	( localfile
	)&gt;
&lt;!ATTLIST propertyfile
	type  CDATA #IMPLIED&gt;

&lt;!ELEMENT localfile EMPTY&gt;
&lt;!ATTLIST localfile
	name	CDATA #REQUIRED&gt;

&lt;!ELEMENT description (#PCDATA)&gt;

&lt;!ELEMENT manufacturer (#PCDATA)&gt;

&lt;!ELEMENT modelnumber (#PCDATA)&gt;

&lt;!ELEMENT deviceclass
	(class+
	)&gt;

&lt;!ELEMENT class (#PCDATA)&gt;

&lt;!ELEMENT childhwdevice
	(hwdeviceregistration
	|devicepkgref
	)&gt;

&lt;!ELEMENT devicepkgref
	(localfile
	)&gt;
&lt;!ATTLIST devicepkgref
	type	CDATA #IMPLIED&gt;
</pre>
		</helpTopic>
		<!--Properties Descriptor-->
		<helpTopic outputFile="PropertiesDescriptor.html" title="Properties Descriptor">
			<h1>Properties Descriptor DTD</h1>
			<p>The following is the DTD for the SCA Properties Descriptor.  Click to link to the associated topics in the online help.</p>
			<pre>
&lt;!ELEMENT properties
      ( description?
      , 	( simple
	| simplesequence
	| test
	| struct
	| structsequence
	)+
       )&gt;

&lt;!ELEMENT simple
	( description?
	, value?
	, units?
	, range?
	, enumerations?
	, kind*
	, action?
	)&gt;
&lt;!ATTLIST simple
	id	ID	#REQUIRED
	type  ( boolean	| char	| double | float
	| short	| long	| objref | octet
	| string	| ulong	| ushort 	#REQUIRED
	name  CDATA	#IMPLIED
	mode  ( readonly  | readwrite | writeonly)	"readwrite"&gt;

&lt;!ELEMENT description (#PCDATA)&gt;

&lt;!ELEMENT value (#PCDATA)&gt;

&lt;!ELEMENT units (#PCDATA)&gt;

&lt;!ELEMENT range EMPTY&gt;
&lt;!ATTLIST range
	min	CDATA #REQUIRED
	max	CDATA #REQUIRED&gt;

&lt;!ELEMENT enumerations
	( enumeration+
	)&gt;

&lt;!ELEMENT enumeration EMPTY&gt;
&lt;!ATTLIST enumeration
	label	CDATA #REQUIRED
	value	CDATA #IMPLIED&gt;

&lt;!ELEMENT kind EMPTY&gt;
&lt;!ATTLIST kind
	kindtype	(allocation | configure | test | execparam | factoryparam)
"configure"&gt;

&lt;!ELEMENT action EMPTY&gt;
&lt;!ATTLIST action
       type  ( eq  | ne | gt  |  lt | ge | le | external ) "external"&gt;

&lt;!ELEMENT simplesequence
       ( description?
       , values?
       , units?
       , range?
       , kind*
       , action?
       )&gt;
&lt;!ATTLIST simplesequence
       id   ID                                  #REQUIRED
       type  ( boolean | char   | double | float
             | short  | long   | objref | octet
             | string | ulong  | ushort )  #REQUIRED
       name  CDATA                              #IMPLIED
       mode  (readonly | readwrite | writeonly)  "readwrite"&gt;

&lt;!ELEMENT values
       ( value+
)&gt;

&lt;!ELEMENT test
       ( description
       , inputvalue?
       , resultvalue
       )&gt;
&lt;!ATTLIST test
       id          CDATA #REQUIRED&gt;

&lt;!ELEMENT inputvalue
       ( simple+
       )&gt;

&lt;!ELEMENT resultvalue
       ( simple+
       )&gt;

&lt;!ELEMENT struct
       ( description?
       , simple+
       , configurationkind?
       )&gt;
&lt;!ATTLIST struct
       id          ID   #REQUIRED
       name        CDATA #IMPLIED
       mode        (readonly | readwrite | writeonly)  "readwrite"&gt;

&lt;!ELEMENT configurationkind EMPTY&gt;
&lt;!ATTLIST configurationkind
       kindtype    (configure | factoryparam)   "configure"&gt;

&lt;!ELEMENT structsequence
       ( description?
       , structvalue+
       , configurationkind?
       )&gt;
&lt;!ATTLIST structsequence
       id         ID    #REQUIRED
       structrefid CDATA #REQUIRED
       name       CDATA #IMPLIED
       mode       (readonly | readwrite | writeonly)  "readwrite"&gt;

&lt;!ELEMENT structvalue
       (simpleref+
       )&gt;

&lt;!ELEMENT simpleref EMPTY&gt;
&lt;!ATTLIST simpleref
       refid      CDATA #REQUIRED
       value      CDATA #REQUIRED&gt;
</pre>
		</helpTopic>
		<!--Software Component Descriptor-->
		<helpTopic outputFile="SoftwareComponentDescriptor.html" title="Software Component Descriptor">
			<h1>Software Component Descriptor DTD</h1>
			<p>The following is the DTD for the SCA Software Component Descriptor.  Click to link to the associated topics in the online help.</p>
			<pre>
&lt;!ELEMENT softwarecomponent
       ( corbaversion
       , componentrepid
       , componenttype
       , componentfeatures
       , interfaces
       , propertyfile?
       )&gt;

&lt;!ELEMENT corbaversion (#PCDATA)&gt;

&lt;!ELEMENT componentrepid EMPTY&gt;
&lt;!ATTLIST componentrepid
       repid       CDATA #REQUIRED&gt;

&lt;!ELEMENT componenttype (#PCDATA)&gt;

&lt;!ELEMENT componentfeatures
       ( supportsinterface*
       , ports
       )&gt;

&lt;!ELEMENT supportsinterface EMPTY&gt;
&lt;!ATTLIST supportsinterface
       repid            CDATA #REQUIRED
       supportsname     CDATA #REQUIRED&gt;

&lt;!ELEMENT ports
       (provides
       | uses
       )*&gt;

&lt;!ELEMENT provides
       ( porttype*)&gt;
&lt;!ATTLIST provides
       repid            CDATA #REQUIRED
       providesname     CDATA #REQUIRED&gt;

&lt;!ELEMENT uses
       ( porttype*)&gt;
&lt;!ATTLIST uses
       repid       CDATA #REQUIRED
       usesname    CDATA #REQUIRED&gt;

&lt;!ELEMENT porttype EMPTY&gt;
&lt;!ATTLIST porttype
      type  ( data      | control   |
            responses   | test )    #REQUIRED&gt;

&lt;!ELEMENT interfaces
       ( interface+
       )&gt;

&lt;!ELEMENT interface
       ( inheritsinterface*)&gt;
&lt;!ATTLIST interface
       repid       CDATA #REQUIRED
       name        CDATA #REQUIRED&gt;

&lt;!ELEMENT inheritsinterface EMPTY&gt;
&lt;!ATTLIST inheritsinterface
       repid       CDATA #REQUIRED&gt;

&lt;!ELEMENT propertyfile
       (localfile
       )&gt;
&lt;!ATTLIST propertyfile
       type        CDATA #IMPLIED&gt;

&lt;!ELEMENT localfile EMPTY&gt;
&lt;!ATTLIST localfile
       name        CDATA #REQUIRED&gt;
</pre>
		</helpTopic>
		<!--Software Assembly Descriptor-->
		<helpTopic outputFile="SoftwareAssemblyDescriptor.html" title="Software Assembly Descriptor">
			<h1>Software Assembly Descriptor DTD</h1>
			<p>The following is the DTD for the SCA Assembly Component Descriptor.  Click to link to the associated topics in the online help.</p>
			<pre>
&lt;!ELEMENT softwareassembly
       ( description?
       , componentfiles
       , partitioning
       , assemblycontroller
       , connections?
       , externalports?
       )&gt;
&lt;!ATTLIST softwareassembly
       id          ID   #REQUIRED
       name        CDATA #IMPLIED&gt;

&lt;!ELEMENT description (#PCDATA)&gt;

&lt;!ELEMENT componentfiles
       ( componentfile+
       )&gt;

&lt;!ELEMENT componentfile
       ( localfile
       )&gt;
&lt;!ATTLIST componentfile
       id          ID   #REQUIRED
       type        CDATA #IMPLIED&gt;

&lt;!ELEMENT localfile EMPTY&gt;
&lt;!ATTLIST localfile
       name        CDATA #REQUIRED&gt;

&lt;!ELEMENT partitioning
       ( componentplacement
       |  hostcollocation
       )*&gt;

&lt;!ELEMENT componentplacement
       ( componentfileref
       , componentinstantiation+
       )&gt;

&lt;!ELEMENT componentfileref  EMPTY&gt;
&lt;!ATTLIST componentfileref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT componentinstantiation
       ( usagename?
       , componentproperties?
       , findcomponent?
       )&gt;
&lt;!ATTLIST componentinstantiation
       id          ID   #REQUIRED&gt;

&lt;!ELEMENT usagename (#PCDATA)&gt;

&lt;!ELEMENT componentproperties
       ( simpleref
       | simplesequenceref
       | structref
       | structsequenceref
       )+ &gt;

&lt;!ELEMENT findcomponent
       ( componentresourcefactoryref
       | namingservice
       )&gt;

&lt;!ELEMENT componentresourcefactoryref
       ( resourcefactoryproperties?
       )&gt;
&lt;!ATTLIST componentresourcefactoryref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT resourcefactoryproperties
       ( simpleref
       | simplesequenceref
       | structref
       | structsequenceref
       )+ &gt;

&lt;!ELEMENT simpleref EMPTY&gt;
&lt;!ATTLIST simpleref
       refid       CDATA #REQUIRED
       value       CDATA #REQUIRED&gt;

&lt;!ELEMENT simplesequenceref
       (values
       )&gt;
&lt;!ATTLIST simplesequenceref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT structref
       (simpleref+
       )&gt;
&lt;!ATTLIST structref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT structsequenceref
       ( structvalue+
       )&gt;
&lt;!ATTLIST structsequenceref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT structvalue
       (simpleref+
       )&gt;

&lt;!ELEMENT values
       ( value+
       )&gt;

&lt;!ELEMENT value (#PCDATA)&gt;
&lt;!ELEMENT hostcollocation
       ( componentplacement
       )+&gt;
&lt;!ATTLIST hostcollocation
       id          ID    #IMPLIED
       name        CDATA #IMPLIED&gt;

&lt;!ELEMENT assemblycontroller
       ( componentinstantiationref
       )&gt;

&lt;!ELEMENT connections
       ( connectinterface*
       )&gt;

&lt;!ELEMENT connectinterface
       ( usesport
       , ( providesport
             | componentsupportedinterface
             | findby
         )
       )&gt;
&lt;!ATTLIST connectinterface
       id          ID    #IMPLIED&gt;

&lt;!ELEMENT usesport
       ( usesidentifier
       , (componentinstantiationref
          | devicethatloadedthiscomponentref
          | deviceusedbythiscomponentref
          | findby
          )
       )&gt;

&lt;!ELEMENT usesidentifier (#PCDATA)&gt;

&lt;!ELEMENT componentinstantiationref EMPTY&gt;
&lt;!ATTLIST componentinstantiationref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT findby
       ( namingservice
       | domainfinder
       )&gt;

&lt;!ELEMENT namingservice EMPTY&gt;
&lt;!ATTLIST namingservice
       name        CDATA #REQUIRED&gt;

&lt;!ELEMENT domainfinder EMPTY&gt;
&lt;!ATTLIST domainfinder
       type        (filemanager |log | eventchannel | namingservice | servicename | servicetype)
       #REQUIRED
       name        CDATA #IMPLIED&gt;

&lt;!ELEMENT devicethatloadedthiscomponentref EMPTY&gt;
&lt;!ATTLIST devicethatloadedthiscomponentref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT deviceusedbythiscomponentref EMPTY&gt;
&lt;!ATTLIST deviceusedbythiscomponentref
       refid       CDATA #REQUIRED
       usesrefid   CDATA #REQUIRED&gt;

&lt;!ELEMENT providesport
       ( providesidentifier
       , ( componentinstantiationref
         | devicethatloadedthiscomponentref
         | deviceusedbythiscomponentref
         | findby
        )
       )&gt;

&lt;!ELEMENT providesidentifier (#PCDATA)&gt;

&lt;!ELEMENT componentsupportedinterface
       ( supportedidentifier
       , ( componentinstantiationref
         | findby
         )
       )&gt;

&lt;!ELEMENT supportedidentifier (#PCDATA)&gt;

&lt;!ELEMENT externalports
       (port+
       )&gt;

&lt;!ELEMENT port
       ( description?
       , (usesidentifier | providesidentifier | supportedidentifier)
       , componentinstantiationref
       )&gt;
</pre>
		</helpTopic>
		<!--Device Configuration Descriptor-->
		<helpTopic outputFile="DeviceConfigurationDescriptor.html" title="Device Configuration Descriptor">
			<h1>Device Configuration Descriptor DTD</h1>
			<p>The following is the DTD for the SCA Device Configuration Descriptor.  Click to link to the associated topics in the online help.</p>
			<pre>
&lt;!ELEMENT deviceconfiguration
       ( description?
       , devicemanagersoftpkg
       , componentfiles?
       , partitioning?
       , connections?
       , domainmanager
       , filesystemnames?
       )&gt;
&lt;!ATTLIST deviceconfiguration
       id          ID   #REQUIRED
       name        CDATA #IMPLIED&gt;

&lt;!ELEMENT description (#PCDATA)&gt;

&lt;!ELEMENT devicemanagersoftpkg
       ( localfile
       )&gt;

&lt;!ELEMENT componentfiles
       ( componentfile+
       )&gt;

&lt;!ELEMENT componentfile
       ( localfile
       )&gt;
&lt;!ATTLIST componentfile
       id          ID   #REQUIRED
       type        CDATA #IMPLIED&gt;

&lt;!ELEMENT localfile EMPTY&gt;
&lt;!ATTLIST localfile
       name        CDATA #REQUIRED&gt;

&lt;!ELEMENT partitioning
       ( componentplacement
       )*&gt;

&lt;!ELEMENT componentplacement
       ( componentfileref
       , deployondevice?
       , compositepartofdevice?
       , devicepkgfile?
       , componentinstantiation+
       )&gt;

&lt;!ELEMENT componentfileref  EMPTY&gt;
&lt;!ATTLIST componentfileref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT deployondevice  EMPTY&gt;
&lt;!ATTLIST deployondevice
       refid       CDATA #REQUIRED&gt;
&lt;!ELEMENT compositepartofdevice  EMPTY&gt;
&lt;!ATTLIST compositepartofdevice
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT devicepkgfile
       (localfile
       )&gt;
&lt;!ATTLIST devicepkgfile
       type        CDATA #IMPLIED&gt;

&lt;!ELEMENT componentinstantiation
       ( usagename?
        ,componentproperties?
       )&gt;
&lt;!ATTLIST componentinstantiation
       id   ID     #REQUIRED&gt;

&lt;!ELEMENT usagename (#PCDATA)&gt;

&lt;!ELEMENT componentproperties
       ( simpleref
       | simplesequenceref
       | structref
       | structsequenceref
       )+ &gt;

&lt;!ELEMENT simpleref EMPTY&gt;
&lt;!ATTLIST simpleref
       refid       CDATA #REQUIRED
       value       CDATA #REQUIRED&gt;

&lt;!ELEMENT simplesequenceref
       (values
       )&gt;
&lt;!ATTLIST simplesequenceref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT structref
       (simpleref+
       )&gt;
&lt;!ATTLIST structref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT structsequenceref
       ( structvalue+
       )&gt;
&lt;!ATTLIST structsequenceref
       refid       CDATA #REQUIRED&gt;

&lt;!ELEMENT structvalue
       (simpleref+
       )&gt;

&lt;!ELEMENT values
       ( value+
       )&gt;
&lt;!ELEMENT value (#PCDATA)&gt;

&lt;!ELEMENT connections
      ( connectinterface*
      )&gt;

&lt;!ELEMENT connectinterface
       ( usesport
       , ( providesport
         | componentsupportedinterface
         | findby
         )
       )&gt;
&lt;!ATTLIST connectinterface
       id          ID   #IMPLIED&gt;

&lt;!ELEMENT usesport
       ( usesidentifier
       , (componentinstantiationref
          | devicethatloadedthiscomponentref
          | deviceusedbythiscomponentref
          | findby
          )
       )&gt;

&lt;!ELEMENT usesidentifier (#PCDATA)&gt;

&lt;!ELEMENT componentinstantiationref EMPTY&gt;
&lt;!ATTLIST componentinstantiationref
       refid CDATA #REQUIRED&gt;

&lt;!ELEMENT devicethatloadedthiscomponentref EMPTY&gt;
&lt;!ATTLIST devicethatloadedthiscomponentref
       refid CDATA #REQUIRED&gt;

&lt;!ELEMENT deviceusedbythiscomponentref EMPTY&gt;
&lt;!ATTLIST deviceusedbythiscomponentref
       refid       CDATA #REQUIRED
       usesrefid   CDATA #REQUIRED&gt;

&lt;!ELEMENT providesport
       ( providesidentifier
       , ( componentinstantiationref
         | devicethatloadedthiscomponentref
         | deviceusedbythiscomponentref
         | findby
         )
       )&gt;

&lt;!ELEMENT providesidentifier (#PCDATA)&gt;

&lt;!ELEMENT componentinstantiationref EMPTY&gt;
&lt;!ATTLIST componentinstantiationref
       refid CDATA #REQUIRED&gt;

&lt;!ELEMENT componentsupportedinterface
      ( supportedidentifier
      , ( componentinstantiationref
        | findby
        )
      )&gt;

&lt;!ELEMENT supportedidentifier (#PCDATA)&gt;

&lt;!ELEMENT domainmanager
      ( namingservice )&gt;

&lt;!ELEMENT namingservice EMPTY&gt;
&lt;!ATTLIST namingservice
      name       CDATA #REQUIRED&gt;

&lt;!ELEMENT findby
      ( namingservice
      | domainfinder
      )&gt;

&lt;!ELEMENT domainfinder EMPTY&gt;
&lt;!ATTLIST domainfinder
      type       (filemanager |log | eventchannel | namingservice)
      #REQUIRED
      name       CDATA #IMPLIED&gt;

&lt;!ELEMENT filesystemnames
      (filesystemname+
      )&gt;

&lt;!ELEMENT filesystemname EMPTY&gt;
&lt;!ATTLIST filesystemname
      mountname  CDATA #REQUIRED
      deviceid   CDATA #REQUIRED&gt;
</pre>
		</helpTopic>
		<!--DomainManager Configuration Descriptor-->
		<helpTopic outputFile="DomainManagerConfigurationDescriptor.html" title="Domain Manager Configuration Descriptor">
			<h1>DomainManager Configuration Descriptor DTD</h1>
			<p>The following is the DTD for the SCA Domain Manager Configuration Descriptor.  Click to link to the associated topics in the online help.</p>
			<pre>
&lt;!ELEMENT domainmanagerconfiguration
	 ( description?
	 , domainmanagersoftpkg
	 , services
	 )&gt;
&lt;!ATTLIST domainmanagerconfiguration
	id	ID	#REQUIRED
	name	CDATA #REQUIRED&gt;

&lt;!ELEMENT description (#PCDATA)&gt;

&lt;!ELEMENT devicemanagersoftpkg
	( localfile
	)&gt;

&lt;!ELEMENT services
	( service+
	)&gt;

&lt;!ELEMENT service
	( usesidentifier
	, findby
	)&gt;

&lt;!ELEMENT usesidentifier (#PCDATA)&gt;

&lt;!ELEMENT findby
	( namingservice

	| domainfinder
	)&gt;

&lt;!ELEMENT namingservice EMPTY&gt;
&lt;!ATTLIST namingservice
	name 	CDATA #REQUIRED&gt;


&lt;!ELEMENT domainfinder EMPTY&gt;
&lt;!ATTLIST domainfinder
	type	CDATA #REQUIRED
	name	CDATA #IMPLIED&gt;
</pre>
		</helpTopic>
		<!--Tutorials-->
		<!--intro-->
		<helpTopic outputFile="tutorialintro.html" title="Tutorials">
			<h1>Tutorials</h1>
			<p>The tutorials in this section provide you with a comprehensive introduction to working with CX. You will learn about element creation, 
property definition, validation, and generation. These tutorials will help you learn about the concepts fundamental to COE and CX.</p>
			<p>These tutorials are sequential, you must start with <a href="tutorial1.html">Tutorial 1: Learning the Basics</a>.</p>
		</helpTopic>
		<!--Tutorial 1-->
		<helpTopic outputFile="tutorial1.html" title="Tutorial 1: Learning the Basics">
			<h1>Tutorial 1: Learning the Basics</h1>
			<p>
				<pn>ProductName</pn> is the backbone of SCA development. Using components, UML 2.0, and domain specializations you can dynamically build and design systems. 
CX takes you to the next step by combining the model and the code for a true model driven development process. With CX you model structure and implementations to define
SCA compliant applications and platforms. The validation feature takes things one step further, to ensure that SCA compliance is guaranteed.</p>
			<p>In this introductory tutorial you will learn how to:</p>
			<ul>
				<li>create projects and models</li>
				<li>define preferences</li>
				<li>create elements, including applications, components, ports, and connectors</li>
			</ul>
			<h2>Create a new project and model</h2>
			<p>Models are saved in EMX format. A single project can have multiple models - you can use the elements from different models within one project.
 Additionally, you may want to have separate platform and application models. However, for simplicity, this tutorial will use just one model.</p>
			<ol>
				<li>From the <strong>File</strong> menu, select <strong>New &gt; SCA Model Project</strong>.</li>
				<li>In the <strong>Project Name</strong> field, type <strong>CXTutorial</strong> and click <strong>Next</strong>.</li>
				<li>In the <strong>Model Name</strong> field, type <strong>CXTutorial_Model</strong>.</li>
				<li>In the <strong>CDT Project Name</strong> field, type <strong>CXTutorial_Model_src</strong> and click <strong>Finish</strong>.</li>
			</ol>
			<p>The model project is displayed in the Project Explorer. This model project folder contains a Diagrams folder and a Models folder. These folders are not real folders, in the file system. Rather, they provide a logical view of elements in your model. The Diagrams 
folder contains all the diagrams in your project. </p>
			<p>In the Models folder, a <strong>modelConfiguration</strong> entry is listed in the Project Explorer. Use this to view and edit the model configuration.</p>
			<h2>Define preference settings</h2>
			<p>CX preferences are organized into three categories: Modeling, SCA, and Validation.</p>
			<p>In this section you will configure the Modeling and SCA preferences and review the default Validation preference settings.</p>
			<p>The Modeling preferences include:</p>
			<ul>
				<li>Post-fix for Inverse Port Type: allows you to control how the inverse port type is named. By default this attribute is set to Inv.
		</li>
				<li>Make location: location of the make application used to build applications. Type the location or click Browse.</li>
			</ul>
			<p>The SCA preferences include the following:</p>
			<ul>
				<li>CORBA Version: the default value is 2.2. Ensure this attribute is configured to match your system.</li>
				<li>Repository Version Identifier: the default value is 1.0.</li>
				<li>Author properties: configure the Name, Company, and Webpage properties.</li>
				<li>Component wizard options: configure the default executable file extension for elements created with the Component Creation Wizard.</li>
				<li>SCA 2.2.2 Extension: select when modeling SCA 2.2.2 Extension elements. Enables SCA 2.2.2 Extension DTD files.</li>
			</ul>
			<ol>
				<li>From the <strong>Windows</strong> menu, select <strong>Preferences</strong>.</li>
				<li>In the Preferences window, expand <strong>Spectra CX</strong>.</li>
				<p>The Modeling and Validation sections are displayed.</p>
				<li>To view the suffix for inverse PortType and Make location options, select <strong>Modeling</strong>. By default the inverse PortType option is enabled 
		and set to Inv.</li>
				<li>Select <strong>SCA</strong> to display the SCA preferences.</li>
				<li>In the <strong>Author properties</strong> section, type your <strong>Name</strong>, <strong>Company</strong>, and <strong>Webpage</strong> information.</li>
				<p>The CORBA Version and Repository Version Identifier are configured with default values.</p>
				<li>Click <strong>Apply</strong>.</li>
				<li>Review the <strong>Component options</strong>.</li>
				<li>Select <strong>Validation</strong> and review the validation constraints. By default all constraints are enabled.</li>
				<li>Click <strong>OK</strong>.</li>
			</ol>
			<h2>Create a package</h2>
			<p>You can use packages to group or contain common elements and to help you better organize your elements.</p>
			<ol>
				<li>In Project Explorer, right-click on <strong>CXTutorial_Model</strong> and from the popup menu, 
select <strong>Add CX</strong> &gt; <strong>Package</strong>. </li>
				<li>Name the Package, <strong>TutorialApplication</strong>.</li>
				<p>The package is added to the Project Explorer.</p>
			</ol>
			<p>You will use this package to "hold" or "contain" the elements you create in this tutorial.</p>
			<h2>Create a component</h2>
			<p>A component represents a software module (source code, binary code, executable, DLL, etc.) with a well-defined interface. The interface of a component is represented by one or 
		several interface elements that the component provides. Components are used to show compiler and run-time dependencies, as well as interface and calling dependencies among software modules. 
		</p>
			<p>Using the Component Wizard you will create a component and the corresponding associated component interface, implementation, package, and diagram.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select the <strong>TutorialApplication</strong> package.</li>
				<li>To open the <strong>Component Wizard</strong>, right-click the <strong>TutorialApplication</strong> package and select 
<strong>Add CX</strong> &gt; <strong>Component</strong>.</li>
				<li>In the <strong>Component Name</strong> field, type <strong>Decryptor</strong>.</li>
				<br>All other fields in the wizard are optional but enabled. </br>
				<br>The wizard will create a corresponding Component Interface, Implementation, Executable File, Package, and Diagram for the component.</br>
				<li>In the <strong>Component Interface</strong>, select <strong>Resource</strong> from the <strong>Type</strong> drop-down list.</li>
				<li>Click <strong>Finish</strong>.</li>
				<li>In the <strong>CX Component Diagram</strong>, select <strong>DecryptorInterface</strong>.</li>
				<li>Select the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab. This is where SCA component property values can be viewed and/or set.</li>
				<li>Create a second component, in the <strong>TutorialApplication</strong> package, named <strong>Filter</strong>.</li>
			</ol>
			<p>The new elements are displayed on the diagram you created with the Component Wizard.</p>
			<h2>Add User IDL to the Model</h2>
			<p>IDL is used to specify interfaces used for communication. PortTypes are then created from this IDL to specify how the interface is 
used (i.e. provides or uses ports). IDL may be modeled or imported.</p>
			<ol>
				<li>In <strong>Project Explorer</strong>, select <strong>CXTutorial_Model</strong> and create a 
new package called <strong>Communication</strong>.</li>
				<li>In <strong>Project Explorer</strong>, select the <strong>Communication</strong> package, right-click and
from the popup menu, select <strong>Add Diagram</strong> and select: <strong>CX 
		Component Diagram</strong>.</li>
				<li>Name the diagram, <strong>Communication</strong>.</li>
				<li>In the <strong>Palette</strong>, expand the <strong>CORBA</strong> drawer and select <strong>IDL File</strong>.</li>
				<li>Drop the element onto the new diagram. Name the element, <strong>DataFile</strong>.</li>
				<li>This IDL file depends on <strong>CF.idl</strong>. In the <strong>Project Explorer</strong> drag <strong>CXTutorial_Model::CF_IDL::CF</strong>
 onto the <strong>Communication</strong> diagram.</li>
				<li>In the <strong>Palette</strong> select <strong>IDL Include</strong> link and draw a link from the <strong>DataFile</strong> to <strong>CF</strong>
 on the <strong>Communication</strong> diagram. This will cause a #include &lt;CF.idl&gt; to be generated in the DataFile.idl file.</li>
				<li>In the <strong>CORBA</strong> drawer, select <strong>Module</strong> and drop the element onto the diagram.</li>
				<li>Name the element, <strong>Data</strong>.</li>
				<li>In the <strong>CORBA</strong> drawer, select <strong>Interface</strong> and drop it onto the diagram.</li>
				<li>Name the element, <strong>EncryptedData</strong>.</li>
				<li>Create two more <strong>Interface</strong> elements and name them <strong>OpenData</strong> and <strong>ProcessedData</strong>.</li>
				<li>In the <strong>Project Explorer</strong>, move the elements so that <strong>Data</strong> is in the <strong>DataFile</strong> element and that 
the three new Interfaces (<strong>EncryptedData</strong>, <strong>OpenData</strong>, and <strong>ProcessedData</strong>) are in the 
<strong>Data</strong> element.</li>
				<li>Right-click on the <strong>Communication</strong> diagram and from the popup menu, select <strong>Filters</strong> &gt; <strong>Show/Hide 
Relationships</strong> and then click <strong>OK</strong>.</li>
				<br>The containment relationships are now displayed on the diagram.</br>
				<li>In the <strong>Project Explorer</strong>, select <strong>EncryptedData</strong>.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Operations</strong> tab.</li>
				<li>Click the <strong>Insert New Operation</strong> button. Be careful to click the drop down arrow, rather than the button itself. This will reveal a menu from which you should select <strong>CORBA Operation</strong></li>
				<li> Create a new operation called <strong>pushEncryptedData</strong>.</li>
				<li>In the <strong>Project Explorer</strong>, select <strong>pushEncryptedData</strong>.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>Parameters</strong> tab.</li>
				<li>Click the <strong>Insert New Parameter</strong> button and create a parameter called <strong>pkt</strong>. 
Set the <strong>type</strong> for the new parameter to <strong>CF::OctetSequence</strong> and set the <strong>direction</strong> 
to <strong>in</strong>.</li>
				<li>Repeat the above for <strong>OpenData</strong>. Create an <strong>operation</strong> called <strong>pushOpenData</strong>
				</li>
				<li> Create a parameter of type <strong>CF::OctetSequence</strong> called <strong>pkt</strong>.</li>
				<li>Repeat the above for <strong>ProcessedData</strong>. Create an <strong>operation</strong> called <strong>pushProcessedData</strong>
and create a parameter of type <strong>CF::OctetSequence</strong> called <strong>pkt</strong>.</li>
				<li>In the <strong>Project Explorer</strong>, right-click on <strong>DataFile</strong> and from the popup menu, select 
<strong>CX Generate</strong> &gt; <strong>Generate IDL</strong>. </li>
				<br>A file <strong>CXTutorial_Model_src/idl/DataFile.idl</strong> is generated and displayed in the <strong>Project Explorer</strong>. Also, because <strong>DataFile.idl</strong> includes <strong>CF.idl</strong> which in turn includes <strong>PortTypes.idl</strong>, these two additional IDL files are also generated.</br>
			</ol>
			<p>Note that the new <strong>CXTutorial_Model_src</strong> project has an error. This can be safely ignored for now. It occurs because the project is created as a CDT project but it does not yet contain a makefile. When we generate code later, a makefile will also be generated which will solve this error.</p>
			<h2>Create a port type</h2>
			<p>The port type defines how the interface is used as a port. The port realizes all interfaces that the port type 
realizes and uses all the interfaces that the port type uses. In the SCA, a port type can only realize or use one interface and is unidirectional.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, right-click the <strong>Communication</strong> package
 and choose <strong>Add CX</strong> &gt; <strong>PortType</strong>.</li>
				<li>In the <strong>Name</strong> field, type <strong>EncryptedData</strong>.</li>
				<br>Use the default <strong>Inverse Name</strong>.</br>
				<li>Select the <strong>EncryptedData</strong> Interface.</li>
				<li>Click <strong>Finish</strong>.</li>
				<li>Create two more port types named <strong>OpenData</strong> and <strong>ProcessedData</strong>. 
Select the appropriate interface for each one.</li>
			</ol>
			<p>The new port type and the inverse port type are added to the Project Explorer in the <strong>Communication</strong> package. </p>
			<h2>Create ports</h2>
			<p>Ports isolate a component from its environment and its environment from the component. Each port has one interface. Each port has a 
direction: provides or uses. CX uses UML 2.0 notation to indicate the port interface direction. The interface's direction is 
called its conjugation. SCA ports are unidirectional and support a single interface.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, open the <strong>Decryptor</strong> diagram you created with the Component Wizard.</li>
				<br>This diagram is in the <strong>CXTutorial_Model::TutorialApplication::Decryptor</strong> package.</br>
				<br>The component, component interface and implementation are displayed.</br>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Application</strong> drawer.</li>
				<li>Select <strong>Port</strong> and drop the port onto the <strong>Component Interface</strong>.</li>
				<li>From the pop-up menu, select <strong>Select Existing Element</strong>.</li>
				<li>Click <strong>Search</strong> and type <strong>EncryptedData</strong>.</li>
				<li>Select the <strong>&lt;&lt;PortType&gt;&gt; EncryptedData</strong>  and click <strong>OK</strong>.</li>
				<li>Name the port <strong>dataIn</strong>.</li>
				<br>When naming a port, ensure the name indicates: how the component uses the environment (uses port) and how the environment uses the component (provides port).
		The key to successful use of ports is to name from the viewpoint of the component.</br>
				<li>With the <strong>dataIn</strong> port selected, goto the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.</li>
				<li>In the <strong>Kind</strong> field, click the Edit Kind.</li>
				<li>In the <strong>Properties</strong> window, click <strong>Add New Kind</strong>.</li>
				<li>Click in the <strong>Value</strong> field and from the drop-down list, select <strong>0-data</strong> and click <strong>Close</strong>.</li>
				<li>Create a uses port on the <strong>Decryptor</strong> component interface. Select <strong>&lt;&lt;PortType&gt;&gt; OpenDataInv</strong>
		and name the port <strong>dataOut</strong>. Set the <strong>Kind</strong> to <strong>Data</strong>.</li>
				<li>In the <strong>Project Explorer</strong>, open the <strong>Filter</strong> diagram you created with the Component Wizard.</li>
				<br>This diagram is in the <strong>CXTutorial_Model::TutorialApplication::Filter</strong> package.</br>
				<li>Create a provides port on <strong>Filter</strong> component interface. Select <strong>&lt;&lt;PortType&gt;&gt; OpenData</strong>
and name the port <strong>dataIn</strong>. Set the <strong>Kind</strong> to <strong>Data</strong>.</li>
				<li>Create a uses port on the <strong>Filter</strong> component interface. Select <strong>&lt;&lt;PortType&gt;&gt; ProcessedDataInv</strong>
and name the port <strong>dataOut</strong>. Set the <strong>Kind</strong> to <strong>0-data</strong>.</li>
			</ol>
			<h2>Create an application</h2>
			<p>An application is a set of components in a communicating architecture.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select the <strong>TutorialApplication</strong> package and
 from the right-click menu choose <strong>Add Diagram</strong> &gt; <strong>CX
Component Diagram</strong>.</li>
				<li>Name the diagram, <strong>ApplicationDiagram</strong>.</li>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Application</strong> drawer.</li>
				<li>Select <strong>Application</strong> and drop the element on the CX Component Diagram.</li>
				<li>Name the application <strong>TutorialApplication</strong>.</li>
				<li>Select the application border and drag to resize the application to fill the whitespace.</li>
				<li>In the <strong>Project Explorer</strong>, select the <strong>TutorialApplication::Decryptor::Decryptor</strong> component structural realization
 you created and drag it onto the application. </li>
				<li>In the <strong>Project Explorer</strong>, select the <strong>TutorialApplication::Filter::Filter</strong> component structure realization you created and 
 drag it onto the application. </li>
				<li>Resize the components and position them evenly on the application.</li>
			</ol>
			<h2>Create connections</h2>
			<p>Connections are used to show which elements communicate with each other. Uses ports connect to provides ports (or supports interface). 
Connectors can also be used with external ports. In this case, a uses port is connected to a uses port and a provides port is connected to a 
provides port.</p>
			<p>When creating connections, keep in mind that all the elements and labels in the CX Component Diagram can be moved and resized. Additionally,
you can control the font type, size and color to make the diagram more visually dynamic.</p>
			<ol>
				<li>Open the <strong>ApplicationDiagram</strong>.</li>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Application</strong> drawer and select <strong>Connector</strong>.</li>
				<li>Draw a connection from <strong>Decryptor dataOut port</strong> to <strong>Filter dataIn port</strong>.</li>
				<li>Delete the connector name. </li>
			</ol>
			<h2>Application port development</h2>
			<p>Applications can have external ports. These are created on the application's border using the same procedure as when creating internal ports. </p>
			<ol>
				<li>Create a port on <strong>TutorialApplication</strong> based on an existing element.</li>
				<li>Search for <strong>ProcesssedData</strong> and select <strong>&lt;&lt;PortType&gt;&gt; ProcessedDataInv</strong>. 
Name the port, <strong>dataOut</strong>. The port is displayed on the border of TutorialApplication.</li>
				<li>Draw a connection from the <strong>Filter dataOut port</strong> to the <strong>TutorialApplication dataOut port</strong>.</li>
				<li>Delete the connector name.</li>
			</ol>
			<h2>Save project and model</h2>
			<p>On the toolbar, click the <strong>Save</strong> icon.</p>
			<h2>Tutorial Summary</h2>
			<p>In this tutorial you became familiar with the CX user interface, created some basic elements, learned about components, 
ports, port types, applications and connectors, and saw how the
versatility of CX enables you to manage and develop large applications.</p>
			<p>In Tutorial 2: Developing the Model, you will learn about:</p>
			<ul>
				<li>validation</li>
				<li>property types</li>
				<li>definitions, implementations, and instances</li>
				<li>freestanding ports</li>
			</ul>
		</helpTopic>
		<!--Tutorial 2-->
		<helpTopic outputFile="tutorial_2.html" title="Tutorial 2: Developing the Model">
			<h1>Tutorial 2: Developing the Model</h1>
			<p>This tutorial builds on the elements you created and lessons learned in <a href="tutorial1.html">Tutorial 1: Learning the Basics</a>.</p>
			<p>In this tutorial you will complete some more advanced procedures that will teach you about:</p>
			<ul>
				<li>validation</li>
				<li>property types</li>
				<li>definitions, implementations, and instances</li>
				<li>freestanding ports</li>
			</ul>
			<h2>Open the project and model</h2>
			<p>In <a href="tutorial1.html">Tutorial 1: Learning the Basics</a> you created the base elements of your model. You created:</p>
			<ul>
				<li>IDL</li>
				<li>port types</li>
				<li>ports</li>
				<li>components and their associated elements</li>
				<li>an application</li>
				<li>connectors</li>
				<li>defined SCA and UML properties</li>
			</ul>
			<p>In the <strong>Project Explorer</strong> expand the CXTutorial project and CX Tutorial model you created in <a href="tutorial1.html">Tutorial 1: Learning the Basics</a>.</p>
			<h2>Run CX Validation</h2>
			
			<p>The validation process ensures that all SCA requirements are being met in your model, elements, or application.</p>
			<p>To validate the TutorialApplication, do the following:</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select <strong>TutorialApplication</strong>. Right-click and from the pop-up menu, select <strong>SCA Validation</strong>.</li>
				<br>The validation process will run and any errors, warnings, or informational messages are displayed in the Problems View.</br>
				<br>Four errors are returned by the validation process.</br>
			</ol>
			<p>The following errors are returned (and will be fixed later):</p>
			<ul>
				<li>TutorialApplication property controller is required but has no value.</li>
				<ul><li>This error is related to not having defined an assembly controller.</li></ul>
				<li>DecryptorImpl requires at least one os, processor, property dependency or resource dependency.</li>
				<ul><li>This error indicates that further modeling is required on the DecryptorImpl element.</li></ul>
				<li>FilterImplImpl requires at least one os, processor, property dependency or resource dependency.</li>
				<ul><li>This error indicates that further modeling is required on the FilterImpl element.</li></ul>
			</ul>
			<p>In addition to the these four errors, produced by the model validation process, the following error can also be seen. This error can be ignored. CX is looking for a makefile to build source. Because we have not generated source and its makefiles this error appears.</p>
			<ul>
				<li>no rule to make target 'all'</li>
			</ul>
			<h2>Create an assembly controller</h2>
			<p>One of the errors returned by validation indicated that an assembly controller is missing. The SCA requires that an assembly controller be identified. 
Any component instance in your model can be the assembly controller. To resolve this error, you will create a new component and then designate it
as the assembly controller.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select the <strong>TutorialApplication</strong> package that you created in Tutorial 1.</li>
				<li>Right-click on the element and select <strong>Add CX</strong> &gt; <strong>Component</strong>.</li>
				<li>In the Component Wizard, name the component <strong>AssemblyController</strong> and in the <strong>Type</strong>
drop-down list, select <strong>Resource</strong>. </li>
				<li>Click <strong>Finish</strong>.</li>
				<li>Open the <strong>AssemblyController</strong> diagram and add two uses ports to the component interface.
The ports should be of type <strong>&lt;&lt;PortType&gt;&gt; ResourceInv</strong> and be named <strong>decryptCtrl</strong> and 
<strong>filterCtrl</strong>. In the <strong>Properties View SCA Tab</strong> set the <strong>kind</strong> to <strong>Control</strong> on both ports.</li>
				<li>In the <strong>Project Explorer</strong>, open the <strong>ApplicationDiagram</strong> diagram.</li>
				<li>In the <strong>Project Explorer</strong>, select <strong>AssemblyController</strong> structural realization
 and drag it onto <strong>TutorialApplication</strong>.</li>
				<li>In the <strong>Palette</strong>, select the <strong>Connector</strong> and connect the <strong>AssemblyController</strong> ports
				 to the <strong>decryptor</strong> and <strong>filter</strong>. Note these connections should be made directly to the components, not their ports. Leave the connection names empty. </li>
				<li>With the <strong>TutorialApplication</strong> selected, click the <strong>SCA</strong> tab in the <strong>Properties View</strong>.</li>
				<li>In the <strong>controller</strong> field, click the edit button.</li>
				<li>Choose the <strong>assemblyController</strong> part which is part of TutorialApplication, and click <strong>OK</strong>. </li>
				<p>This identifies the component as the assembly controller for the application.</p>
			</ol>
			<h2>Run validation</h2>
			<p>To ensure that the error regarding the assembly controller, discovered in the earlier validation process, are fixed, validate the 
TutorialApplication again. You should now see the following errors (which will be fixed later):</p>
			<ul>
				<li>AssemblyControllerImpl requires at least one os, processor, property dependency or resource dependency.</li>
				<li>DecryptorImpl requires at least one os, processor, property dependency or resource dependency.</li>
				<li>FilterImplImpl requires at least one os, processor, property dependency or resource dependency.</li>
				<li>no rule to make target 'all'</li>
			</ul>
			<h2>Property type creation</h2>
			<p>Property types are essentially elements that can be re-used multiple times. Property types are used to define the elements in your model. 
There are a number of property types:</p>
			<ul>
				<li>Enumeration Property Type</li>
				<li>Primitive Property Type</li>
				<li>Struct Property Type </li>
				<li>Struct Sequence Property Type</li>
				<li>Test Property Type</li>
			</ul>
			<p>In the SCA, a property has a name and this property has the potential to be re-used across multiple devices and/or components. 
		For example, MAX_THROUGHPUT or DECRYPT_KEY can be created and make the re-use of properties simpler and more convenient.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, right-click your <strong>CXTutorial_Model</strong> model and select <strong>Add CX</strong> &gt; <strong>Package</strong>.</li>
				<li>Name the package <strong>SCAProperties</strong>.</li>
				<li>Right-click <strong>SCAProperties</strong> and select <strong>Add Diagram</strong> &gt; <strong>CX Component Diagram</strong>.</li>
				<li>Name the diagram <strong>SCAPropertiesDiagram</strong>.</li>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Application</strong> drawer.</li>
				<li>In the <strong>Property Types</strong> drop-down list, select <strong>Primitive Property Type</strong>.</li>
				<li>Drop this element onto the CX Component Diagram.</li>
				<li>Name the property <strong>Key</strong>.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.</li>
				<li>Set the following attributes: </li>
				<ul>
					<li>Action: External</li>
					<li>Kind: Configure And Exec</li>
					<li>Type: String</li>
				</ul>
				<li>Save the model.</li>
			</ol>
			<p>This property is now available to be applied to model elements.</p>
			<h2>User-defined SCA property creation</h2>
			<p>Each component interface, component, instance or implementation can have several properties. Properties are used to provide
extra information about the element they are associated with.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, open the <strong>Decryptor</strong> diagram. This is the diagram you created earlier with Component Wizard.</li>
				<li>In the <strong>CX Component Diagram</strong>, select the <strong>Decryptor</strong>.</li>
				<li>Right-click on <strong>Decryptor</strong> and from the pop-up menu, select <strong>Add CX</strong> &gt; <strong>SCA Property</strong>.</li>
				<li>Name the attribute <strong>DECRYPT_KEY</strong>.</li>
				<li>Select the <strong>DECRYPT_KEY</strong> attribute and in the <strong>Properties View</strong> &gt; <strong>SCA</strong>
 tab.</li>
				<li>Click the <strong>Select Type</strong> button and choose the <strong>Key</strong> primitive property you created earlier.</li>
				<li>Set the <strong>Value</strong> to <strong>abc123</strong>.</li>
			</ol>
			<h2>Components and Devices: Definitions, Implementations, and Instances</h2>
			<p>A component or device's definition is its external interfaces and ports. A component or device's monolithic implementation is an 
implementation of the component's definition. This is usually associated with source code or an executable. Instances of either a 
component or device definition are added to an application or node. All definitions used must have at least one implementation.</p>
			<p>Each definition needs one or more implementations.</p>
			<h2>Define monolithic implementation dependencies</h2>
			<p>The operating system and processor dependencies define which operating environment the component implementation needs to run or be loaded in.</p>
			<ol>
				<li>In <strong>CXTutorial_Model</strong>, create a package named <strong>SCADependencies</strong>, add a 
<strong>CX Component Diagram</strong> and name it <strong>Dependencies</strong>. Open this diagram.</li>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Application</strong> drawer.</li>
				<li>Select <strong>Operating System</strong> and drop this onto the <strong>Dependencies</strong> diagram.
 Name this element <strong>Linux</strong>.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab and set the <strong>Version</strong> to <strong>2.6</strong>. The Version should match the os_version
			allocation property set on the device to which this component will be deployed.</li>
				<li>In the <strong>Palette</strong> select <strong>Processor</strong> and drop this onto the diagram. Name the element <strong>x86</strong>.</li>
			</ol>
			<p>For each Component in your model, do the following:</p>
			<ol>
				<li>Open the component's associated <strong>CX Component Diagram</strong>.</li>
				<li>Drag the <strong>Linux</strong> and <strong>x86</strong> elements from the <strong>SCADependencies</strong> package onto the diagram.</li>
				<li>In the <strong>Palette</strong>, select <strong>OS Link</strong> and connect the <strong>implementation</strong> to <strong>Linux</strong>. </li>
				<li>In the <strong>Palette</strong>, select <strong>Processor Link</strong> and connect the <strong>implementation</strong> to <strong>x86</strong>. </li>
			</ol>
			<h2>Create a DeviceThatLoadedThisComponentRef (DTLTCR) Freestanding Port</h2>
			<p>A freestanding port (FSP) models how to find a port or a service during run-time. A supports interface, uses or 
provides port can be designated as a freestanding port.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, open the <strong>ApplicationDiagram</strong> diagram. </li>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Application</strong> drawer. </li>
				<li>Select <strong>FSP Device That Loaded</strong> and drop this element onto the <strong>application structure</strong>.</li>
				<li>Select <strong>Existing Element</strong> and search for the <strong>Port Type (EncryptedData)</strong> you created in Tutorial 1.</li>
				<li>Select <strong>&lt;&lt;PortType&gt;&gt; EncryptedDataInv</strong> and click <strong>OK</strong>. </li>
				<li>Name the port <strong>dataSource</strong>.</li>
				<li>Select the <strong>FSP</strong> and in the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.</li>
				<li>Set the <strong>part</strong> property  to <strong>decryptor</strong> in the TutorialApplication.</li>
				<li>Set the <strong>Findby Port Name</strong> property to <strong>dataSource</strong>. This is the name of the port to connect to on the platform.</li>
				<li>In the <strong>Palette</strong>, select the <strong>Connector</strong> and connect the <strong>decryptor's dataIn port</strong>
 to the <strong>dataSource FSP</strong>.</li>
				<li>Right-click on the <strong>dataSource FSP</strong> and select <strong>Add Note</strong>. 
Type: <strong>DTLTCR for Device That Loaded This Component Ref</strong>. Resize and move the note as necessary.</li>
			</ol>
			<h2>Validate the Tutorial Application</h2>
			<p>Select the TutorialApplication and validate again. The application should validate with no errors. Validating the application, also validates other components and elements that are used in the definition of the application. </p>
			<h2>Tutorial Summary</h2>
			<p>In this tutorial you built on the model and elements you defined in Tutorial 1: Learning the Basics.</p>
			<p>You saw how the CX validation process works, learned how to find and fix errors in your application, learned about elements such as: assembly controllers, property types, 
implementation artifacts, and freestanding ports.</p>
			<p>The following images illustrate what your application and model should look like in <pn>ProductName</pn>:</p>
			<p>
				<img src="../images/tutorial2_application.gif" border="0" alt="TutorialApplication"></img>
			</p>
			<p>
				<img src="../images/tutorial2_pe.gif" border="0" alt="Project Explorer"></img>
			</p>
			<p>In Tutorial 3: Platform Development, you will learn about: </p>
			<ul>
				<li>device</li>
				<li>allocation properties</li>
				<li>nodes</li>
				<li>device and domain manager</li>
			</ul>
		</helpTopic>
		<!--Tutorial 3-->
		<helpTopic outputFile="tutorial_3.html" title="Tutorial 3: Platform Development">
			<h1>Tutorial 3: Platform Development</h1>
			<p>This tutorial builds on <a href="tutorial1.html">Tutorial 1</a> and <a href="tutorial_2.html">Tutorial 2</a>. In this tutorial, you will
learn some more advanced skills and concepts. You will learn about:</p>
			<ul>
				<li>devices</li>
				<li>allocation properties</li>
				<li>nodes</li>
				<li>device managers</li>
				<li>domain managers</li>
			</ul>
			<p>This tutorial assumes you have completed <a href="tutorial1.html">Tutorial 1</a> and <a href="tutorial_2.html">Tutorial 2</a>.</p>
			<h2>Open the project and model</h2>
			<p>In <a href="tutorial2.html">Tutorial 2</a> you created the following elements:</p>
			<ul>
				<li>an assembly controller</li>
				<li>property types and SCA attributes</li>
				<li>a monolithic implementation</li>
				<li>monolithic implementation dependencies</li>
				<li>a freestanding port</li>
			</ul>
			<p>In the <strong>Project Explorer</strong> expand the project and model you developed <a href="tutorial1.html">Tutorial 2</a>.</p>
			<h2>Create a device</h2>
			<p>The platform is divided into: devices, nodes, and platforms.</p>
			<p>A device is an abstract software representation of a physical hardware element. Devices are the software view of the hardware element. These elements, 
allow a platform independent SCA model to include the platform view. Devices are very similar to components - you must configure the device's interfaces and ports.</p>
			<ol>
				<li>In the Project Explorer, select <strong>CXTutorial_Model</strong> and create a new package called <strong>Platform</strong>.</li>
				<li>Right click on the <strong>Platform</strong> package and from the popup menu, select <strong>Add CX</strong> &gt; <strong>Component</strong>.</li>
				<li>Name the device <strong>Modem</strong> and set the <strong>Type</strong> to <strong>ExecutableDevice</strong>. Click <strong>Finish</strong>.</li>
				<li>Add <strong>processor</strong> and <strong>OS dependencies</strong> from the <strong>SCADependencies diagram</strong> to the 
<strong>Modem</strong> diagram. Using the <strong>Palette</strong>, draw <strong>OS</strong> and <strong>Processor</strong> links.</li>
				<li>Validate the <strong>Modem</strong> package and correct any errors.</li>
			</ol>
			<h2>Create ports on the device interface</h2>
			<p>This is done the same way as you did on the component interface. You will reuse the portTypes you created when adding ports to component interfaces.</p>
			<ol>
				<li>Open the <strong>Modem</strong> diagram.</li>
				<li>In the <strong>Palette</strong>, select <strong>Port</strong> and drop it onto the <strong>ModemInterface</strong> component interface.</li>
				<li>From the menu, select <strong>Existing Element</strong> and search for <strong>EncryptedDataInv</strong>. Select 
<strong>&lt;&lt;PortType&gt;&gt; EncryptedDataInv</strong> and name the port <strong>dataSource</strong>.</li>
				<li>Select the <strong>dataSource</strong> port and in the <strong>Properties View</strong> &gt; <strong>SCA</strong>
 tab and set <strong>kind</strong> to <strong>data</strong>. </li>
			</ol>
			<h2>Define Executable Device SCA properties</h2>
			<p>This is similar to defining the SCA properties on a component. An executable device has two properties: os_name and processor_name.</p>
			<ol>
				<li>Open <strong>Modem</strong> diagram.</li>
				<li>Right click on the <strong>Modem</strong> structure realization and from the popup menu, select <strong>Add CX</strong> &gt; 
<strong>SCA Property</strong>.
Name the property <strong>os_name</strong>.</li>
				<li>Select <strong>os_name</strong> and in the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.</li>
				<li>Click <strong>Edit Type</strong> and choose <strong>os_name</strong>. Set the <strong>Value</strong> to <strong>Linux</strong>.</li>
				<li>Right click on the <strong>Modem</strong> structure realization and select <strong>Add CX</strong> &gt; <strong>SCA Property</strong>. 
Name the property <strong>processor_name</strong>.</li>
				<li>Select <strong>processor_name</strong> and in the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.</li>
				<li>Click <strong>Edit Type</strong> and choose <strong>processor_name</strong>. Set the <strong>Value</strong> to <strong>x86</strong>.</li>
				<li>Save the model.</li>
			</ol>
			<h2>Define allocation properties</h2>
			<p>Allocation properties can be used to specify services from the device. For example, using allocation properties, you can define processing 
power and throughput for the device. When you define allocation properties, you have to set the action property: when set to external, this 
implies that the device manages the capacity using allocateCapacity and deallocateCapacity; any other setting indicates that the Core Framework 
manages the capacity. </p>
			<p>SCA properties in CX are elements and as such can be reused. </p>
			<h2>Create SCAPrimitives</h2>
			<ol>
				<li>In the Project Explorer open <strong>CXTutorial_Model</strong> &gt; <strong>SCAProperties</strong> &gt; <strong>SCAPropertiesDiagram</strong>. </li>
				<li>In the <strong>Palette</strong>, select <strong>Primitive Property Type</strong> and drop this element onto the diagram.</li>
				<li>Name the element <strong>KIPS</strong>. In the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.</li>
				<li>Set the following properties:</li>
				<ul>
					<li>
						<strong>Kind</strong> to <strong>Allocation</strong>
					</li>
					<li>
						<strong>Type</strong> to <strong>Ulong</strong>
					</li>
					<li>
						<strong>Action</strong> to <strong>Greater than or Equal</strong>
					</li>
				</ul>
				<li>Repeat this process for a second SCAPrimitive named <strong>Throughput</strong>. Set the following properties, for this
element:</li>
				<ul>
					<li>
						<strong>Kind</strong> to <strong>Allocation</strong>
					</li>
					<li>
						<strong>Type</strong> to <strong>Ulong</strong>
					</li>
					<li>
						<strong>Action</strong> to <strong>Greater than or Equal</strong>
					</li>
				</ul>
			</ol>
			<h2>Create SCA Properties and assign them</h2>
			<p>In this section you will create SCA properties for the <strong>Modem</strong> and then assign them to the SCAPrimitives you created and defined 
above.</p>
			<ol>
				<li>Open <strong>Modem</strong> diagram.</li>
				<li>Right click on <strong>Modem structure realization</strong> and from the popup menu, select <strong>Add CX</strong> &gt; <strong>SCA Property</strong>.
Name the attribute <strong>KIPS</strong>.</li>
				<li>Select <strong>KIPS</strong> and in the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab. 
Click <strong>Select type</strong> and choose <strong>SCA Primitive KIPS</strong>. Set the <strong>Value</strong> to <strong>50</strong>.</li>
				<li>Right click on the <strong>Modem structure realization</strong> and select <strong>Add CX</strong> &gt; <strong>SCA Property</strong>. 
Name the property <strong>Throughput</strong>. </li>
				<li>Select <strong>Throughput</strong> and in the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab. 
Click <strong>Select type</strong> and choose <strong>SCA Primitive Throughput</strong>. Set the <strong>Value</strong> to <strong>100</strong>.</li>
			</ol>
			<h2>Validate the Modem Device</h2>
			<p>To ensure you have not introduced any errors, right click on <strong>Modem</strong>, on the diagram or in the Project Explorer, and select <strong>SCA Validate</strong>. Correct any errors.</p>
			<h2>Create a node</h2>
			<p>A node is made of the set of devices under the control of a single Device Manager component. A node can contain one or more 
devices and their connections. One of the devices in a node must be an executable device. </p>
			<p>The concept of a node is introduced by CX. The SCA equivalent of a node is the DCD.</p>
			<ol>
				<li>Create a new package under the <strong>Platform</strong> package and name it <strong>DecryptorNode</strong>.</li>
				<li>Create a diagram in the <strong>DecryptorNode</strong> package called <strong>DecryptorNode</strong>.</li>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Platform</strong> drawer.</li>
				<li>Select the <strong>Node</strong> element and drop it on the diagram you created.</li>
				<li>Name the element <strong>DecryptorNode</strong>.</li>
				<li>Resize the node to make it large enough to contain the device.</li>
				<li>In the <strong>Project Explorer</strong> select <strong>Modem structural realization</strong> and drag it onto 
<strong>DecryptorNode</strong>.</li>
				<br>This creates a device instance on the node.</br>
				<li>Resize and move the device instance as required.</li>
			</ol>
			<p>Next you need to define a Device Manager, Domain Manager, File Manager, and Log for the node.</p>
			<h2>Core Framework elements</h2>
			<p>The SCA defines Core Framework elements that provide services to the application and platform:</p>
			<ul>
				<li>Domain Manager</li>
				<li>Device Manager</li>
				<li>File Manager</li>
				<li>Log</li>
			</ul>
			<p>These elements need to be configured on the node. Each node requires a Device Manager and the entire platform requires one Domain 
Manager. The File Manager and Log elements are optional.</p>
			<p>These Core Framework elements are similar to components and devices - they have attributes and implementations.</p>
			<h2>Create a Device Manager</h2>
			<ol>
				<li>In the Project Explorer, right click on the <strong>Platform</strong> package and from the popup menu, select <strong>Add CX</strong>
 &gt; <strong>Component</strong>.</li>
				<li>Name it, <strong>DeviceManager</strong> and set the <strong>Type</strong> to <strong>DeviceManager</strong>. Click
<strong>Finish</strong>.</li>
				<li>Add <strong>processor</strong> and <strong>OS</strong> dependencies from the <strong>SCADependencies</strong> diagram to the 
<strong>DeviceManager</strong> diagram. Using the <strong>Palette</strong>, create <strong>OS</strong> and <strong>Processor</strong> links.</li>
				<li>Validate <strong>DeviceManager</strong> and correct any errors.</li>
			</ol>
			<h2>Create a Domain Manager</h2>
			<ol>
				<li>In the Project Explorer, right click on the <strong>Platform</strong> package and from the popup menu, select <strong>Add CX</strong> &gt;
<strong>Component</strong>. </li>
				<li>Name the CF element <strong>DomainManager</strong> and set the <strong>Type</strong> to <strong>DomainManager</strong>. Click <strong>Finish</strong>.</li>
				<li>Add <strong>Processor</strong> and <strong>OS</strong> dependencies from the <strong>SCADependencies</strong>
 diagram to the <strong>DomainManager</strong> diagram. Using the <strong>Palette</strong>, create <strong>OS</strong> and <strong>Processor</strong> links.</li>
				<li>Validate <strong>DomainManager</strong> and correct any errors.</li>
			</ol>
			<p>Next you must define the Domain Manager Descriptor for this Domain Manager. The Domain Manager Descriptor describes the services the Domain 
Manager connects to during startup. </p>
			<ol>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Platform</strong> drawer.</li>
				<li>Select the <strong>Domain</strong> element and drop it onto the <strong>DomainManager</strong> diagram you have been using. </li>
				<li>Change the name to <strong>myDomain</strong>. </li>
				<li>In the <strong>Palette</strong>, select the <strong>Domain Dependency</strong> and link from <strong>myDomain</strong> to 
				<strong>DomainManager</strong>. You can delete the label from this association if you want to.</li>
				<li>In the <strong>Palette</strong>, select the <strong>DMD Service</strong> and drop this element onto the diagram.</li>
				<li>Name this element <strong>LogService</strong>.</li>
				<li>In the <strong>Palette</strong>, select the <strong>DMD Service Link</strong> and link from <strong>myDomain</strong> 
to <strong>LogService</strong>.</li>
				<li>In the diagram, select <strong>LogService</strong>.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab and configure the following mandatory properties: </li>
				<ul>
					<li>
						<strong>FindBy Name</strong> to <strong>domainLog</strong>
					</li>
					<li>
						<strong>FindBy Type</strong> to <strong>DomainFinder_Log</strong>
					</li>
					<li>
						<strong>Uses Identifier</strong> to <strong>log</strong>
					</li>
				</ul>
				<li>Save the model. </li>
			</ol>
			<h2>Create a Log Service</h2>
			<ol>
				<li>In the Project Explorer, right click on the <strong>Platform</strong> package and from the popup menu, select <strong>Add CX</strong> &gt;
 <strong>Component</strong>.</li>
				<li>Name the service <strong>DomainLog</strong> and set the <strong>Type</strong> to <strong>Log</strong>. Click <strong>Finish</strong>.</li>
				<li>Add <strong>processor</strong> and <strong>OS</strong> dependencies from the <strong>SCADependencies</strong> diagram to the 
<strong>DomainLog</strong> diagram. Using the Palette, draw <strong>OS</strong> and <strong>Processor</strong> links.</li>
				<li>Validate <strong>DomainLog</strong> and correct any errors.</li>
			</ol>
			<h2>Add Core Framework elements to the node</h2>
			<p>Now that you have created the elements and requirements of the node, you must now add them to the node.</p>
			<ol>
				<li>In the Project Explorer, select the <strong>DomainManager</strong> structure realization and drag it onto the <strong>DecryptorNode</strong> diagram.</li>
				<li>Repeat for the <strong>Device Manager</strong>.</li>
				<li>Repeat for the <strong>DomainLog</strong>. </li>
				<li>Resize and move the <strong>DecryptorNode</strong> parts as desired.</li>
			</ol>
			<h2>Configure the node</h2>
			<p>The node has attributes that need to be defined. CX automatically determines the Device Manager for the node and updates appropriately. Using the namingservice 
property, you need to define the Domain Manager.</p>
			<ol>
				<li>Open the <strong>DecryptorNode</strong> diagram.</li>
				<li>Select <strong>DecryptorNode</strong>.</li>
				<li>In the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.</li>
				<li>Configure the <strong>Naming Service</strong> property to be the <strong>myDomain/DomainManager</strong>. This tells the Node how to find the 
DomainManager in the NamingService.</li>
				<li>Save the model.</li>
			</ol>
			<h2>Validate the node</h2>
			<p>Validation will ensure that you haven't missed anything or introduced any errors to the node.</p>
			<ol>
				<li>In <strong>Project Explorer</strong>, select the <strong>DecryptorNode</strong> and from the right-click menu select <strong>SCA Validation</strong>.</li>
				<li>If errors are returned, navigate to the error source and debug.</li>
			</ol>
			<h2>Define the platform</h2>
			<p>A platform is a set of nodes under the control of a single domain manager. A platform can contain one or more nodes,</p>
			<p>A platform is a modeling entity introduced by  CX. The SCA equivalent of the platform is the entire set of DCDs that comprise the 
Domain.</p>
			<ol>
				<li>Create a new diagram under the <strong>Platform</strong> package and name it <strong>Platform</strong>.</li>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Platform</strong> drawer.</li>
				<li>Select the <strong>Platform</strong> element and drop it onto the diagram.</li>
				<li>Name the element <strong>CommunicatorPlatform</strong>.</li>
				<li>Resize the element so it will hold the node.</li>
				<li>In the <strong>Project Explorer</strong>, select the <strong>DecryptorNode</strong> you created and drag it onto the <strong>CommunicatorPlatform</strong>.</li>
				<li>Validate <strong>CommunicatorPlatform</strong> and correct any errors.</li>
				<li>Validate the <strong>Platform</strong> package and correct any errors.</li>
				<li>Save your model.</li>
			</ol>
			<h2>Tutorial Summary</h2>
			<p>In this tutorial you learned about the next step of model driven development: platform definition and creation. You became familiar with the elements in the 
SCA Platform drawer and learned more about defining dependencies and attributes. As well you saw how you can re-use elements multiple times.</p>
			<p>In the Tutorial 4: Finalizing the Model, you will learn about dependencies and freestanding ports.</p>
			<p>The following images illustrate what your application and model should look like in <pn>ProductName</pn>:</p>
			<p>
				<img src="../images/tutorial3_pe.gif" border="0" alt="Project Explorer"></img>
			</p>
			<p>
				<img src="../images/tutorial3_decryptor.gif" border="0" alt="Decryptor Node"></img>
			</p>
			<p>
				<img src="../images/tutorial3_communicator.gif" border="0" alt="Communicator Platform"></img>
			</p>
		</helpTopic>
		<!--Tutorial 4-->
		<helpTopic outputFile="tutorial4.html" title="Tutorial 4: Finalizing the Model">
			<h1>Tutorial 4: Finalizing the Model</h1>
			<p>In this tutorial, you will complete the final phase of modeling, you will:</p>
			<ul>
				<li>learn about dependencies</li>
				<li>create findBy freestanding ports</li>
				<li>validate the entire model</li>
			</ul>
			<p>This tutorial assumes you have completed <a href="tutorial1.html">Tutorial 1</a>, <a href="tutorial_2.html">Tutorial 2</a>, and <a href="tutorial_3.html">Tutorial 3</a>.</p>
			<h2>Open the project and model</h2>
			<p>In <a href="tutorial_3.html">Tutorial 3</a> you created the following elements:</p>
			<ul>
				<li>devices</li>
				<li>defined SCA properties</li>
				<li>Core Framework elements</li>
				<li>node and platform</li>
			</ul>
			<p>In the <strong>Project Explorer</strong> expand the project and model you defined in <a href="tutorial_3.html">Tutorial 3</a>.</p>
			<h2>Add a PropertyReference Dependency</h2>
			<p>A property reference dependency expresses a need from an implementation to an allocation property. To be defined correctly, the property 
must be an allocation property.</p>
			<ol>
				<li>Open the <strong>CXTutorial_Model::TutorialApplication::Filter::Filter</strong> diagram.</li>
				<li>In <strong>Project Explorer</strong> expand the <strong>SCAProperties</strong> package.</li>
				<li>Drag the <strong>KIPS SCA Primitive property</strong> onto the <strong>Filter</strong> diagram.</li>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Application</strong> drawer and select <strong>Property Dependency</strong>.</li>
				<li>Using the <strong>Property Dependency</strong>, draw a link from <strong>Filter_Impl</strong> to <strong>KIPS</strong>. Name the link 
<strong>needsKIPS</strong>.</li>
				<li>Select <strong>needsKIPS</strong> and in the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.
Set the value to 5 for this element. </li>
				<li>Validate the <strong>Filter</strong> package and correct any errors.</li>
				<li>Save the model. </li>
			</ol>
			<h2>Add a Software Package Reference Dependency</h2>
			<p>A software package reference dependency specifies a dependency to a Software Package (SPD). This element is typically used for 
libraries needed by components.</p>
			<p>The first step is to create the SoftPkg component:</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select the <strong>TutorialApplication</strong> package and create a package 
named <strong>CryptoLibImpl</strong>.</li>
				<li>Right click on <strong>CryptoLib</strong> and add a <strong>Component Diagram</strong> named <strong>CryptoLib</strong>.</li>
				<li>In the <strong>Palette</strong>, select <strong>Library</strong> and drop this element onto <strong>CryptoLib</strong>. 
Name the element <strong>CryptoLib</strong>.</li>
				<li>With <strong>CryptoLib</strong> selected, in the <strong>Properties View</strong> &gt; <strong>SCA</strong> 
tab and uncheck the <strong>SCA Compliant</strong> property.</li>
				<li>In the <strong>Palette</strong>, select <strong>Implementation Artifact</strong> and drop this element onto the diagram. 
Name this element <strong>CryptoLibImpl</strong>. </li>
				<li>Select <strong>CryptoLibImpl</strong> and in the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.
 Set <strong>Code &gt; File</strong> to <strong>cryptolib.so</strong> and <strong>Type</strong> to <strong>Shared Library</strong>.</li>
				<li>Use the <strong>Palette</strong> to draw a <strong>Component Implementation</strong> link from the <strong>CryptoLibImpl</strong>
 implementation to the <strong>CryptoLib</strong> component.</li>
				<li>From <strong>Project Explorer</strong> open the <strong>SCADependencies</strong> package, and add <strong>Linux</strong> and <strong>x86</strong>
 to the <strong>CryptoLib</strong> diagram.</li>
				<li>From the <strong>Palette</strong>, add <strong>OS</strong> and <strong>Processor</strong> links from <strong>CryptoLibImpl</strong>
 to <strong>Linux</strong> and <strong>x86</strong>.</li>
				<li>Validate the <strong>CryptoLib</strong> package and correct any errors.</li>
				<li>Save the model.</li>
			</ol>
			<p>The next step is to add a Resource Dependency:</p>
			<ol>
				<li>Open the <strong>Decryptor</strong> diagram.</li>
				<li>From the <strong>Project Explorer</strong> drag the <strong>CryptoLib structure realization</strong> onto <strong>Decryptor</strong>.</li>
				<li>From the <strong>SCA Application</strong> of the <strong>Palette</strong> drawer, select <strong>Resource Dependency</strong>
 and draw a link from the <strong>Decryptor_Impl</strong> to the <strong>CryptoLib</strong> library component. Name the link <strong>needsLibrary</strong>.</li>
				<li>In the <strong>Properties View</strong> with the <strong>Resource Dependency</strong> selected, select the <strong>SCA</strong> tab
and set the <strong>implementation</strong> property for the dependency to <strong>CryptoLibImpl</strong>. 
This allows you to specify the exact implementation of the library to be used. If this property is not defined, the Core Framework will select an
library implementation.</li>
				<li>Validate the <strong>Decryptor</strong> package and correct any errors.</li>
				<li>Save the model.</li>
			</ol>
			<h2>Uses Devices and Uses Devices Dependencies</h2>
			<p>The uses device relationship describes the requirement of something from a device. It shows that a component needs the device. This 
relationship can be used to configure connections. In this relationship, the source is a component or device definition or implementation and the 
target is an allocation property on a device definition or implementation. Additionally, a uses device can depend on more than 
one allocation property.</p>
			<ol>
				<li>Open the <strong>CXTutorial_Model::TutorialApplication::Decryptor::Decryptor</strong> diagram.</li>
				<li>In the <strong>Palette</strong>, expand the <strong>SCA Application</strong> drawer and select <strong>UsesDevice</strong>.
Drop this onto the <strong>Decryptor</strong> diagram and name the element <strong>RequiredThroughput</strong>.</li>
				<li>Select <strong>RequiredThroughput</strong> and in the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab.
Set <strong>type</strong> to <strong>Throughput</strong>.</li>
				<li>From <strong>SCA Application</strong> drawer, select <strong>UsesDevice Dependency</strong> and draw a link from the <strong>Decryptor</strong>
 component to the <strong>RequiredThroughput</strong> element. Name this element <strong>UsesThroughput</strong>.</li>
				<li>In <strong>Project Explorer</strong> expand the <strong>SCAProperties</strong> package. Drag the <strong>SCA Primitive property Throughput</strong>
 onto the <strong>Decryptor</strong> diagram.</li>
				<li>In the <strong>Palette</strong> select <strong>Property Dependency</strong> and draw a link from <strong>RequiredThroughput</strong> to the 
<strong>Throughput</strong> property. The label on this link is not used so you may delete it.</li>
				<li>Select the <strong>Property Dependency</strong> and in the <strong>Properties View</strong> &gt; <strong>SCA</strong> tab
 and set the <strong>value</strong> to <strong>10</strong>.</li>
				<li>Validate the <strong>Decryptor</strong> package and correct any errors.</li>
				<li>Save the model. </li>
			</ol>
			<h2>Validate the model</h2>
			<p>We will run validation here to catch any errors that may have been introduced during modeling.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong> select the top-level model element: <strong>CXTutorial_Model</strong>.</li>
				<li>Right-click and select <strong>SCA Validation</strong>.</li>
				<li>Fix any errors that are returned.</li>
				<li>Save your model.</li>
			</ol>
			<h2>Tutorial summary</h2>
			<p>In this tutorial you completed the final steps of modeling. Your application and model are fully-defined and ready for the next phase of COE - implementing.</p>
		</helpTopic>
		<!--Tutorial 5-->
		<helpTopic outputFile="tutorial5.html" title="Tutorial 5: Implementing">
			<h1>Tutorial 5: Implementing</h1>
			<p>Once your model has been created and validated, the next step is the implementation of your components and devices and the generation of 
descriptor files and source code. CX makes this possible with its powerful code and descriptor generation functionality.  </p>
			<p>The code and descriptor generation capabilities of CX leverage the complete configuration in the model to determine the optimal code 
	to generate for the applications and the communication between the connected elements. All of the information in the model is analyzed to 
	determine the most optimized way to generate the code.</p>
			<p>In this tutorial, you will:</p>
			<ul>
				<li>define code generation properties</li>
				<li>generate and browse the code</li>
				<li>generate SCA descriptors</li>
			</ul>
			<p>This tutorial assumes you have completed <a href="tutorial1.html">Tutorial 1</a>, <a href="tutorial_2.html">Tutorial 2</a>, <a href="tutorial_3.html">Tutorial 3</a>, 
and <a href="tutorial4.html">Tutorial 4</a>.</p>
			<p>In the <strong>Project Explorer</strong> expand the project and model you defined in <a href="tutorial4.html">Tutorial 4</a>.</p>
			<h2>Define the Build Configuration</h2>
			<p>CX generates the source code once for each component. The build configuration determines the build environment that will be generated 
and this determines how the source code is built. With CX you have the option to create a build configuration or use an existing configuration. 
In your model, a component can have one or more implementations; each of these implementations has a build configuration for a 
specific operating environment. Using the build configuration wizard, you specify General and SCA Domain build options. Each of 
these have Base and Local Values. The Base Values are read only. The Local Values can be overridden for each implementation.</p>
			<p>Before being able to use a Build Configuration in your model you must import one:</p>
			<ol>
				<li>In the <b>Project Explorer</b> select the <b>CXTutorial_Model</b> model.</li>
				<li>Right click and from the pop-up menu select <b>Import Model Library</b></li>
				<li>Select the <b>Deployed Library</b> checkbox.</li>
				<li>Choose the required build configuration from the drop down. For the sake of example, this tutorial will use the 
				<strong>eorb16-linux-gcc-x86</strong> Build Configuration.</li>
			</ol>
			<p>This will add a Package Import element into the model that will make the selected build configuration available for use in your model.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select the <strong>ModemImpl</strong> you created.</li>
				<li>Right-click and from the pop-up menu, select <strong>Build Configuration</strong>.</li>
				<li>Select <strong>General</strong> and from the <strong>Base Build Configuration</strong> drop-down list, select 
				the <strong>eorb16-linux-gcc-x86::eorb16-linux-gcc-x86-build</strong> Build Configuration.</li>
				<p>The base values for this build configuration are loaded and are read only. In this tutorial you will not edit the base values, but you could 
optionally select the <strong>Local Values</strong> tab to configure additional properties for Modem_Impl.</p>
				<li>Click <strong>OK</strong>.</li>
				<li>Repeat this for <strong>AssemblyControllerImpl</strong>, <strong>DecryptorImpl</strong>, 
				and <strong>FilterImpl</strong>, assigning the same Build Configuration to each one.</li>
				<li>Validate your model and correct any errors.</li>
				<li>Save the model.</li>
			</ol>
			<p>Note: for this tutorial it is assumed the CF elements and the CryptoLib binaries are provided to you. So you won't generate 
code for these elements.</p>
			<h2>Define the Make Location</h2>
			<p>If make is not in your path or you use a specific make, you need to specify the make location. The make location specifies 
location of the make application used to build applications. Note that this must be GNU Make version 3.81 or later to work correctly with 
the makefiles generated by <pn>productName</pn>.</p>
			<ol>
				<li>Open <strong>Window</strong> &gt; <strong>Preferences</strong> and expand <strong>
						<pn>productName</pn>
					</strong> &gt; <strong>Modeling</strong>.</li>
				<li>Enter the location of your GNU Make binary into the <strong>Make location</strong> field.</li>
				<li>Click <strong>OK</strong>.</li>
			</ol>
			<h2>Generate Code</h2>
			<p>The application/node determines which components/devices source code needs to be generated for.</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select and right-click <strong>TutorialApplication</strong>. From the pop-up menu, select 
<strong>CX Generate</strong> &gt; <strong>SCA Code</strong>. </li>
				<li>In the <strong>Project Explorer</strong> select and right-click <strong>CommunicatorPlatform</strong>. From the pop-up menu, select 
<strong>CX Generate</strong> &gt; <strong>SCA Code</strong>.</li>
			</ol>
			<h2>Browse Generated Code</h2>
			<p>The generated code is added to the Project Explorer in a folder structure that includes the functional, component, target specific, and port code. A new Project
is added to the Project Explorer for this tutorial called <strong>CXTutorial_Model_src</strong>. You can browse this source code in either the <pn>ProductName</pn> or C/C++ perspective.</p>
			<p>To browse the source code, simply navigate the generated source folder and open files and folders.</p>
			<p>The <strong>comps</strong> folder contains the source code for the components in the application.</p>
			<p>The <strong>devs</strong> folder contains the source code for the devices in the application.</p>
			<p>Under each component or device folder there is a worker folder. This contains the code that will hold your functional code.</p>
			<p>The <strong>framework</strong> folder contains generic code used by components, devices and ports.</p>
			<p>The <strong>ports</strong> folder contains the code for uses and provides ports.</p>
			<h2>Edit Worker Code</h2>
			<p>The Worker code is populated from CX and contains gaps where your functional code is inserted. Although you edit the 
			worker code using the CDT source code editor, on the actual source files, CX stores your functional code in the model 
			so that it can always regenerate those source files. Using CX, you can easily edit the Worker code and Worker 
			operations. Note that when you choose to edit any of the fragments of worker code, CX will first generate the source 
			code file to be edited. If the relevant source code file has not been generated previously, CX will generate it for you 
			before opening the CDT editor at the appropriate location in the file.</p>
			<p>Each location in the worker source files that can be edited by the user is marked by special pairs of comments. You 
			must enter your functional code between these marker comments so that CX can distinguish your code from generated code. 
			This enables CX to extract your functional code from these source files and store it in the model. This allows CX to 
			always regenerate the source code from the model. An example of these marker comments is shown below.</p>
			<pre>
	...
	#include "scxData_EncryptedDataPortHandler.h"
	#include "scxData_OpenDataUsesPort.h"

	/* CXGEN-USERREGION-BEGIN platform:/resource/CXTutorial/CXTutorial_Model.emx#_Mi1I0FjzEd-N4KNIfE9jyQ h_Source SCA::SCA_SoftwarePackage::SCAGeneratableComponent */
	<strong>YOUR CODE GOES HERE</strong>
	/* CXGEN-USERREGION-END */

	class scxDecryptorWorker : public scxData_EncryptedDataPortHandler
	{
		...
	</pre>
			<ol>
				<li>Ensure you are in the <strong>
						<pn>ProductName</pn>
					</strong> perspective.</li>
				<li>Open the <strong>Decryptor</strong> diagram and select <strong>Decryptor</strong>.</li>
			</ol>
			<p>To edit the Worker.h file:</p>
			<ol>
				<li>Right click <strong>Decryptor</strong> and select <strong>Open Editor</strong> &gt; <strong>Header</strong>.</li>
				<li>This will generate the <strong>scxDecryptorWorker.h</strong> file and open the CDT editor on it, with the cursor placed between the marker comments.</li>
				<li>Add the following: <strong>// worker header comment</strong>. This should be added between the markers, and then save the file.</li>
				<li>When you saved the <strong>scxDecryptorWorker.h</strong> file, <pn>ProductName</pn> captures the changes you had made and stored them in the model.</li>
				<li>Delete the <strong>scxDecryptorWorker.h</strong> file and go back to right click <strong>Decryptor</strong> and select <strong>Open Editor</strong> &gt; <strong>Header</strong> again.</li>
				<li>This will generate the <strong>scxDecryptorWorker.h</strong> file again and open the CDT editor on it again. This time you will see the modification that you previously made, and which <pn>ProductName</pn> has regenerated.</li>				
			</ol>
			<p>In addition to the above location, you may also edit code in the Worker.cpp file, using <strong>Open Editor</strong> &gt; <strong>Implementation</strong>, and in the Worker class, using <strong>Open Editor</strong> &gt; <strong>Class</strong>.</p>
			<p>The worker's configure, query and runTest methods should be edited by right clicking on the appropriate <strong>SCA Property</strong> and selecting <strong>Open Editor</strong>.
For example, to edit the Decryptor Worker's DECRYPT_KEY configure method, do the following:</p>
			<ol>
				<li>Select and right-click the Decryptor property <strong>DECRYPT_KEY</strong> and select <strong>Open Editor</strong> &gt; <strong>Configure</strong>.</li>
				<li>Add the following: <strong>execParams_.DECRYPT_KEY = DECRYPT_KEY.in();</strong>, save and close the file.</li>
				<li>Select and right-click the Decryptor property <strong>DECRYPT_KEY</strong> and select <strong>Open Editor</strong> &gt; <strong>Query</strong>.</li>
				<li>Add the following: <strong>DECRYPT_KEY = execParams_.DECRYPT_KEY.c_str();</strong>, save and close the file.</li>
				<li>Right click <strong>Decryptor</strong> and select <strong>CX Generate</strong> &gt; <strong>SCA Code</strong>. This regenerates
 the code for the component.</li>
				<li>Inspect the <strong>scxDecrytporWorker.cpp</strong> file and see the change you made is still there.</li>
			</ol>
			<p>Other methods can be edited directly (i.e. start, stop, initialize, releaseObject). To edit these methods simply select them, right click and select <strong>Open Editor</strong>.</p>
			<p>Every provides port operation is represented by a method in the worker. A port name on a component has to be unique. 
To ensure components can handle multiple provides ports of the same interface type CX names each method &lt;port_name&gt;_&lt;method&gt;.
For example, to edit the Decryptor Worker's provides ports method, select and right-click the <strong>Decryptor::dataIn_pushEncryptedData()</strong> 
method and select <strong>Open Editor</strong>. This method is called when a pushEncryptedData message is received on the dataIn port.</p>
			<p>Save the model.</p>
			<h2>Compile the Source</h2>
			<p>In order to compile the source code, select or open the <strong>Make Targets</strong> view (to open, go to <strong>Window > Show View > Other</strong>).</p>
			<ol>
				<li>In the <strong>Make Targets</strong> view, double click on the <strong>all</strong> target to compile everything.</li>
				<br>The console view allows you to view the build progress. You should see the source code generated and compiled for the IDL, 
ports and the build target. The binaries should appear under subdirectories of the <strong>CXTutorial_Model_src/obj</strong> directory.</br>
			</ol>
			<h2>Descriptor Generation</h2>
			<p>CX generates SCA-compliant XML descriptor files from the UML 2.0 model that you define. XML can be generated from Applications, 
Nodes, Platforms and individual component structure realizations. CX creates all the XML descriptor files as specified in the Domain Profile.</p>
			<p>To generate the application XML, do the following:</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select <strong>TutorialApplication</strong> and from the pop-up menu select <strong>
CX Generate</strong> &gt; <strong>Descriptor(s)</strong>.</li>
				<p>The files are generated and added to the CXTutorial_Model_src/descriptors folder.</p>
			</ol>
			<p>CX generates the Software Assembly Descriptor for the application.  It also generates the Software Component and Software Package 
			Descriptors for each component contained in the application. If you have defined properties for the components, CX generates the 
			Properties Descriptors, as well. </p>
			<p>To generate the platform xml, do the following:</p>
			<ol>
				<li>In the <strong>Project Explorer</strong>, select <strong>CommunicatorPlatform</strong> and from the pop-up menu select 
<strong>CX Generate</strong> &gt; <strong>Descriptor(s)</strong>. </li>
			</ol>
			<p>CX generates the Device Configuration Descriptor for all nodes in the platform. It also generates the Software Component and Software 
Package Descriptors for each device or Core Framework element contained in the node. If you have defined properties for the devices or 
Core Framework entities, CX generates the Property Descriptors, as well. </p>
			<h2>Descriptor Validation</h2>
			<p><pn>ProductName</pn> can be used to validate SCA XML descriptor files, whether they are generated from a 
			<pn>ProductName</pn> model or not. To validate the SCA descriptors that were just generated off the 
			<strong>CommunicatorPlatform</strong> and <strong>TutorialApplication</strong>, do the following:</p>
			<ol>
				<li>Select the <strong>CXTutorial_Model_src/descriptors</strong> folder.</li>
				<li>Right click and select <strong>Validate</strong>.</li>
			</ol>
			<p>This will result in 8 problem markers being created on some of the descriptor files. Each of these errors
			relates to a <strong>localfile name</strong> attribute referring to a file that does not exist. Each SPD file 
			contains at least one implementation block which in turn references the actual executable or shared 
			library file that it describes. When <pn>ProductName</pn> generates the descriptors and the binaries, it does 
			not currently generate these filename references with full path information, which is why the SCA XML Validation
			raises these errors. These errors will be fixed in the following sections.</p>
			<h2>Packaging Files for Deployment</h2>
			<p>So far, we have generated code, and compiled it, to produce binaries for the following components:</p>
			<ul>
				<li>AssemblyController</li>
				<li>Filter</li>
				<li>Decryptor</li>
				<li>Modem</li>
			</ul>
			<p>It is assumed that the binaries for the other components are pre-existing, either from a Core Framework distribution or elsewhere:</p>
			<ul>
				<li>cryptolib.so</li>
				<li>DomainManager</li>
				<li>DeviceManager</li>
				<li>DomainLog</li>
			</ul>
			<p>This section describes how to model these pre-existing binaries so that they will get copied into the
			<strong>CXTutorial_Model_src</strong> project during generation. To do this we need to associate a 
			<strong>Binary Configuration</strong> with the appropriate Component Implementation elements. A <strong>Binary 
			Configuration</strong> is similar to a <strong>Build Configuration</strong> except instead of specifying 
			how to generate and compile code, to produce the binary for the component, it specifies the location of 
			a pre-existing binary for the component.</p>
			<p>Before doing this we need to create a dummy <strong>cryptolib.so</strong> file. This file is required to 
			satisfy the SPD validation and Core Framework runtime. However, since it only exists in order to demonstrate
			a modeling construct, it doesn't need to be a functional library.</p>
			<ol>
				<li>Right-click on the <strong>CXTutorial</strong> project and select <strong>New > File</strong>.</li>
				<li>In the New File dialog, select the <strong>CXTutorial</strong> project.</li>
				<li>Enter the File Name as <strong>cryptolib.so</strong> and click <strong>Finish</strong>.</li>
			</ol>
			<p>Now create the <strong>Binary Configurations</strong>.</p>
			<ol>
				<li>In the Project Explorer, or on the DomainManager diagram, select the <strong>DomainManagerImpl</strong> element.</li>
				<li>Right click and select <strong>Build Configuration...</strong>.</li>
				<li>In the <strong>Base Build Configuration</strong> drop down, select 
				<strong>eorb16-linux-gcc-x86::eorb16-linux-gcc-x86-build</strong> (or the Build Configuration that 
				describes your pre-existing binary the closest).</li>
				<li>Check the <strong>Use Binary Configuration</strong> check box.</li>
				<li>Click the <strong>Browse</strong> button on the <strong>Binary</strong> field and select your 
				pre-existing <strong>DomainManager</strong> binary. Note you can browse for your binary either in 
				the workspace or in the file system. Using a workspace URI, rather than a native file system URI, 
				makes your model projects more portable between different workspaces.</li>
				<li>Click <strong>OK</strong>.</li>
				<li>Now select the <strong>DomainManager</strong> element, right-click and select <strong>CX Generate > Descriptor(s)</strong>.</li>
				<li>Expand <strong>CXTutorial_Model_src/obj/eorb16-linux-gcc-x86-tools/eorb16-linux-gcc-x86-build</strong> 
				and you will see the generated <strong>DomainManager</strong> directory containing the copied 
				<strong>DomainManager</strong> binary.</li>
			</ol>
			<p>Repeat the above steps for the <strong>DeviceManager</strong>, <strong>DomainLog</strong> and 
			<strong>cryptolib.so</strong> binaries.</p>
			<p>Now that all of the binary files have been either compiled or copied into 
			<strong>CXTutorial_Model_src/obj/...</strong>, the SCA XML validation errors can now be addressed.
			This is done by creating a symbolic link (or copy) of the binaries in the 
			<strong>CXTutorial_Model_src/descriptors</strong> directory.</p>
			<p>Note that in the steps below, the names of the &lt;toolsdir&gt; and 
			&lt;builddir&gt; directories depends on which Build Configuration you have chosen. If you have used 
			the <strong>eorb16-linux-gcc-x86</strong> Build Configuration these directories will be named 
			<strong>eorb16-linux-gcc-x86-tools</strong> and <strong>eorb16-linux-gcc-x86-build</strong>.</p>
			<p>Also, depending on which Build Configuration you have chosen, the binary executable files may have an
			extension such as <strong>.vxe</strong> or <strong>.mod</strong> etc.</p>
			<ol>
				<li>Expand the <strong>CXTutorial_Model_src</strong> project.</li>
				<li>Link or copy the following binary files into the <strong>descriptors</strong> directory:</li>
				<ul>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/AssemblyController/AssemblyController</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/Decryptor/Decryptor</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/Filter/Filter</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/DomainManager/DomainManager</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/DeviceManager/DeviceManager</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/DomainLog/DomainLog</strong></li>
				<li><strong>obj/&lt;toolsdir&gt;/&lt;builddir&gt;/CryptoLib/cryptolib.so</strong></li>
				</ul>
			</ol>
			<p>Repeat the steps to validate the <strong>descriptors</strong> directory, and all of the XML errors 
			should now be fixed, indicating that you now have a self consistent set of valid descriptors and binary files.</p>
			<h2>Tutorial Summary</h2>
			<p>In this tutorial you have learned about code and descriptor generation. This final phase of the process shows how the model and its elements can be 
used to implement the principles of COE.</p>
		</helpTopic>




<!--Tutorial 6-->
		<helpTopic outputFile="tutorial6.html" title="Tutorial 6: Deploying on a Spectra Core Framework">
			<h1>Tutorial 6: Deploying on a Spectra Core Framework</h1>

<p> This tutorial assumes you have completed Tutorial 1, Tutorial 2, Tutorial 3, Tutorial 4 and Tutorial 5. </p>

<p>
In Tutorial 5 components were associated with implementations; build configurations were specified; domain descriptors and source code were generated.
</p>

<p>
In this tutorial, you will:
<ul>
<li>Amend components to make them deployable on Spectra Core Framework</li>
<li>Build the generated source code</li>
<li>Start an OE platform (created in Tutorial 3)</li>
<li>Load and run the Application (created in Tutorial 2)</li>
</ul>
</p>

<p>

<h1>Amending Components for Spectra CF</h1>
<p>Throughout this section, it is assumed that you are working on Linux and you have 
<strong>e*ORB</strong> installed in <strong>$EORBHOME</strong> and <strong>Spectra 
Core Framework</strong> installed in <strong>$CFHOME</strong>.</p>
<h1>Open the project and model</h1>

</p>

<p>
In the Project Explorer expand the project and model you worked with in Tutorial 5.
</p>

<h1>
Adding Properties
</h1>



<p>
To deploy an application successfully, the runtime must be able to match all Resource and Device properties.  
This step adds the properties to Spectra CX generated components and 
Spectra CF components to correctly setup for a successful application deployment.
</p>

<p>
<strong>Spectra CF Components</strong>
</p>
<p>
<strong>DeviceManager</strong>
</p>
<p>
DeviceManager requires os_name, processor and os_version properties. In addition for logging PRODUCER_LOG_LEVEL is required. 
</p>
<p>
<ol>
<li>Open the DeviceManager diagram</li>
<li>Right click on the DeviceManager component and from the popup menu, select Add CX  &gt; SCA Property. Name the attribute os_name. </li>
<li>Select os_name and in the Properties View  &gt;  SCA tab.    </li>
<li>Click Select type and browse to SCA Primitive CXTutorial_Model  &gt;  (SCALibrary)  &gt;  os_name. Set the Value to Linux.</li> 
<li>Right click on the DeviceManager component and select Add CX  &gt;  SCA Property. Name the attribute processor_name.    </li>
<li>Select processor_name and in the Properties View  &gt;  SCA tab.</li> 
<li>Click Select type and browse to SCA Primitive CXTutorial_Model  &gt;  (SCALibrary)  &gt;  processor_name. Set the Value to x86.</li>
<li>Open the SCAPropertiesDiagram </li>
<li>In the Palette, expand the SCA Platform drawer.     </li>
<li>In the Property Types drop-down list, select Primitive Property Type.      </li>
<li>Drop this element onto the SCAPropertiesDiagram.</li> 
<li>Name the property os_version. </li>
<li>In the Properties View &gt; SCA tab.</li> 

<br> Set the following attributes: </br> 
<br>ID: DCE:cf250630-4ba8-11da-8cd6-0800200c9a66</br> 
<br>Action: Equal</br> 
<br>Kind: Allocation</br> 
<br>Type: String</br> 
<li>Right click on DeviceManager component and from the popup menu, select Add CX  &gt;  SCA Property. Name the attribute os_version.</li>
<li>Select os_version and in the Properties View  &gt;  SCA tab. Click Type: and browse to SCA Primitive os_version.</li>
<li>Set the Value: field to 2.6.</li>
<li>Right click on the DeviceManager component and from the popup menu, select Add CX > SCA Property. Name the attribute PRODUCER_LOG_LEVEL.</li>
<li>Select the <strong>PRODUCER_LOG_LEVEL</strong> property.</li>
<li>In the <strong>Properties View &gt; SCA</strong> tab, click Select type and browse to SCA Primitive CXTutorial_Model > (SCALibrary) > PRODUCER_LOG_LEVEL.</li>
<li>In the <strong>Properties View &gt; General</strong> tab, set the <strong>Multiplicity</strong> to <strong>*</strong></li>
<li>In the <strong>Properties View &gt; General</strong> tab, set the <strong>Default Value</strong> to <strong>2,8</strong></li>
<li>Save the model.</li>

</ol>
</p>

<p>
<h1>DomainManager</h1>
</p>
<p>
The DomainManager requires two properties to work with SpectraCX generated components. In addition, for logging PRODUCER_LOG_LEVEL is required.
</p>
<p>
Threadpool Settings
</p>
<p>
<ol>
<li>Open the SCAPropertiesDiagram</li>
<li>In the Palette, expand the SCA Platform drawer.</li> 
<li>In the Property Types drop-down list, select Primitive Property Type.</li> 
<li>Drop this element onto the SCAPropertiesDiagram. </li>
<li>Name the property THREADPOOL_NO_POOL. </li>
<li>In the Properties View  &gt;  SCA tab. </li>
<br>Set the following attributes:</br> 
<br>ID: THREADPOOL_NO_POOL</br> 
<br>Action: Equal</br> 
<br>Kind: Exec</br> 
<br>Type: Ulong</br> 
<li>Open the DomainManager diagram.</li>
<li>Right click on DomainManager component and from the popup menu, select Add CX  &gt;  SCA Property. Name the attribute THREADPOOL_NO_POOL.</li>
<li>Select THREADPOOL_NO_POOL and in the Properties View  &gt;  SCA tab. Click Type: and browse to SCA Primitive THREADPOOL_NO_POOL.</li>
<li>Set the Value: field to 1.</li>
<li>Save the model.</li>
</ol>
</p>

DomainManager domain profile
<p>
<ol>
<li>Open the SCAPropertiesDiagram</li>
<li>In the Palette, expand the SCA Platform drawer.</li> 
<li>In the Property Types drop-down list, select Primitive Property Type.</li> 
<li>Drop this element onto the SCAPropertiesDiagram.</li> 
<li>Name the property DMD_FILENAME.</li> 
<li>In the Properties View  &gt;  SCA tab.</li> 

<p>
Set the following attributes: 
<br>ID: DMD_FILENAME</br>
<br>Action: Equal</br>
<br>Kind: Exec</br>
<br>Type: String</br>
</p>

<li>Open the DomainManager diagram.</li>
<li>Right click on DomainManager component and from the popup menu, select Add CX  &gt;  SCA Property. Name the attribute DMD_FILENAME.</li>
<li>Select DMD_FILENAME and in the Properties View &gt; SCA tab. Click Type: and browse to SCA Primitive DMD_FILENAME.</li>
<li>Set the Value: field to /dmfs/DomainManager.dmd.xml</li>
<li>Save the model.</li>
</ol>
</p>

PRODUCER_LOG_LEVEL
<p>
<ol>
<li>Right click on the DomainManager component and from the popup menu, select Add CX > SCA Property. Name the attribute PRODUCER_LOG_LEVEL.</li> 
<li>Select the <strong>PRODUCER_LOG_LEVEL</strong> property.</li>
<li>In the <strong>Properties View &gt; SCA</strong> tab, click Select type and browse to SCA Primitive CXTutorial_Model > (SCALibrary) > PRODUCER_LOG_LEVEL.</li>
<li>In the <strong>Properties View &gt; General</strong> tab, set the <strong>Multiplicity</strong> to <strong>*</strong></li>
<li>In the <strong>Properties View &gt; General</strong> tab, set the <strong>Default Value</strong> to <strong>2,8</strong></li>
</ol>
</p>


<h1>
Spectra CX Components
</h1>

Modem
<p>
<ol>
<li>Open Modem diagram.</li>
<li>Right click on Modem structure realization and from the popup menu, select Add CX &gt; SCA Property. Name the attribute os_version.</li>
<li>Select os_version and in the Properties View &gt; SCA tab. Click Select type and browse to SCA Primitive os_version.</li>
<li>Set the Value: to 2.6.</li>
</ol>
</p>

<h1>
Building Source Code
</h1>

<p>
Your source code must be rebuilt after changes to generated components. Please refer back to 
Tutorial 5 â€“ Generate Code step for instructions on how to generate. After generation of 
source code, follow Tutorial 5 â€“ Compile the Source and Tutorial 5 â€“ Descriptor Generation 
again to ensure all binary and domain profiles are consistent with the new model changes for 
Spectra Core Framework deployment. 
</p>

<h1>
Testing the components
</h1>

<p>
Before deploying your components they need to be tested. Spectra CX can generate tests for your components. 
<br></br>
To configure your model for test generation:
<ol>
<li>	In the Project Explorer, select the <strong>CXTutorial_Model</strong> model.</li>
<li>	Right click and select <strong>Import Model Library...</strong>.</li>
<li>	Select the <b>Deployed Library</b> checkbox.</li>
<li>	Choose the <strong>TargetLoader</strong> library from the drop down list and click OK.</li>li> 
<li>	In the Project Explorer, select the <strong>CXTutorial_Model</strong> model.</li>
<li>	Right click and select <strong>Add CX &gt; SCA Target Loader</strong>.</li>
<li>	In the Project Explorer, select the <strong>SCATargetLoader</strong>.</li>
<li>	In the Properties pane select the SCA tab and configure SCATargetLoader as follows:</li>
<ul>
<li>	Name: SCATargetLoader</li>
<li>	Object Ref: corbaloc:iiop:1.1@&lt;IP ADDRESS OR HOST NAME&gt;:8277/TargetLoader</li>
<li>	Timeout: 60000</li> 
</ul>
</ol>

To generate and run tests for your components:
<ol>
<li>	Open the Modem diagram.</li>
<li>	Drag the <strong>SCATargetLoader</strong> from the Project Explorer onto the diagram.</li>
<li>	Select "Target Loader Dependency" from the palette.</li>
<li>	Add a dependency from <strong>ModemImpl</strong> to <strong>SCATargetLoader</strong>.</li>
<li>	Select the <strong>Modem structural realization</strong>.</li>
<li>	Right click and select <strong>CX Generate -> Tests</strong>.</li>
<li>	Run the <strong>$CFHOME/bin/TargetLoader</strong> binary in a terminal.</li>
<li>	In the Project Explorer, select <strong>CXTutorial_Model_src/utests/tests/CXTutorial_Model/Platform/Modem/ModemImplSCATargetLoaderTest.java</strong>.</li>
<li>	Right click and select <strong>Run As -> JUnit Test</strong>.</li>
<li>	Repeat steps 1 to 4 for the <strong>DomainLog</strong>, <strong>Decryptor</strong>, <strong>Filter</strong> and <strong>AssemblyController</strong>.</li>
</ol>

To generate and run test suites for your assemblies:
<ol>
<li>	In the Project Explorer, select <strong>CommunicatorPlatform</strong>.</li>
<li>	Right click and select <strong>CX Generate -> Tests</strong>.</li>
<li>	Run the <strong>$CFHOME/bin/TargetLoader</strong> binary in a terminal.</li>
<li>	In the Project Explorer, select <strong>CXTutorial_Model_src/utests/tests/CXTutorial_Model/Platform/CommunicatorPlatformTestSuite.java</strong>.</li>
<li>	Right click and select <strong>Run As -> JUnit Test</strong>.</li>
<li>	The will run the tests for the Modem and the DomainLog.</li>
<li>	Repeat this process for the <strong>TutorialApplication</strong> (TutorialApplicationTestSuite.java will run the tests for the Decryptor, the Filter and the AssemblyController).</li>
</ol>
</p>

<h1>
Running OE Platform
</h1>

<p>
In order to run the platform you will need to change directory into CXTutorial_Model_src/descriptors.
</p>

<p>
At the terminal prompt enter:
</p>
<p>
$CFHOME/bin/BootLoader -DCD_FILENAME DecryptorNode.dcd.xml -ORBInitRef NameService=corbaloc:iiop:1.1@ &lt; IP ADDRESS OR HOST NAME &gt; :2809/NameService
</p>

<p>
You should see output similar to the following, if not check your steps again.
</p>

<p>
$ cd ~/spectracx/workspace/Tutorial_Model_src/descriptors
</p>
<p>
$ /home/cf/spectracx/release/3.1-GA/oe/bin/BootLoader -DCD_FILENAME DecryptorNode.dcd.xml -ORBInitRef NameService=corbaloc:iiop:1.1@10.1.0.23:2809/NameService
<br>Use the following line as an argument when starting LogServices or
Devices:</br>
<br>
-DEVICE_MGR_IOR
IOR:010000001900000049444c3a43462f4465766963654d616e616765723a312e3000000000010000000000000044000000010101000a00000031302e312e302e3233001e9a2800000001921800654f52427a910020030000000e4465766963654d616e616765720000040000000f00000000000000
</br>
<br>
ORB Args:</br></p>
<p>
Use the following line as an argument when starting DeviceManager:
</p>
<p>
-ORBInitRef NameService=corbaloc:iiop:1.1@10.1.0.23:2809/NameService
</p>
<p>
Or:
</p>
<p>
-ORBInitRef
</p>
<p>
NameService=IOR:010000002800000049444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e746578743a312e3000010000000000000050000000010101000a00000031302e312e302e323300f90a3200000001820a00654f5242000000000e446f6d61696e4d616e6167657200000b0000004e414d494e475f504f410000020000003000000000000000
</p>

DomainManager waiting for requests ....
<h1>
Loading and Running Application
</h1>
<p>
In order to run an application you need to add a Monitor to the model.
</p>

<p>
<ol>
<li>	In the Project Explorer, select the <strong>CXTutorial_Model</strong> model.</li>
<li>	Right click and select <strong>Add CX &gt; Monitor</strong></li>
<li>	New Monitor Wizard will appear, set</li>
<ul>
<li>	Name: Monitor</li>
<li>	Domain Manager: myDomain/DomainManager</li>
<li>	Naming Service: corbaloc:iiop:1.1@&lt;IP ADDRESS OR HOST NAME&gt;:2809/NameService</li> 
</ul>
<li>	Click the Finish button.</li>
<li>	Select the new <strong>Monitor</strong> object in <strong>CXTutorial_Model</strong>.</li>
<li>	Right click Monitor  &gt;  Open SCA Monitor</li>
<li>	The Monitor view will appear showing Control and Deployment panes.  The view will contain running OE components (DeviceManager, DomainManager, ModemDevice).</li>
<li>	In the Control pane, right click Application Folder  &gt;  Install Application Factory</li>
<li>	The Enter SAD window will appear. Enter the path to the SAD file, which is <strong>/dmfs/TutorialApplication.sad.xml</strong></li>
<li>	Click OK.</li>
<li>	In the <strong>Control</strong> window you will see the <strong>TutorialApplication</strong> application factory deployed.</li>
<li>	Right click on the <strong>TutorialApplication</strong> factory and select <strong>Create Application</strong></li>
<li>	Enter <strong>app1</strong> as the application name, and click <strong>OK</strong></li>
<li>	The new application instance <strong>app1</strong> will show up in the <strong>Control</strong> window and, in the <strong>Deployment</strong> window, you will see its constituent resources executing on the <strong>Modem</strong> device.</li>
<li>	Right clicking on <strong>app1</strong> will let you control the lifecycle of your application instance. There are options to Start, Stop and Release your instance.</li>
</ol>
</p>
		</helpTopic>
	</helpTopics>
</root>
