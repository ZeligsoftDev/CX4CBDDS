import langc;
import ZMLMM::ZML_Deployments;
import ZMLMM::ZML_Component;
import ZMLMM::ZML_Core;
import CLanguageDomain::CLanguageDomain;

extension langc::debug;
extension langc::element;
extension langc::expr;
extension langc::stmt;
extension langc::type;
extension langc::name;

extension structure::posixelement;
extension util::lookup;

extension template::name;
extension cmps::recvFuncs;
extension template::utils;
extension cmps::instances;
extension cmps::send;
extension cmps::userWorkerFuncs;
extension cfgs::process;
extension cfgs::process_entry;
extension ifs::interface;
extension fwk::api;
extension fwk::zcx_context;
extension fwk::message;
extension include::compInterface;
extension include::compInstances;
extension include::userStruct;

create System deployment( Deployment deployment ) :
    setArtifacts(
        deployment
            .eAllContents.typeSelect( Allocation )
            .deployedOn.typeSelect( DeploymentPart ).reject( e | e.getProcessDefinition().isEmpty )
            .artifact( deployment ) )
;

private cached LinkableArtifact artifact( DeploymentPart process, Deployment deployment ) :
//    let userStructs = deployment.zdlAsComponent().getModel().eAllContents.typeSelect( C_Struct ) :
    let sources = process.getSourcesForTargetPart() :
    let artifact = process.artifact() :
        sources.visitComponentInstance( deployment, process )
     -> artifact.rootElements.add( deployment.portIteratorImpl( process ) )
     -> artifact.rootElements.add( deployment.entryImpl( process ) )
     -> deployment.queueName( process )
     -> deployment.queueInit( process )
     -> deployment.queueRelease( process )

/*
 -> rootElements.addAll( sources.genSendFile( process, d ).elements )  
 -> rootElements.addAll( process.genProcessFile( d ).elements )
 -> rootElements.addAll( process.genProcessEntryFile( d ).elements )
 -> rootElements.addAll( sources.getComponentInterface().genRecvFuncsFile().elements )
 -> rootElements.addAll( sources.getComponentInterface().genUserWorkerFuncsFile().elements )
 -> rootElements.addAll( sources.select( e | ! e.getComponentInterface().isEmpty ).getInterfaceFile().elements )
-> rootElements.addAll( sources.collect( e | e.getComponentInterface().get( 0 ).genCompInstanceFile( e ) ).elements )
 -> rootElements.addAll( sources.getComponentInterface().genCompInterfaceFile().elements )
 -> rootElements.addAll( d.getFrameworkApiFile().elements )
 -> rootElements.addAll( d.getFrameworkContextFile().elements )
 -> rootElements.addAll( d.getFrameworkMessageFile().elements )
 -> rootElements.addAll( userStructs.genUserStructFile().elements )
*/

    -> sources.finalizeComponentInstance( deployment, process )
    -> deployment.finalizeProcess( process )
    -> artifact
;

/*
create System deployment( Deployment d ):
   let deployedProcesses = d.eAllContents.typeSelect(Allocation).deployedOn.typeSelect(DeploymentPart).select(e|!e.getProcessDefinition().isEmpty) :
    setSubSystems(  deployedProcesses.collect(e|e.subProcess(d)) )
 -> setPublicFolders( { rootIncludeFolderName() } )
;

cached SubSystem subProcess( DeploymentPart process, Deployment d ) :
   let userStructs = d.zdlAsComponent().getModel().eAllContents.typeSelect(C_Struct) :
   let sources = process.getSourcesForTargetPart() : 
   let s = subSystem( process.zdlAsNamedElement().name ) :
        s.files.addAll( sources.genInstancsFile(process) )
     -> s.files.addAll( sources.genSendFile(process, d) )  
     -> s.files.addAll( { process.genProcessFile(d) }) 
     -> s.files.addAll( { process.genProcessEntryFile(d) })
     -> s.files.addAll( sources.getComponentInterface().genRecvFuncsFile() )
     -> s.files.addAll( sources.getComponentInterface().genUserWorkerFuncsFile() )
     -> s.files.addAll( sources.select(e|!e.getComponentInterface().isEmpty).getInterfaceFile() )
     -> s.files.addAll( sources.collect(e|e.getComponentInterface().get(0).genCompInstanceFile(e)) )
     -> s.files.addAll( sources.getComponentInterface().genCompInterfaceFile() )
     -> s.files.addAll( { d.getFrameworkApiFile() })
     -> s.files.addAll({ d.getFrameworkContextFile() })
     -> s.files.addAll( { d.getFrameworkMessageFile() })
     -> s.files.addAll( userStructs.genUserStructFile() )
     -> s.setPublicFolders( { process.processIncludeFolderName() } )
	 -> s.setFolders( { rootFolderName() } )
	 -> s
;
*/
