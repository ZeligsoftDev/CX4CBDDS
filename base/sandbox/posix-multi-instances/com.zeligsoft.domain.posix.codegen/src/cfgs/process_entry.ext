import langc;
import ZMLMM::ZML_Deployments;
import ZMLMM::ZML_Component;
import ZMLMM::ZML_Core;

extension langc::element;
extension langc::expr;
extension langc::stmt;
extension langc::type;
extension langc::debug;
extension langc::mqueue;
extension langc::libc;
extension langc::preprocessor;
extension langc::name;
extension langc::util;


extension template::name;
extension template::utils;
extension include::compInterface;
extension fwk::zcx_context;
extension fwk::api;
extension cfgs::process;
extension cmps::recvFuncs;
extension fwk::message;

create ElementList genProcessEntryFile(DeploymentPart dp, Deployment d) :
	setName(dp.processEntryFileName(d))
	-> addElement(dp.contextArrayVar(d))
	-> addElement(dp.getSourcesForTargetPart().getCompUsesPort(dp, d))
	-> genContextNextImplFunc(dp, d)
	-> addElement(dp.genMainFunction(d))
;

Function getCompUsesPort(DeploymentPart source, DeploymentPart target, Deployment d) :
	let compDef = source.getComponentInterface().get(0) :
	compDef.ownedPort.select(e|!e.zdlAsPort().required.isEmpty).genCompUsesPortFunction(compDef, target, source, d)	
;

Function genCompUsesPortFunction(Port p, ComponentInterface ci, DeploymentPart target, DeploymentPart source, Deployment d) :
	let f = function(void().ptr().const(), p.processCompUsesPortFuncName(ci, target, d) ) :
	let indexName = getProcessCompPortIds(p, source.modelElement).get(0).processCompIdNames(target, d) :
	f.setKind(implOnly())
	-> f.addParameter(ci.compInterfaceStruct().ptr().const(), 'self')
	-> f.addStatement(returnStmt(target.contextArrayVar(d).access().index(indexName.access()).addressOf()))
	-> f
;

Function genMainFunction(DeploymentPart dp, Deployment d) :
	let sources = getSourcesForTargetPart(dp) :
	let f = function(int32(), dp.mainFuncName(d)) :
	f.addParameter(int32(), 'argc')
	-> f.setKind(implOnly())
	-> f.addParameter(char().ptr().const(), 'argv[]')
	-> sources.genInstLifeCycleFunc(f, dp, 'init')
	-> f.addStatement(printf('Starting %s', dp.zdlAsNamedElement().name.literal()))
	-> f.addStatement(dp.createReceiveQueue(d))
	-> d.eAllContents.typeSelect(DeploymentPart).select(e|(!e.getProcessDefinition().isEmpty) && (!getSourcesForTargetPart(e).isEmpty)).msgqInitFuncCall(f,d)
	-> sources.genInstLifeCycleFunc(f, dp, 'start')
	-> f.addStatement(dp.createBuffArrayVar(d))
	-> f.addStatement(dp.mainWhileStatement(d))
	-> sources.genInstLifeCycleFunc(f, dp, 'stop')
	-> d.eAllContents.typeSelect(DeploymentPart).select(e|(!e.getProcessDefinition().isEmpty) && (!getSourcesForTargetPart(e).isEmpty)).msgqReleaseFuncCall(f,d)
	-> f.addStatement(mq_close(dp.receiveQueueName(d)))
	-> sources.genInstLifeCycleFunc(f, dp, 'release')
	-> f.addStatement(returnStmt(blob('EXIT_SUCCESS')))
	-> f
;

VariableDeclaration createReceiveQueue(DeploymentPart dp, Deployment d) :
	let q = variable(mqd_t(), dp.receiveQueueName(d)) :
	q.setInitializer(createMQueue(dp.processMsgqName(d)))
	-> q
;

VariableDeclaration createPriorityVar(DeploymentPart dp, Deployment d) :
	let q = variable(uint32(), dp.priorityName(d)) :
	q
;

cached VariableDeclaration createBuffArrayVar(DeploymentPart dp, Deployment d) :
	let q = variable(int8(), dp.buffName(d)) :
	q.element.setArrayBounds({dp.maxMSGSizeName(d).access()})
	-> q
;

Expression msgqInitFuncCall(DeploymentPart dp, Function f, Deployment d) :
	let fc = new FunctionCall :	
	fc.setFunction(dp.genMQInitFunc(d))
	-> f.addStatement(fc)
;

Expression msgqReleaseFuncCall(DeploymentPart dp, Function f, Deployment d) :
	let fc = new FunctionCall :	
	fc.setFunction(dp.genMQReleaseFunc(d))
	-> f.addStatement(fc)
;

Expression genInstLifeCycleFunc(DeploymentPart source, Function f, DeploymentPart target, String operationName) :
	let part = (uml::Property)source.modelElement :
	let compDef = source.getComponentInterface().get(0) :
	let sr = getStructuralRealizations(compDef).get(0) :
	let operation = sr.worker.portOperation.select(e|e.zdlAsOperation().name.matches(operationName)).first() :
	let body = sr.worker.select(e|e.portOperation.zdlAsOperation().name.matches(operationName)).body.first() :
	let instNames = part.getMultiInstanceNames() :
	body != null
	? instNames.lifeCycleFuncCall(compDef, sr, f, operation, target)
	: Void
;

Expression lifeCycleFuncCall(String instName, ComponentInterface ci, StructuralRealization sr, Function f, Operation o, DeploymentPart target) :
	let fc = new FunctionCall :
	fc.setFunction(o.genLifeCycleOperation(ci, sr))
	-> fc.arguments.add(instName.compUserInstancesName(target, ci).access())
	-> f.addStatement(fc)
;


Void genContextNextImplFunc(DeploymentPart dp, Deployment d) :
    genContextNextFunc().addStatement( genProcessEntryFile(dp, d), dp.switchOnContextEnum(d) )
;

SwitchStatement switchOnContextEnum(DeploymentPart dp, Deployment d) :
	let s = switchStmt(blob('( (unsigned)prev - (unsigned)ctx ) / sizeof( ctx[0] )')) :
	getSourcesForTargetPart(dp).addContextSwitchClase(dp, d, s)
	-> s.addCase(defaultClause().addStatement(returnStmt(NULL())))
	-> s
;

SwitchClause addContextSwitchClase(DeploymentPart source, DeploymentPart target, Deployment d, SwitchStatement s) :
	let modelElement = source.modelElement :
	s.addCase(source.getComponentInterface().get(0).ownedPort.getContextIdName(source, target, d))
;

SwitchClause contextEnumCase(Name idEnumName, DeploymentPart dp, Deployment d, Port p, DeploymentPart source) :
	let list = p.getProcessCompPortIds(source.modelElement).convertStringToName(dp, d) :
	let l = labeledClause(idEnumName.access()) :
	list.iteratorNextContextEnum(idEnumName, l, dp, d)
	-> l
;

SwitchClause getContextIdName(Port p, DeploymentPart source, DeploymentPart target, Deployment d) :
	let list = p.getProcessCompPortIds(source.modelElement) :
	list.convertStringToName(target, d).collect(e|e.contextEnumCase(target, d, p, source))
;


WhileStatement mainWhileStatement(DeploymentPart dp, Deployment d) :
	let w = while(1.literal()) :
	//TODO: sizeof seems not taking a variable declaration
	w.addStatement(mQueueReceive(dp.receiveQueueName(d), dp.createBuffArrayVar(d)))
	-> w.addStatement(variable(genContextStruct().constPtr().const(), dp.destVarName(d), dp.contextArrayVar(d).access().index(dp.buffName(d).access().cast(genMessageStruct().ptr()).field(contextStructMemberName())).addressOf() ))
	-> w.addStatement(dp.switchOnPortInstId(d))
	-> w
;

SwitchStatement switchOnPortInstId(DeploymentPart dp, Deployment d) :
	let s = switchStmt(dp.destVarName(d).field(contextStructMemberName())) :
	getSourcesForTargetPart(dp).addIdSwitchClase(dp, d, s)
	-> s
;

private cached Name destVarName(DeploymentPart dp, Deployment d) :
	dp.mainFuncName(d).child('dest_ctx')
;

SwitchClause compPortInstIdCase(List[Name] idEnumNames, DeploymentPart dp, Deployment d, Port p, DeploymentPart source, Integer index) :
	let l = labeledClause(idEnumNames.access()) :
	l.addStatement(dp.switchOnSignalId(d, p, source, index))
	-> l
;


SwitchClause compPortInstIdCase(Name idEnumName, DeploymentPart dp, Deployment d, Port p, DeploymentPart source, Integer index) :
	let l = labeledClause(idEnumName.access()) :
	l.addStatement(dp.switchOnSignalId(d, p, source, index))
	-> l
;

SwitchClause addIdSwitchClase(DeploymentPart source, DeploymentPart target, Deployment d, SwitchStatement s) :
	let modelElement = source.modelElement :
	!modelElement.zdlAsProperty().isMultivalued() 
	? s.addCase(source.getComponentInterface().get(0).ownedPort.select(e|!e.zdlAsPort().provided.isEmpty).collect(e|e.getPortIdsName(source, target, d)))
	: s.addCase(source.getComponentInterface().get(0).ownedPort.select(e|!e.zdlAsPort().provided.isEmpty).getPortIdName(source, target, d))
	
;
									
SwitchClause getPortIdsName(Port p, DeploymentPart source, DeploymentPart target, Deployment d) :
	let list = p.getProcessCompPortIds(source.modelElement) :
	list.convertStringToName(target, d).compPortInstIdCase(target, d, p, source, 0)
;

SwitchClause getPortIdName(Port p, DeploymentPart source, DeploymentPart target, Deployment d) :
	let list = p.getProcessCompPortIds(source.modelElement) :
	let nameList = list.convertStringToName(target, d) :
	list.convertStringToName(target, d).collect(e|e.compPortInstIdCase(target, d, p, source, nameList.indexOf(e)))
;

private cached List[Name] convertStringToName(List[String] ids, DeploymentPart dp, Deployment d) :
	ids.collect(e|e.processCompIdNames(dp, d))
;

private cached Name convertStringToName(String id, DeploymentPart dp, Deployment d) :
	id.processCompIdNames(dp, d)
;

SwitchStatement switchOnSignalId(DeploymentPart dp, Deployment d, Port p, DeploymentPart source, Integer index) :
	let s = switchStmt(dp.buffName(d).access().cast(genMessageStruct().ptr()).field(messageStructMember2Name())) :
	s.addCase(((MessagePort)p).providedInterface.collect(e|e.operation.collect(o|o.getSignalIdName(e, dp, d, p, source, index))).flatten())
	-> s
;

SwitchStatement getSignalIdName(Operation o, Interface i, DeploymentPart dp, Deployment d, Port p, DeploymentPart source, Integer index) :
	o.operationIdName(i).signalIdCase(dp, d, p, source, o, index)
;

SwitchClause signalIdCase(Name idName, DeploymentPart dp, Deployment d, Port p, DeploymentPart source, Operation o, Integer index) :
	let l = labeledClause(idName.access()) :
	//TODO: right now can only add one param to the statement and which is the first one
	let s = new VariableDeclarationStatement :
	 o.zdlAsOperation().ownedParameter.isEmpty
	 ?  s.setVariable(variable(int32(), 'no_param'))
	 :  ( s.setVariable(variable(int32(), o.zdlAsOperation().ownedParameter.first().name))
	 		-> l.addStatement(s)
	 		-> l.addStatement(memcpy(o.paramNameProcess(dp,d).access().addressOf(), dp.buffName(d).access().cast(genMessageStruct().ptr()).field(messageStructMember3Name()), sizeof(o.paramNameProcess(dp,d))))
	 	)
	-> l.addStatement(dp.workerFuncCall(d, p, source, o, index))
	-> l
;

Expression workerFuncCall(DeploymentPart dp, Deployment d, Port p, DeploymentPart source, Operation o, Integer index) :
	let ci = source.getComponentInterface().get(0) :
	let sr = getStructuralRealizations(ci).get(0) :
	let fc = new FunctionCall :	
	fc.setFunction(o.genWorkerOperation((MessagePort)p, ci, sr))
	-> fc.arguments.add(dp.destVarName(d).access())
	-> fc.arguments.add(getMultiInstanceNames(source.modelElement).get(index).compUserInstancesName(dp, ci).access())
	-> o.workerParam(fc)
	-> fc
;

Expression workerParam(Operation o, FunctionCall fc) :
	o.zdlAsOperation().ownedParameter.isEmpty
	? ""
	: fc.arguments.add(blob(o.zdlAsOperation().ownedParameter.first().name))
;

private cached Name paramNameProcess(Operation o, DeploymentPart dp, Deployment d) :
	let n = new Name :
	n.setParent(dp.mainFuncName(d))
	-> n.setName(o.zdlAsOperation().ownedParameter.first().name)
	-> n
;

VariableDeclaration contextArrayVar(DeploymentPart dp, Deployment d) :
	let v = variable(genContextStruct().const().array(), 'ctx') :
	v.setKind(implOnly())
	-> v.setLinkage(static())
	-> v.setInitializer(dp.contextArrayInit(d))
	-> v
;

Expression contextArrayInit(DeploymentPart dp, Deployment d) :
	let b = new BlockInitializer :
	let portIdNames = getSourcesForTargetPart(dp).collect(e|e.getComponentInterface().get(0).ownedPort.collect(p|p.getProcessCompPortIds(e.modelElement).collect(l|l.processCompIdNames(dp, d)))) :
	portIdNames.flatten().contextArrayEnumInit(b)
	-> b
;

Expression contextArrayEnumInit(List[Name] ids, BlockInitializer b) :
	let list = ids.collect(e|e.access()) :
	b.setExprs(list.collect( e2|let b2 = new BlockInitializer : b2.setExprs( { e2 } ) -> b2 ) )
;


cached Name iteratorNextContextEnum(List[Name] names, Name name, SwitchClause l, DeploymentPart dp, Deployment d) :
	let curIndex = names.indexOf(name) :
	names.last() != name 
		? l.addStatement(returnStmt(dp.contextArrayVar(d).access().index(names.get(curIndex + 1).access()).addressOf()))
		: l.addStatement(returnStmt(NULL()))
;

private cached Name queueName(DeploymentPart dp, Deployment d) :
    let m = dp.genProcessEntryFile(d).privateDefine( MQueueMacroName(dp, d) ) :
        m.setReplacement( (dp.zdlAsNamedElement().name + 'MQ').literal() )
     -> m.name
;

private cached Name maxMSGSizeName(DeploymentPart dp, Deployment d) :
    let m = dp.genProcessEntryFile(d).privateDefine( dp.maxMSGSizeMacroName(d) ) :
        m.setReplacement( 8192.literal() )
     -> m.name
;


