
import langc;

extension langc::debug;
extension langc::element;

cached Collection[FileName] files( System system ) :
    system.subSystems.files.name.toSet()
;

ElementList resolveDependencies( ElementList elementList ) :
    elementList.elements.resolveDeps( elementList )
 -> elementList
;

/* The declaring file for any name is the parent.  This could be null. */
cached FileName filename( Name name )         : name.parent.filename();
cached FileName filename( FileName filename ) : filename;
cached FileName filename( Void name )         : null;

/* User elements cannot be declared, NamedElements are always declared in
 * their containing file.  FunctionImplementations are declared by their
 * function. */
cached FileName declarationFile( UserElement element )  : null;
cached FileName declarationFile( NamedElement element ) : element.name.filename();
cached FileName declarationFile( FunctionImplementation funcImpl ) :
    funcImpl.function.declarationFile()
;

/* UserElements are defined in the specified file.  NamedElements have the
 * option of not specifying their definition location, in which case it
 * defaults to the implementation of the declaring file.  Functions are
 * defined by their implementation (either default or artifact specific).
 * Implementations default to being defined in the file that declares
 * the function -- this should only apply to the defaultImpl.
 * TODO The requirement is that all non-default implementations have a
 *      defn specified, but that is not checked anywhere.  Implementations
 *      that violate the requirement will causes a SO between the Function
 *      and FunctionImplementation rules.  This needs to be fixed. */
cached FileName definitionFile( Void nothing, LinkableArtifact artifact ) : null;
cached FileName definitionFile( UserElement element, LinkableArtifact artifact )  : element.defn;
cached FileName definitionFile( NamedElement element, LinkableArtifact artifact ) :
    element.defn != null
        ? element.defn
        : element.name.filename()
;
cached FileName definitionFile( Function func, LinkableArtifact artifact ) :
    func.defaultImpl == null
        ? func.implementationFor( artifact ).definitionFile( artifact )
        : func.name.filename()
;
cached FileName definitionFile( FunctionImplementation funcImpl, LinkableArtifact artifact ) :
    funcImpl.defn != null
        ? funcImpl.defn
        : funcImpl.function.definitionFile( artifact )
;

// TODO This rule can look at the type of reference to determine whether a #include or
//      just a forward decl is required.  For now it always does a #include.
// TODO This body is wrong, it should make the dep to the element.name.parent file.
private DependencyList resolveInto( ElementReference ref, DependencyList depList ) :
    ref.element.resolveNameInto( depList )
 -> depList
;

private DependencyList resolveInto( Void noInstance, DependencyList depList ) :
    depList
;

private DependencyList resolveInto( NamedReference ref, DependencyList depList ) :
    ref.type.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( FunctionImplementation impl, DependencyList depList ) :
    impl.body.resolveInto( depList )
 -> depList
;

// TODO Need to create rules to resolve expressions, and then resolve the body
private DependencyList resolveInto( CodeBlock block, DependencyList depList ) :
    block.statements.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( Statement stmt, DependencyList depList ) :
    depList
;

private DependencyList resolveInto( ExpressionStatement stmt, DependencyList depList ) :
    stmt.expr == null
        ? depList
        : stmt.expr.resolveInto( depList )
;

private DependencyList resolveInto( SwitchStatement stmt, DependencyList depList ) :
    stmt.condition.resolveInto( depList )
 -> stmt.clauses.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( VariableDeclarationStatement varDeclStmt, DependencyList depList ) :
    varDeclStmt.variable.element.resolveInto( depList )
 -> varDeclStmt.variable.initializer.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( Expression expr, DependencyList depList ) :
    depList
;

private DependencyList resolveInto( FunctionCall call, DependencyList depList ) :
    call.function.resolveNameInto( depList )
 -> call.arguments.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( CastExpr cast, DependencyList depList ) :
    cast.targetType.resolveInto( depList )
 -> cast.expr.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( ElementAccess access, DependencyList depList ) :
    access.name.resolveNameInto( depList )
 -> depList
;

private DependencyList resolveInto( BlockInitializer init, DependencyList depList ) :
    init.exprs.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( BinaryOperation expr, DependencyList depList ) :
    expr.lhs.resolveInto( depList )
 -> expr.rhs.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( SizeofType expr, DependencyList depList ) :
    expr.type.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( SizeofExpr expr, DependencyList depList ) :
    expr.expr.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( SwitchClause clause, DependencyList depList ) :
    clause.statements.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( LabeledClause clause, DependencyList depList ) :
    clause.labels.resolveInto( depList )
 -> clause.statements.resolveInto( depList )
 -> depList
;

private DependencyList resolveInto( CodeBlob blob, DependencyList depList ) :
    depList.add( blob.dependencies )
 -> depList
;

// Only NamedElement's have names.
private DependencyList resolveNameInto( Element element, DependencyList depList ) :
    depList
;

private DependencyList resolveNameInto( NamedElement element, DependencyList depList ) :
    element.name.resolveNameInto( depList )
 -> depList
;

private DependencyList resolveNameInto( Name name, DependencyList depList ) :
    name == null || name.parent == null
        ? depList
        : ( name.parent.resolveNameInto( depList )
            -> depList )
;

private DependencyList resolveNameInto( FileName name, DependencyList depList ) :
    name == null
        ? depList
        : depList.add( depList.createInclude( name ) )
       -> depList
;

// depList is only used to ensure the caching is valid
private create UserInclude createInclude( DependencyList depList, FileName name ) :
    setFilename( name )
 -> this
;

private create SystemInclude createInclude( DependencyList depList, SystemFileName name ) :
    setFilename( name )
 -> this
;

// Subclasses should override to examine their particular dependencies.  This rule should
// resolve both header and impl. dependencies.  This allows the particular element to
// decide where the dependencies should go, e.g., a public function will put its deps
// into the header file, while a file static function (private to .c file) will put them
// into the impl file.
// TODO For now all children put all their dependencies into the header.
private ElementList resolveDeps( Element element, ElementList elementList ) :
    elementList
;

private ElementList resolveDeps( Structure structure, ElementList elementList ) :
    structure.members.resolveInto( elementList.declIncludes() )
 -> elementList
;

private ElementList resolveDeps( Function function, ElementList elementList ) :
    function.returnType.resolveInto( elementList.declIncludes() )
 -> function.parameters.resolveInto( elementList.declIncludes() )
 -> elementList
;

private ElementList resolveDeps( FunctionImplementation impl, ElementList elementList ) :
    impl.body.resolveInto( elementList.defnIncludes() )
 -> elementList
;

private DependencyList implList( UserElement element, ElementList elementList ) :
    element.kind.toString() == 'headerOnly'
        ? elementList.declIncludes()
        : elementList.defnIncludes()
;

/* TODO this needs to check the proper location for initializer deps */
private ElementList resolveDeps( VariableDeclaration variable, ElementList elementList ) :
    variable.element.resolveInto( elementList.declIncludes() )
 -> variable.initializer.resolveInto( elementList.defnIncludes() )
 -> elementList
;

private ElementList resolveDeps( Typedef typedef, ElementList elementList ) :
    typedef.element.resolveInto( elementList.declIncludes() )
 -> elementList
;

private ElementList resolveDeps( FunctionPointer functionPointer, ElementList elementList ) :
    functionPointer.returnType.resolveInto( elementList.declIncludes() )
 -> functionPointer.parameters.resolveInto( elementList.declIncludes() )
 -> elementList
;
