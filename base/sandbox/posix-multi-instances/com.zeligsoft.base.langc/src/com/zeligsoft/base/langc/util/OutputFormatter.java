/**
 * Copyright 2018 ADLINK Technology Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.zeligsoft.base.langc.util;

import org.eclipse.cdt.core.CCorePlugin;
import org.eclipse.cdt.core.ToolFactory;
import org.eclipse.cdt.core.formatter.CodeFormatter;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.Document;
import org.eclipse.jface.text.IDocument;
import org.eclipse.jface.text.IRegion;
import org.eclipse.osgi.util.NLS;
import org.eclipse.text.edits.MalformedTreeException;
import org.eclipse.text.edits.TextEdit;
import org.openarchitectureware.xpand2.output.FileHandle;

import com.zeligsoft.base.langc.internal.Activator;
import com.zeligsoft.base.langc.l10n.Messages;

public class OutputFormatter {

	private static final int MAX_MAKEFILE_BLANK_LINES = 2;
	
	/**
	 * Formats .c and .h files generated by the CX
	 */		
	static public void formatCFile( FileHandle file ) {

		// do nothing if the CDT plugin is not loaded
		if (Platform.getBundle(CCorePlugin.PLUGIN_ID) == null)
			return;

		CodeFormatter codeFormatter = ToolFactory.createCodeFormatter(null);
		String content = file.getBuffer().toString();
		content = content.replaceAll("^[^#][^\r\n]*\r\n", " "); //$NON-NLS-1$ //$NON-NLS-2$
		content = content.replaceAll(" 0BLANKLINE", "\r\n\r\n"); //$NON-NLS-1$ //$NON-NLS-2$
		IDocument doc = new Document(content);
		
		TextEdit edit = codeFormatter.format(
			CodeFormatter.K_TRANSLATION_UNIT, doc.get(), 0, doc.get().length(),
			0, null);

		if (edit == null) {
			Activator.getDefault().getLog().log(
					new Status(IStatus.ERROR, Activator.PLUGIN_ID,
							NLS.bind( Messages.Formatter_CantFormat, file.getTargetFile() )));
			return;
		}

		try {
			edit.apply(doc);
			StringBuffer formatted = new StringBuffer(doc.get());
			if(formatted.charAt(formatted.length() - 1) != '\n')
				formatted.append('\n');
			file.setBuffer(formatted);
		} catch (MalformedTreeException e) {
			Activator.getDefault().getLog().log(
					new Status(IStatus.ERROR, Activator.PLUGIN_ID,
							NLS.bind( Messages.Formatter_IllegalTree, e.getMessage() )));			
		} catch (BadLocationException e) {
			Activator.getDefault().getLog().log(
					new Status(IStatus.ERROR, Activator.PLUGIN_ID,
							NLS.bind( Messages.Formatter_BadLocation, e.getMessage() )));			
		}
	}

	
	/**
	 * Formats makefiles and makefile fragments generated by the CX
	 */		
	static public void formatMakefile( FileHandle file ) {

		IDocument doc = new Document( file.getBuffer().toString() );
		int lines = doc.getNumberOfLines();
		if ( lines > 0 ) {
			try {
				StringBuffer buffer = new StringBuffer( doc.getLength() );
				int empty = 0;
	
				// assume same end of line for all lines in file
				String eol = doc.getLineDelimiter( 0 );
				
				for ( int lineNo = 0; lineNo < lines; lineNo++ ) {
				
					IRegion region = doc.getLineInformation( lineNo );
					String str = doc.get( region.getOffset(), region.getLength() );
					
					// keep track of blank lines
					if ( str.trim().length() == 0 ) {
						str = "";	//$NON-NLS-1$
						empty++;
					} else {
						empty = 0;
					}
					
					// don't write too many blank lines
					if ( empty < MAX_MAKEFILE_BLANK_LINES ) {
						buffer.append( str + eol );
					}
				}
				
				file.setBuffer( buffer );
				
			} catch( BadLocationException ble ) {
				ble.printStackTrace();			
			}
		}
	}

}
