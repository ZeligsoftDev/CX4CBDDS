/**
 * Copyright 2018 ADLINK Technology Limited.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import xmischema; 
import deploymentplan;
import DDS4CCM::DDS4CCM;
import IDL3Plus::Connectors;
import IDL3Plus::IDL3Plus;
import CCM::CCM_Component;
import CCM::CCM_Deployment;
import CCM::CCM_Implementation;
import CCM::CCM_Target;
import CORBADomain::IDL;
import ZMLMM::ZML_Deployments;
import ZMLMM::ZML_Component;
import ZMLMM::ZML_Core;

extension org::eclipse::xtend::util::stdlib::issues;
extension com::zeligsoft::domain::omg::ccm::descriptorgenerator::utils::cdpgenerator;
extension com::zeligsoft::domain::omg::ccm::descriptorgenerator::utils::util;
extension com::zeligsoft::base::zdl::util::ZDLUtil;
extension com::zeligsoft::domain::dds4ccm::utils::codeGenUtils;
extension org::eclipse::xtend::util::stdlib::globalvar;
extension org::eclipse::xtend::util::stdlib::io;

Void enableTrace(String topic) : JAVA
	com.zeligsoft.domain.ngc.ccm.descriptorgeneration.XDebugUtil.enableTrace(java.lang.String);
Void trace0(String topic, String message) :JAVA
    com.zeligsoft.domain.ngc.ccm.descriptorgeneration.XDebugUtil.trace0(java.lang.String,java.lang.String);
Void trace1(String topic, String message, Object parm) :JAVA
    com.zeligsoft.domain.ngc.ccm.descriptorgeneration.XDebugUtil.trace1(java.lang.String,java.lang.String,java.lang.Object);
Void trace2(String topic, String message, Object parm0, Object parm1) :JAVA
    com.zeligsoft.domain.ngc.ccm.descriptorgeneration.XDebugUtil.trace2(java.lang.String,java.lang.String,java.lang.Object,java.lang.Object);
	
create DeploymentPlan mainTransformAxcioma(CCM::CCM_Deployment::DeploymentPlan deployment) :
	let modelType = deployment.getModelType():
	let instances = deployment.allocation.deployed.select( e | e.modelElement.metaType.toString() == "CCM::CCM_Implementation::CCMPart") :
	let homeInstances = deployment.allocation.deployed.select( e | e.modelElement.metaType.toString() == "CCM::CCM_Implementation::HomeInstance") : 
	let connectors = deployment.part.modelElement.typeSelect(DataSpace) :
	let parts = deployment.part.modelElement.typeSelect(CCMPart):
	enableTrace("RegisterNaming") ->
	storeGlobalVar("modelType",modelType) ->
	this.label.add(deployment.zdlAsNamedElement().name) ->
	this.label.add(getPath(deployment) + deployment.zdlAsNamedElement().name) ->
	this.uuid.add(getUUID()) ->
	this.createLocalityManagerElements() ->
	// generates localityConstraints for deployed components and deployed containerProcesses 
	deployment.part.select( e | e.modelElement.metaType.toString() == "CCM::CCM_Deployment::ContainerProcess").select( e | e.isDeployed()).visitContainerProcess(this, deployment) -> // create locality constraints
	instances.visit(this, deployment) -> // create component part instances, connector instances for non-local component ports and internal connections  
	instances.visitPartForExternalConnectons(deployment, this) -> // create external connections between already created connector instances
	homeInstances.visitHome(this, deployment) ->
	connectors.createInstances(this, deployment) -> // create instances for DataSpace connector fragments
	deployment.part.select( part | part.topLevelAssembly()).select( part | part.createConnections(deployment, this, part.modelElement));

cached Boolean topLevelAssembly( DeploymentPart part ) :
	part.getParentPart() == null && part.nestedPart.size > 0 && part.modelElement.isComponent();

cached uml::Property getParentPart( DeploymentPart part ) :
	JAVA com.zeligsoft.domain.zml.util.ZDeploymentUtil.getParentPart(org.eclipse.uml2.uml.Property);

cached Boolean isComponent(CCMComponent comp ) :
	true;
	
cached Boolean isComponent(CCM::CCM_Target::Domain ele ) :
	false;	
	
Void visit(ZMLMM::ZML_Deployments::Allocation self, DeploymentPlan deployment, List[ZMLMM::ZML_Deployments::Allocation] allocations) :
	let process = self.deployedOn :
	let node = allocations.select(e|e.deployed.contains(process)).deployedOn.first() :
	self.deployed.modelElement.typeSelect(CCMPart).visit(deployment, node);

Void visitContainerProcess(DeploymentPart process, DeploymentPlan deployment, CCM::CCM_Deployment::DeploymentPlan zDeployment ) :
	createPlanLocalityConstraint(process, deployment, zDeployment);

create PlanLocality createPlanLocalityConstraint(DeploymentPart deploymentPart, DeploymentPlan deployment, CCM::CCM_Deployment::DeploymentPlan zDeployment ) :
	let containerProcessInstance = createContainerProcessInstance(deploymentPart, zDeployment) :
	deployment.localityConstraint.add(this) ->
	deployment.instance.add(containerProcessInstance) ->
	this.constraint.add(PlanLocalityKind::SameProcess) ->
	this.constrainedInstance.add(createInstanceDeploymentDescription(containerProcessInstance)); // ->
//	this.constrainedInstance.addAll(zDeployment.allocation.select(e | e.deployedOn == deploymentPart).deployed.createInstanceDeploymentDescription(deployment));
	
create InstanceDeploymentDescription createInstanceDeploymentDescription(DeploymentPart part, DeploymentPlan deployment) :
	let partSN = part.getScopedName() :
	let id = deployment.instance.selectFirst( i | i.name.first().matches(partSN)).id :
	this.JavaSetAttribute("idref", id);
	
create InstanceDeploymentDescription createInstanceDeploymentDescription(InstanceDeploymentDescription instance) :
	this.JavaSetAttribute("idref", instance.id);

create MonolithicDeploymentDescription visit(CCMComponent inst, DeploymentPlan deployment, CCM::CCM_Deployment::DeploymentPlan zDeployment) :
	let artiExec = visitArtifactExec(inst) :
	let artiSvnt = visitArtifactSvnt(inst) :
	let artiExecRef = artiExec.visitImplArtifact() :
	let artiSvntRef = artiSvnt.visitImplArtifact() :
	let process = zDeployment.allocation.selectFirst(a | a.deployed.nestedPart.modelElement.name.contains(inst.ownedPort.name.first())).deployedOn:
	let node = zDeployment.allocation.selectFirst(a | a.deployed.contains(process)).deployedOn :
	deployment.artifact.add(artiExec) ->
	deployment.artifact.add(artiSvnt) ->
	this.artifact.add(artiExecRef) ->
	this.artifact.add(artiSvntRef) ->
	this.name.add(inst.zdlAsNamedElement().name + "Impl") ->
	if( getHome(inst) == null ) then {		
		this.execParameter.add(inst.visitParam1()) ->
		this.execParameter.add(inst.visitParam2()) ->
		this.execParameter.add(inst.visitParam3()) ->
		this.execParameter.add(inst.visitParam4()) 
	} ->
	this.execParameter.add(inst.visitImplementationTypeParameter()) ->
	this.JavaSetAttribute("id", getUUID()) ->
	deployment.implementation.add(this);
	
create MonolithicDeploymentDescription visit(MonolithicImplementation inst, DeploymentPlan deployment, CCM::CCM_Deployment::DeploymentPlan zDeployment) :
	let artiExec = visitArtifactExec(inst) :
	let artiSvnt = visitArtifactSvnt(inst) :
	let artiExecRef = artiExec.visitImplArtifact() :
	let artiSvntRef = artiSvnt.visitImplArtifact() :
	deployment.artifact.add(artiExec) ->
	deployment.artifact.add(artiSvnt) ->
	this.artifact.add(artiExecRef) ->
	this.artifact.add(artiSvntRef) ->
	this.name.add(inst.zdlAsNamedElement().name + "Impl") ->
	if( getHome(inst.interface) == null) then {
		this.execParameter.add(inst.visitParam1()) ->
		this.execParameter.add(inst.visitParam2()) ->
		this.execParameter.add(inst.visitParam3()) ->
		this.execParameter.add(inst.visitParam4()) 
	} ->
	this.execParameter.add(inst.visitImplementationTypeParameter()) ->
	this.JavaSetAttribute("id", getUUID()) ->
	deployment.implementation.add(this);

create MonolithicDeploymentDescription visit(ConnectorDef inst, DeploymentPlan deployment) :
	let artiExec = visitArtifactExec(inst) :
	let artiSvnt = visitArtifactSvnt(inst) :
	let artiExecRef = artiExec.visitImplArtifact() :
	let artiSvntRef = artiSvnt.visitImplArtifact() :
	deployment.artifact.add(artiExec) ->
	deployment.artifact.add(artiSvnt) ->
	this.artifact.add(artiExecRef) ->
	this.artifact.add(artiSvntRef) ->
	this.name.add(inst.getCorbaScopedName()) ->
	this.execParameter.add(inst.visitParam1())->
	this.execParameter.add(inst.visitParam2())->
	this.execParameter.add(inst.visitParam3())->
	this.execParameter.add(inst.visitParam4())->
	this.execParameter.add(inst.visitImplementationTypeParameter()) ->
	this.JavaSetAttribute("id", getUUID()) ->
	deployment.implementation.add(this);

create MonolithicDeploymentDescription visit(Home inst, DeploymentPlan deployment, MonolithicImplementation impl) :
	let artiExec = visitArtifactExec(inst.manages.component) :
	let artiSvnt = visitArtifactSvnt(inst.manages.component) :
	let artiExecRef = artiExec.visitImplArtifact() :
	let artiSvntRef = artiSvnt.visitImplArtifact() :
	if( deployment.artifact.contains(artiExec) == false) then deployment.artifact.add(artiExec) ->
	if( deployment.artifact.contains(artiSvnt) == false) then deployment.artifact.add(artiSvnt) ->
	this.artifact.add(artiExecRef) ->
	this.artifact.add(artiSvntRef) ->
	impl != null ?
		this.name.add(impl.name + "_Home" ) :
		this.name.add(inst.zdlAsNamedElement().name + "Impl") ->
	this.execParameter.add(inst.visitParam1(impl)) ->
	this.execParameter.add(inst.visitParam2(impl)) ->
	this.execParameter.add(inst.visitParam3(impl)) ->
	this.execParameter.add(inst.visitParam4(impl)) ->
	this.execParameter.add(inst.visitImplementationTypeParameter(impl)) ->
	this.JavaSetAttribute("id", getUUID()) ->
	deployment.implementation.add(this);

create InstanceDeploymentDescription visit(DeploymentPart partDP, DeploymentPlan deployment, CCM::CCM_Deployment::DeploymentPlan zDeployment) :
	let part = partDP.modelElement:
	let comp_type = part.definition :
	let interfacePortsGeneratingFragments = comp_type.ownedPort.typeSelect(InterfacePort).select(e | e.porttype.portGeneratesFragment()) :
	let process = zDeployment.allocation.selectFirst( a | a.deployed.contains(partDP)).deployedOn :
	let node = zDeployment.allocation.selectFirst(a | a.deployed.contains(process)).deployedOn :
	let planLocality = createPlanLocalityConstraint(process, deployment, zDeployment):
	
	let id = partDP.getSelectedImplementation() == null ?
		(
			part.definition.visit(deployment, zDeployment).id
		) 
		:
		(
			partDP.getSelectedImplementation().visit(deployment, zDeployment).id
		) :	
	interfacePortsGeneratingFragments.forAll(ifp | visitPortType(ifp, deployment)) ->
	this.JavaSetAttribute("id", getUUID()) ->	
	this.name.add(partDP.getScopedName()) ->
	this.node.add(node.zdlAsNamedElement().name) ->
	this.source.add(null) ->
	this.implementation.add(id.visitInstanceImpl(this)) ->
	// trace0("RegisterNaming", "visit: BEFORE visitConfigProperty") ->
	part.definition.zdlAsComponent().member.typeSelect(CORBAAttribute).visitConfigProperty(this, partDP) ->
	// trace0("RegisterNaming", "visit: AFTER  visitConfigProperty") ->
	part.definition.zdlAsComponent().member.typeSelect(CCM::CCM_Target::Property).select(p | getModelTypeSpecificProperty("REGISTER_NAMING").matches(p.name) == false || partDP.shouldGenerateRegisterNamingTag(p)).visitConfigProperty(this, partDP) ->
	if comp_type.getHome() != null then createHomeIdProperty(this, getHomePart(zDeployment, comp_type.getHome(), partDP)) -> 
	deployment.instance.add(this) ->
	planLocality.constrainedInstance.add(partDP.createInstanceDeploymentDescription(deployment)) ->
	
	// Generate appropriate connector fragments for port-types only if certain conditions are met	
    partDP.visitPartForConnectorFragments(zDeployment, deployment); 
	
cached MonolithicImplementation getSelectedImplementation(ComponentDeploymentPart cdp ) :
	let impls = ( cdp.modelElement.definition != null ? cdp.modelElement.definition.getMonolithicImplementations() : {} ) :
	impls.size == 1 ?
		impls.first() :
		cdp.selectedImplementation;
	
cached List[emf::EObject] getMonolithicImplementations(CCMComponent comp ) :
	JAVA com.zeligsoft.domain.omg.ccm.util.CCMUtil.getMonolithicImplementationsForComponent(
		org.eclipse.emf.ecore.EObject);
	
/*
 * Retrieve the deployment part pointing to a Home given a parent part for hierarchical context.
 */
DeploymentPart getHomePart(CCM::CCM_Deployment::DeploymentPlan zDeployment, Home home, DeploymentPart componentPart ) :
	zDeployment.part.select( part | part.modelElement.isHomePart()).select(part | part.modelElement.definition == home).select( part | part.getParentPart() == componentPart.getParentPart()).selectFirst(part | part.getTargetPart() == componentPart.getTargetPart());
	
	
Void visitConfigProperty(CORBAAttribute attribute, InstanceDeploymentDescription idd, DeploymentPart part ) :
	let defaultSlots = createList(new java::lang::Object) :
	defaultSlots.addAll(findDefaultSlot(attribute, part)) ->
	if part.zdlAsProperty().defaultValue != null then
	{
		let slot = part.zdlAsProperty().defaultValue.zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst( slot | slot.definingFeature == attribute) :
		if( slot == null ) then 
		{	
			if( !defaultSlots.isEmpty ) then {
				let defaultSlot = defaultSlots.get(0) :
				defaultSlots.remove(defaultSlot) ->
				defaultSlot.visitConfigProperty(idd, defaultSlots)
			}
		} 
		else slot.visitConfigProperty(idd, defaultSlots)
	} 
	else
	{
		if( !defaultSlots.isEmpty ) then {
			let defaultSlot = defaultSlots.get(0) :
			defaultSlots.remove(defaultSlot) ->		
			defaultSlot.visitConfigProperty(idd, defaultSlots)
		}
	};
	
Void visitConfigProperty(CCM::CCM_Target::Property property, InstanceDeploymentDescription idd, DeploymentPart part ) :
	let defaultSlots = createList(new java::lang::Object) :
	// check for and prevent double add of a property.
	if(!idd.configProperty.name.exists(n | n == property.name)) then {
		defaultSlots.addAll(findDefaultSlot(property, part)) ->
		if part.zdlAsProperty().defaultValue != null then
		{
			let slot = part.zdlAsProperty().defaultValue.zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst( slot | slot.definingFeature == property) :
			if( slot == null ) then 
			{			
				if( !defaultSlots.isEmpty ) then {
					let defaultSlot = defaultSlots.get(0) :
					defaultSlots.remove(defaultSlot) ->
					defaultSlot.visitConfigProperty(idd, defaultSlots)
				}			
			} 
			else slot.visitConfigProperty(idd, defaultSlots)
		} 
		else
		{
			if( !defaultSlots.isEmpty ) then {
				let defaultSlot = defaultSlots.get(0) :
				defaultSlots.remove(defaultSlot) ->	
				defaultSlot.visitConfigProperty(idd, defaultSlots)
			}
		}->
		
		// Register naming tag must be generated even if no values set
		//
		// IF there�s no explicit RegisterNaming property set on either the CCMComponent type (default setting) 
		// OR on the instance of that type (override setting) in the deployment plan, 
		// BUT there�s a CCMConnector connection definition in the deployment assembly that 
		// connects a deployed component instance (any facet/receptacle port � just takes one) 
		// with a non-deployed component instance, then generate the register naming tag for the deployed instance.
		if(property.name == getModelTypeSpecificProperty("REGISTER_NAMING") && !idd.configProperty.name.exists(n | n == property.name)) then {
			idd.createRegisterNamingProperty(part.name)
		}
	};
	
	
create Property createHomeIdProperty(InstanceDeploymentDescription idd, DeploymentPart home) :
	idd.configProperty.add(this) ->
	this.name.add(getModelTypeSpecificProperty("COMPONENT_HOME")) ->
	this.value.add(this.createHomeIdPropertyValue(home));

create Any createHomeIdPropertyValue(Property property, DeploymentPart home ) :
	let type = new DataType :
	let value = new DataValue :
	type.kind.add(TcKind::tkString) ->
	this.type.add(type) ->
	if( home != null ) then	{ // This can happen if you have not created an instance for the managing home
		value.string.add(home.getScopedName()) ->
		this.value.add(value)
	};
	
create InstanceDeploymentDescription visitHome(DeploymentPart part, DeploymentPlan deployment, CCM::CCM_Deployment::DeploymentPlan zDeployment) :
	let comp_type = part.modelElement.definition :
	let process = zDeployment.allocation.selectFirst( a | a.deployed.contains(part)).deployedOn :
	let node = zDeployment.allocation.selectFirst(a | a.deployed.contains(process)).deployedOn :
	let componentPartImplementation = getComponentPartImplementationForHomeInstance(part, zDeployment) :
	let id = part.modelElement.definition.visit(deployment, componentPartImplementation).id :
	this.JavaSetAttribute("id", getUUID()) ->
	this.name.add(part.getScopedName()) ->
	this.node.add(node.zdlAsNamedElement().name) ->
	this.source.add(null) ->
	this.implementation.add(id.visitInstanceImpl(this)) ->
	if part.zdlAsProperty().defaultValue != null then part.zdlAsProperty().defaultValue.zdlAsInstanceValue().visitConfigProperty(this) ->
	deployment.instance.add(this);
	
MonolithicImplementation getComponentPartImplementationForHomeInstance(DeploymentPart homePart, CCM::CCM_Deployment::DeploymentPlan zDeployment ) :
	let home = homePart.modelElement.definition :
	let managedComponent = home.manages.component :
	let parentPart = homePart.getParentPart() :
	let componentPart = zDeployment.part.select( part | part.getParentPart() == parentPart).select( part | part.getTargetPart() == homePart.getTargetPart()).select( part | part.modelElement.definition == managedComponent).first() :
	componentPart.getSelectedImplementation(); 
	
Void createInstances(DataSpace dataSpace, DeploymentPlan plan, CCM::CCM_Deployment::DeploymentPlan deployment) :
	visit(dataSpace, plan, deployment, dataSpace.zdlAsProperty().eContainer);
	
Void visit(DataSpace dataSpace, DeploymentPlan plan, CCM::CCM_Deployment::DeploymentPlan deployment, AssemblyImplementation assembly ) :
	assembly.connector.select( c | c.end.zdlAsConnectorEnd().role.contains(dataSpace)).visit(dataSpace, plan, deployment, dataSpace);
	
Void visit(CCMConnector connector, DataSpace dataSpace, DeploymentPlan plan, CCM::CCM_Deployment::DeploymentPlan deployment, Object expansionObject) :
	visit(connector, dataSpace, plan, deployment, expansionObject, connector);
	
Void visit(CCMConnector connector, DataSpace dataSpace, DeploymentPlan plan, CCM::CCM_Deployment::DeploymentPlan deployment, Object expansionObject, CCMConnector origConn) :
	let compPart = connector.end.reject(e | e.partWithPort == null).partWithPort.first() :
	let deploymentTarget = deployment.allocation.select(e | e.deployed.modelElement.contains(compPart)) :
	if( deploymentTarget.size == 0) then {
		// Assembly. Iterate into the assembly and generate the instances for every connected leaf component.
		let assembly_impl = getAssembly(compPart.definition) :
		let connectedPort = connector.end.reject(e | e.partWithPort == null).port.first() :
		assembly_impl.connector.select( c | c.end.port.contains(connectedPort)).visit(dataSpace, plan, deployment, compPart, origConn) 
	}  
	else {
		// Leaf. Generate DDS4CCM fragments for every deployed instance of this part.
		let compPort = connector.end.reject(e | e.partWithPort == null).port.first() :
		let origConnPart = origConn.end.reject(e | e.partWithPort == null).partWithPort.first() : // original CCMPart in the top-level connection
		deploymentTarget.select( dt | dt.deployed.select(dep | dep.modelElement == compPart).select( part | part.hasAncestor(origConnPart)).createDDS4CCMConnectorFragmentHelper(dt.deployedOn, plan, deployment, dataSpace, compPort, origConn))
	};

/*
 * Returns true if the deploymentPart or one of its ancestors points to the CCMPart as its modelElement
 */
boolean hasAncestor(DeploymentPart possibleChild, CCMPart ancestor ) :
	possibleChild.modelElement == ancestor ? true : // base case, success
	hasAncestor(possibleChild.getParentPart(), ancestor); // recurse on parent
	
boolean hasAncestor(Void possibleChild, CCMPart ancestor ) :
	false; // if we get to a null element then the CCMPart wasn't an ancestor
		
/*
 * This method uses a lazy form of filtering instead of the dispatch mechanism used by "create". This is necessary to create the
 * connections correctly.
 * It is therefore up to the previous callstack to make sure it's iterating through assemblies properly.
 */
Void createDDS4CCMConnectorFragmentHelper(DeploymentPart source, DeploymentPart target, DeploymentPlan plan, CCM::CCM_Deployment::DeploymentPlan deployment, DataSpace dataSpace, InterfacePort sourcePort, CCMConnector origConn ) :
	let fragmentInstance = createDDS4CCMConnectorFragmentHelper(source, target, plan, deployment, dataSpace ) :
	let sourceSN = source.getScopedName() : 
	let compInstance = plan.instance.selectFirst( i | i.name.first().matches(sourceSN)) :
		
	// For the DDS Connector that connects them, for each provides and requires, create a connection where one endpoint is
	// the facet/recept on the component, and the other is the connector fragment we just created.
	// source is the component we are connecting to. 
	createConnectionsForDDS4CCMConnectorFragment(plan, sourcePort, compInstance, fragmentInstance, dataSpace, sourcePort.porttype, origConn);
	

create InstanceDeploymentDescription createDDS4CCMConnectorFragmentHelper(DeploymentPart source, DeploymentPart target, DeploymentPlan plan, CCM::CCM_Deployment::DeploymentPlan deployment, DataSpace dataSpace ) :
	let node = deployment.allocation.selectFirst(e | e.deployed.contains(target)).deployedOn :
	let idd = this : 
	let dataSpaceSN = dataSpace.connectorType.getCorbaScopedName() :
	let id = visit(dataSpace.connectorType, plan).id :
	let dataSpaceDP = deployment.part.select( part | part.modelElement == dataSpace).selectFirst( part | part.sameLocalAssembly(source)) :
	idd.JavaSetAttribute("id", getUUID()) ->
	idd.name.add(dataSpace.getScopedName() + "_to_" + source.name + "@" + node.name + "." + target.name) ->
	idd.node.add(node.name) ->
	idd.source.add(null) ->
	idd.implementation.add(id.visitInstanceImpl(idd)) ->
	dataSpace.connectorType.zdlAsComponent().member.typeSelect(CORBAAttribute).visitDataSpaceProperty(idd, getPerPortDP(source, dataSpace, deployment), dataSpaceDP) ->
	dataSpace.connectorType.zdlAsComponent().member.typeSelect(InterfacePort).visitDataSpaceProperty(idd, getPerPortDP(source, dataSpace, deployment), dataSpaceDP) ->
	plan.instance.add(idd) ->
	addInstanceToLocalityConstraint(
		idd, 
		plan, 
		deployment.allocation.selectFirst(e | e.deployedOn == target).deployed.selectFirst(e | e.modelElement.isComponentPart())
	);
	
boolean sameLocalAssembly(DeploymentPart dataSpaceDP, DeploymentPart componentDP ) :
	JAVA com.zeligsoft.domain.idl3plus.utils.IDL3PlusXtendUtils.sameLocalAssembly(
		org.eclipse.uml2.uml.Property,
		org.eclipse.uml2.uml.Property);

DeploymentPart getPerPortDP(DeploymentPart part , DataSpace dataSpace, CCM::CCM_Deployment::DeploymentPlan deployment) :
	JAVA com.zeligsoft.domain.idl3plus.utils.IDL3PlusXtendUtils.getPerPortDP(org.eclipse.uml2.uml.Property, org.eclipse.uml2.uml.Property, org.eclipse.uml2.uml.Component);

/*
 * For an attribute on a dataspace, check if the deployment part has
 * a slot containing an overridden value for it. If it does not, find
 * the default value slot for the attribute on the ConnectorDefaultValueBinding.
 * If one is found, pass that slot on instead.
 */
Void visitDataSpaceProperty(CORBAAttribute attribute, InstanceDeploymentDescription idd, DeploymentPart perPort, DeploymentPart dataSpace) :
	let defaultSlots = createList(new java::lang::Object) :
	defaultSlots.addAll(findDefaultSlot(attribute, dataSpace)) ->
	if (perPort != null && perPort.zdlAsProperty().defaultValue != null && perPort.zdlAsProperty().defaultValue.zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst( slot | slot.definingFeature == attribute) != null) then
	{
		let slot = perPort.zdlAsProperty().defaultValue.zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst( slot | slot.definingFeature == attribute) :
		slot.visitConfigProperty(idd, defaultSlots)
	}
	else if (dataSpace.zdlAsProperty().defaultValue != null) then
	{
		let slot = dataSpace.zdlAsProperty().defaultValue.zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst( slot | slot.definingFeature == attribute) :
		if( slot == null ) then 
		{
			if( !defaultSlots.isEmpty ) then {
				let defaultSlot = defaultSlots.get(0) :
				defaultSlots.remove(defaultSlot) ->
				defaultSlot.visitConfigProperty(idd, defaultSlots)
			}	
		} 
		else slot.visitConfigProperty(idd, defaultSlots)
	} 
	else
	{
		if( !defaultSlots.isEmpty ) then {
				let defaultSlot = defaultSlots.get(0) :
				defaultSlots.remove(defaultSlot) ->
				defaultSlot.visitConfigProperty(idd, defaultSlots)
		}
	};
	
Void visitDataSpaceProperty(InterfacePort port, InstanceDeploymentDescription idd, DeploymentPart perPort, DeploymentPart dataSpace) :
	port.porttype.ownedAttribute.visitDataSpaceProperty(port, idd, perPort, dataSpace);
	
Void visitDataSpaceProperty(CORBAAttribute attribute, InterfacePort port, InstanceDeploymentDescription idd, DeploymentPart perPort, DeploymentPart dataSpace ) :
	if(perPort != null && perPort.zdlAsProperty().defaultValue != null && perPort.zdlAsProperty().defaultValue.zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst( slot | slot.definingFeature == port) != null) then
	{
		let defaultSlots = createList(new java::lang::Object) :
		let slot2 = perPort.zdlAsProperty().defaultValue.zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst( slot | slot.definingFeature == port).value.first().zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst( slot | slot.definingFeature == attribute) :
		defaultSlots.addAll(findDefaultSlot(attribute, port, dataSpace)) ->
		slot2.visitConfigProperty(idd, defaultSlots).addPortPrefix(port)
	}
	else if dataSpace.zdlAsProperty().defaultValue != null then
	{
		let slot = dataSpace.zdlAsProperty().defaultValue.zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst
			( slot | slot.definingFeature == port) :
		let defaultSlots = createList(new java::lang::Object) :
		defaultSlots.addAll(findDefaultSlot(attribute, port, dataSpace)) ->
		if( slot == null ) then 
		{
			if( !defaultSlots.isEmpty ) then {
				let defaultSlot = defaultSlots.get(0) :
				defaultSlots.remove(defaultSlot) ->
				defaultSlot.visitConfigProperty(idd, defaultSlots).addPortPrefix(port)
			}	
		} 
		else 
		{
			let slot2 = slot.value.first().zdlAsInstanceValue().instance.zdlAsInstanceSpecification().slot.selectFirst( slot | slot.definingFeature == attribute) :
			slot2.visitConfigProperty(idd, defaultSlots).addPortPrefix(port)
		} 
	} 
	else
	{
		let defaultSlots = createList(new java::lang::Object) :
		defaultSlots.addAll(findDefaultSlot(attribute, dataSpace)) ->
		if( !defaultSlots.isEmpty ) then {
				let defaultSlot = defaultSlots.get(0) :
				defaultSlots.remove(defaultSlot) ->
				defaultSlot.visitConfigProperty(idd, defaultSlots).addPortPrefix(port)
		}
	};

Void addPortPrefix(Property prop, InterfacePort port ) :
	let genName = prop.name.first() :
	prop.name.remove(prop.name.first()) ->
	prop.name.add(port.name + "_" + genName);

cached List[uml::Slot] findDefaultSlot(CCM::CCM_Target::Property property, DeploymentPart part ) :
	JAVA com.zeligsoft.domain.idl3plus.utils.IDL3PlusXtendUtils.findDefaultSlot(
		org.eclipse.uml2.uml.Property,
		org.eclipse.uml2.uml.Property);
			
cached List[uml::Slot] findDefaultSlot(CORBAAttribute attribute, DeploymentPart dataSpace) :
	JAVA com.zeligsoft.domain.idl3plus.utils.IDL3PlusXtendUtils.findDefaultSlot(
		org.eclipse.uml2.uml.Property,
		org.eclipse.uml2.uml.Property);
		
cached List[uml::Slot] findDefaultSlot(CORBAAttribute attribute, InterfacePort port, DeploymentPart dataSpace) :
	JAVA com.zeligsoft.domain.idl3plus.utils.IDL3PlusXtendUtils.findDefaultSlot(
		org.eclipse.uml2.uml.Property,
		org.eclipse.uml2.uml.Property,
		org.eclipse.uml2.uml.Property);	

Void createConnectionsForDDS4CCMConnectorFragment(DeploymentPlan plan, InterfacePort sourcePort, InstanceDeploymentDescription compInstance, InstanceDeploymentDescription fragmentInstance, DataSpace dataSpace, ExtendedPortType porttype, CCMConnector origConn) :
	let prefix = dataSpace.connectorType.zdlAsComponent().member.typeSelect(InterfacePort).selectFirst( p | p.type == sourcePort.type).name : 
	plan.connection.addAll(porttype.zdlAsClass().clientDependency.createDDS4CCMConnection(sourcePort, compInstance, fragmentInstance, dataSpace, prefix));
	
Void createConnectionsForDDS4CCMConnectorFragment(DeploymentPlan plan, InterfacePort sourcePort, InstanceDeploymentDescription compInstance, InstanceDeploymentDescription fragmentInstance, DataSpace dataSpace, ExtendedPortType porttype, ConnectorStatusListenerConnection origConn) :
	let prefix = dataSpace.connectorType.zdlAsComponent().member.typeSelect(InterfacePort).selectFirst( p | p.type == sourcePort.type).name : 
	plan.connection.addAll(porttype.zdlAsClass().clientDependency.createDDS4CCMConnection(sourcePort, compInstance, fragmentInstance, dataSpace, prefix)) ->
	sourcePort.hasCSL ?
		createStatusListenerConnection(plan, sourcePort, compInstance, fragmentInstance, dataSpace, origConn) :
		{};

create PlanConnectionDescription createConnectionsForDDS4CCMConnectorFragment(DeploymentPlan plan, InterfacePort sourcePort, InstanceDeploymentDescription compInstance, InstanceDeploymentDescription fragmentInstance, DataSpace dataSpace, CORBAInterface porttype, CCMConnector origConn) :
	let prefix = dataSpace.connectorType.zdlAsComponent().member.typeSelect(InterfacePort).selectFirst( p | p.type == porttype).name :
	this.name.add(compInstance.name.first() + "." + sourcePort.name + "::" + fragmentInstance.name.first() + "." + prefix + "_" + porttype.name) ->
	this.createEndPoint(!(sourcePort.isConjugated), false, sourcePort.name, compInstance) ->
	this.createEndPoint((sourcePort.isConjugated), false, prefix, fragmentInstance) ->
	plan.connection.add(this);	

create PlanConnectionDescription createConnectionsForDDS4CCMConnectorFragment(DeploymentPlan plan, InterfacePort sourcePort, InstanceDeploymentDescription compInstance, InstanceDeploymentDescription fragmentInstance, DataSpace dataSpace, CORBAInterface porttype, ConnectorStatusListenerConnection origConn) :
	let prefix = dataSpace.connectorType.zdlAsComponent().member.typeSelect(InterfacePort).selectFirst( p | p.type == porttype).name :
	this.name.add(compInstance.name.first() + "." + sourcePort.name + "::" + fragmentInstance.name.first() + "." + prefix + "_" + porttype.name) ->
	this.createEndPoint(!(sourcePort.isConjugated), false, sourcePort.name, compInstance) ->
	this.createEndPoint((sourcePort.isConjugated), false, prefix, fragmentInstance) ->
	plan.connection.add(this) ->
	sourcePort.hasCSL ?
		createStatusListenerConnection(plan, sourcePort, compInstance, fragmentInstance, dataSpace, origConn ) :
		{};

create PlanConnectionDescription createStatusListenerConnection(DeploymentPlan plan, InterfacePort sourcePort, InstanceDeploymentDescription compInstance, InstanceDeploymentDescription fragmentInstance, DataSpace dataSpace, ConnectorStatusListenerConnection origConn)  :
	let prefix = dataSpace.connectorType.zdlAsComponent().member.typeSelect(InterfacePort).selectFirst( p | p.type == porttype).name :
	this.name.add(compInstance.name.first() + "." + sourcePort.name + "_CSL::" + fragmentInstance.name.first() + "_" + "ConnectorStatusListener") ->
	this.createEndPoint(!(sourcePort.isConjugated), false, sourcePort.name + "_CSL", compInstance) ->
	this.createEndPoint((sourcePort.isConjugated), false, "error_listener", fragmentInstance) ->
	plan.connection.add(this);

create PlanConnectionDescription createDDS4CCMConnection(NamedElement dep, InterfacePort sourcePort, InstanceDeploymentDescription compInstance, InstanceDeploymentDescription fragmentInstance, DataSpace dataSpace, String prefix ) :
	this.name.add(compInstance.name.first() + "." + sourcePort.name + "::" + fragmentInstance.name.first() + "." + prefix + "_" + dep.name) ->
	// I have to check the type of dep this way because it's always a ZML Named Element, so metaType won't work.
	if dep.toString().startsWith("org.eclipse.uml2.uml.internal.impl.UsageImpl") then 
	{
		this.createEndPoint((sourcePort.isConjugated), false, sourcePort.name + "_" + dep.name, compInstance) ->
		this.createEndPoint(!(sourcePort.isConjugated), false, prefix + "_" + dep.name, fragmentInstance)
	} 
	else
	{
		this.createEndPoint(!(sourcePort.isConjugated), false, sourcePort.name + "_" + dep.name, compInstance) ->
		this.createEndPoint((sourcePort.isConjugated), false, prefix + "_" + dep.name, fragmentInstance)
	};
			
Void addInstanceToLocalityConstraint(InstanceDeploymentDescription instance, DeploymentPlan plan, DeploymentPart deployedComp) :
	let deployedCompSN = deployedComp.getScopedName() :
	let compInstanceId = plan.instance.selectFirst( i | i.name.first() == deployedCompSN).id :
	let planLocality = plan.localityConstraint.selectFirst( s | s.constrainedInstance.idref.contains(compInstanceId)) :
	
	planLocality.constrainedInstance.add(createInstanceRef(instance, planLocality));

create InstanceDeploymentDescription createInstanceRef(InstanceDeploymentDescription instance, Object obj) :
	this.JavaSetAttribute("idref", instance.id);
	
cached String getConnectorImplementationID(CORBAInterface intf, String portConnectorType, DeploymentPlan plan):
	plan.implementation.selectFirst(e | e.name.first() == intf.getConnectorName(portConnectorType)).id;
	

/*
 * Get implementation name of a connectorType for the given interface
 */
cached String getConnectorName(CORBAInterface intf, String portConnectorType):
	let connectorName = {}:
	{if (portConnectorType == "AMI4CCM_Connector") then {
		connectorName.add(intf.getCorbaScopedName() + "_AMI_Connector")    
	} else if (portConnectorType == "CORBA4CCM_Connector") then {
	    connectorName.add(intf.getCorbaScopedName() + "_SRR_CORBA_Connector")
	}} ->
	connectorName.first();
			

/*
 * Create register naming property with given value	
 */
create Property createRegisterNamingProperty(InstanceDeploymentDescription idd, String val ) :
	this.name.add(getModelTypeSpecificProperty("REGISTER_NAMING")) ->
	this.value.add(this.createRegisterNamingProperty(val)) ->
	idd.configProperty.add(this);

create Any createRegisterNamingProperty(Property property, String val ) :
	let type = new DataType :
	let value = new DataValue :
	type.kind.add(TcKind::tkString) ->
	this.type.add(type) ->
	value.string.add(val) ->
	this.value.add(value);

/*
* Depending on the given connectorType, return corresponding 'provides' port name
*/
cached List[String] getConnectorProvidesPortName(InterfacePort port):
	let connectorType = port.connectorType.name:
	let portName = {}:
	{if(connectorType == "AMI4CCM_Connector") then{
		portName.add("ami4ccm_port_ami4ccm_provides") ->
		portName.add("ami4ccm_port_ami4ccm_sync_provides")
	}else if(connectorType == "CORBA4CCM_Connector") then{
		portName.add("srr_facet")
	}else{
	// this should never be entered given we pass a valid connectorType
		portName.add("")
	}} ->
	portName;

/*
* Depending on the given connectorType, return corresponding 'uses' port name
*/
cached String getConnectorUsesPortName(InterfacePort port):
	usesPortName(port.connectorType);

cached String syncProvidesPortName(ComponentInterface connectorDef) :
    connectorDef.name == "AMI4CCM_Connector" 
        ? "ami4ccm_port_ami4ccm_sync_provides"
        : "srr_facet";

cached String asyncProvidesPortName(ComponentInterface connectorDef) :
    connectorDef.name == "AMI4CCM_Connector" 
        ? "ami4ccm_port_ami4ccm_provides"
        : "<error:no async provides for " + connectorDef.name + ">"; 

cached String usesPortName(ComponentInterface connectorDef) :
    connectorDef.name == "AMI4CCM_Connector" 
        ? "ami4ccm_port_ami4ccm_uses"
        : "srr_receptacle";

create PlanConnectionDescription findOrCreateClientSideSyncConnection(
        ComponentDeploymentPart clientCompDP, InterfacePort receptacle,
        ComponentDeploymentPart serverCompDP, InterfacePort facet,
        DeploymentPlan plan
    ) :
    // Ideal world:
    //   let clientCompInst = findOrCreateComponentInstance(clientCompDP, plan) :
    // Real world: we have not easily reused 'create' function, so we 'know' what visit(DeploymentPart, ...) does.
    let clientCompInst = plan.instance.selectFirst( i | i.name.first().matches(clientCompDP.getScopedName())) :
    let connectorInstance = findOrCreateClientSideConnectorFragment(clientCompDP, receptacle, serverCompDP, facet, plan ) :
    let connectorPortName = receptacle.connectorType.syncProvidesPortName() :

    trace0("Connection", "Entering findOrCreateClientSideSyncConnection") ->
    trace2("Connection", "Client %s.%s", clientCompDP.name, receptacle.name) ->
    trace2("Connection", "Server %s.%s", serverCompDP.name, facet.name) ->

    this.name.add(clientCompInst.name.first() + "." + receptacle.name 
        + "::" + connectorInstance.name.first() + "." + connectorPortName) ->
    this.createEndPoint(false, true, receptacle.name, clientCompInst) ->
    this.createEndPoint(true, false, connectorPortName, connectorInstance) ->
    
    trace1("Connection", "ClientSide Sync %s", this.name) ->
    
    plan.connection.add(this);

create PlanConnectionDescription findOrCreateClientSideAsyncConnection(
        ComponentDeploymentPart clientCompDP, InterfacePort receptacle,
        ComponentDeploymentPart serverCompDP, InterfacePort facet,
        DeploymentPlan plan
    ) :
    // Ideal world:
    //   let clientCompInst = findOrCreateComponentInstance(clientCompDP, plan) :
    // Real world: we have not easily reused 'create' function, so we 'know' what visit(DeploymentPart, ...) does.
    let clientCompInst = plan.instance.selectFirst( i | i.name.first().matches(clientCompDP.getScopedName())) :
    let connectorInstance = findOrCreateClientSideConnectorFragment(clientCompDP, receptacle, serverCompDP, facet, plan ) :
    let connectorPortName = receptacle.connectorType.asyncProvidesPortName() :

    trace0("Connection", "Entering findOrCreateClientSideAsyncConnection") ->

    this.name.add( clientCompInst.name.first() + "." + receptacle.name 
        + "::" + connectorInstance.name.first() + "." + connectorPortName) ->
    this.createEndPoint(false, false, "sendc_" + receptacle.name, clientCompInst) ->
    this.createEndPoint(true, false, connectorPortName, connectorInstance) ->

    trace1("Connection", "ClientSide ASync %s", this.name) ->
    
    plan.connection.add(this);
	
create PlanSubcomponentPortEndpoint createEndPoint(PlanConnectionDescription conn, Boolean provides, Boolean multiple, String portName, InstanceDeploymentDescription instance ) :
	this.portName.add(portName) ->
	this.kind.add(provides ? CcmComponentPortKind::Facet : 
		(multiple ? CcmComponentPortKind::MultiplexReceptacle : CcmComponentPortKind::SimplexReceptacle)
	) ->
	this.provider.add( provides ? "true" : "false" ) ->
	this.instance.add(createInstanceRef(instance, this)) ->
	conn.internalEndpoint.add(this);

/*
 * Create an external reference to an AMI4CCM connector fragment.
 * The other endpoint is always a facet.
 */
create ExternalReferenceEndpoint createExternalEndPoint(PlanConnectionDescription connDescription, String connFragmentName, InterfacePort contextPort, DeploymentPart contextPartDP) :
	let location = getLocationPrefix(contextPartDP) :
	this.location.add((location != null && location != "" ? location : "corbaname:rir:/NameService#") + connFragmentName ) ->
		
	{if(contextPort.isConjugated) then{
		this.provider.add( "false" ) ->
		this.portName.add(contextPort.getConnectorUsesPortName())
		
	}else{
	//	let portConnectorType = contextPort.connectorType.name :
		this.provider.add( "true" ) ->
		this.portName.add(contextPort.getConnectorProvidesPortName().first())
	}} ->
	
	this.supportedType.add("Meaningless") ->
	connDescription.externalReference.add(this);
	
/*
 * Axcioma: Connection between srr_receptacle and facet. Both in server side 
 */	
create PlanConnectionDescription createServerSideConnection(InstanceDeploymentDescription srrInstance, 
		DeploymentPart facetPart, InterfacePort facet, DeploymentPlan plan):
	let facetSN = facetPart.getScopedName() :
	let compInstance = plan.instance.selectFirst( i | i.name.first().matches(facetSN)) :
	let portNameOfConnectorInstance = getConnectorUsesPortName(facet):
	
	this.name.add(facetSN + "." + facet.name + "::" + srrInstance.name.first() + "." + portNameOfConnectorInstance) ->
	this.createEndPoint(true, false, facet.name, compInstance) ->
	this.createEndPoint(false, false, portNameOfConnectorInstance, srrInstance);		

cached boolean isComponentPart(CCMPart part) :
	true;
	
cached boolean isComponentPart(NamedElement element) :
	false;

cached boolean isHomePart(HomeInstance part ) :
	true;
	
cached boolean isHomePart(NamedElement part ) :
	false;
	
/**
 * External connection generation
 */
Void visitPartForExternalConnectons(DeploymentPart partDP, CCM::CCM_Deployment::DeploymentPlan zDeployment, DeploymentPlan plan) :
	let part = partDP.modelElement:
	let portsForGeneration = clientSideInterfacePorts(part):
	portsForGeneration.select(port| visitPortForExternalConnectons(partDP, port, zDeployment, plan));

Void visitPortForExternalConnectons(DeploymentPart partDP, InterfacePort port, CCM::CCM_Deployment::DeploymentPlan deployment, DeploymentPlan plan) : 
	let terminalConnectedPortDP = getTerminalConnectedPortDP(port, partDP, deployment):
	terminalConnectedPortDP.select(tce| visitPortForExternalConnectons(partDP, port, tce.getParentPart(), tce.modelElement, deployment, plan));

cached Allocation getDeploymentTarget(CCM::CCM_Deployment::DeploymentPlan deployment, CCMPart part):
	deployment.allocation.select( e | e.deployed.modelElement.contains( part ));

// Assumption: 'port' for which the method is called for from another method is a terminal port as well 
cached List[DeploymentPart] getTerminalConnectedPortDP(InterfacePort port, DeploymentPart partDP, CCM::CCM_Deployment::DeploymentPlan zDeployment):
	let terminalConnectedPortDP = {}:
	let part = partDP.modelElement:
	
	if (part.isPortConnectedInOwnerAssemblyOfPart(port)) then{
		// Get the set of all connectors that are connected to this port
		let portConnectors = part.zdlAsProperty().owner.connector.select( c | c.end.exists(ce | (ce.port == port) && (ce.partWithPort == part))) :
		let portConnectorsAssembly = portConnectors.select(pc| isAssemblyConnector(pc)) :
		let portConnectorsDelegation = portConnectors.select(pc| isDelegationConnector(pc)) :
		
		// get the set of connected ports in those connections.
		let connectedCEAssembly = portConnectorsAssembly.end.reject(e| e.port == port) :
		let connectedCEDelegation = portConnectorsDelegation.end.reject(e| e.port == port) :
		
		if (connectedCEAssembly.size > 0) then{	
			connectedCEAssembly.select(ca_ce | terminalConnectedPortDP.addAll(getTerminalConnectedPortHelperDP(partDP.getParentPart(), ca_ce)))
		} ->
		if (connectedCEDelegation.size > 0) then{
			connectedCEDelegation.select(ce| terminalConnectedPortDP.addAll(ce.port.getTerminalConnectedPortDP(partDP.getParentPart(), zDeployment))) 
		}
	} ->
	terminalConnectedPortDP;

cached Boolean isPortConnectedInOwnerAssemblyOfPart(CCMPart part, InterfacePort port):
	part.zdlAsProperty().owner.connector.end.port.contains(port);
	
cached getPossibleConnectedPorts(ConnectorEnd connectedCE, InterfacePort port):
	connectedCE.partWithPort.zdlAsProperty().owner.part.definition.typeSelect(CCMComponent).ownedPort.select( zport | zport.isConjugated != port.isConjugated).select(zport | zport.porttype == port.porttype);
			
cached List[DeploymentPart] getTerminalConnectedPortHelperDP(DeploymentPart containerPartDP, ConnectorEnd connectedCEAssembly):
	let terminalConnectedPortDP = {}:
	let assembly_impl = getAssembly(connectedCEAssembly.partWithPort.definition) :
	let partDP = containerPartDP.nestedPart.select( np | np.modelElement == connectedCEAssembly.partWithPort).first():
	
	{if(assembly_impl.size == 0) then{
		// Filter out the external ports by taking the intersection of the possible connected ports and the connected assembly ports.
		let portDP = partDP.nestedPart.select( np | np.modelElement == connectedCEAssembly.port).first():
		
		terminalConnectedPortDP.add(portDP)
	}else{	// delegation exists in the connected part
		
		let connectedCEInDelegation = assembly_impl.connector.select(c| c.end.port.contains(connectedCEAssembly.port)).end.reject( e | e.port == connectedCEAssembly.port):		
		connectedCEInDelegation.select(ce_de| terminalConnectedPortDP.addAll(getTerminalConnectedPortHelperDP(partDP, ce_de)))
	}} ->
	terminalConnectedPortDP;

Void visitPortForExternalConnectons(DeploymentPart partDP, InterfacePort port, DeploymentPart connectedPartDP, InterfacePort connectedPort, CCM::CCM_Deployment::DeploymentPlan deployment, DeploymentPlan plan) :	
	
	let receptPartDP = {}:
	let receptacle = {}:
	let facetPartDP = {}:
	let facet = {}:
	
	trace0("Connection", "Entering visitPortForExternalConnectons") ->
	trace2("Connection", "partDP(port) = %s(%s)", partDP.name, port.name) ->
	trace2("Connection", "connectedPartDP(connectedPort) = %s(%s)", connectedPartDP.name, connectedPort.name) ->
	
	{if(port.isConjugated) then{
		receptPartDP.add(partDP) ->
		receptacle.add(port) ->
		facetPartDP.add(connectedPartDP) ->
		facet.add(connectedPort)
	}else{
		receptPartDP.add(connectedPartDP) ->
		receptacle.add(connectedPort) ->
		facetPartDP.add(partDP) ->
		facet.add(port)
	}} ->	

    trace2("Connection", "receptPartDP(receptacle) = %s(%s)", receptPartDP.first().name, receptacle.first().name) ->
    trace2("Connection", "facetPartDP(facet) = %s(%s)", facetPartDP.first().name, facet.first().name) ->
	
	// generate external connection only if 'receptPartDP' is deployed
	if(receptPartDP.first().isDeployed() && facetPartDP.first().isDeployed()) then{
		createClientServerConnection(receptPartDP.first(), receptacle.first(), facetPartDP.first(), facet.first(), deployment, plan)
	} else if(receptPartDP.first().isDeployed()) then {
        createClientConnectionToExternalServer(receptPartDP.first(), receptacle.first(), facetPartDP.first(), facet.first(), deployment, plan)
	} ->
	
	trace0("Connection", "Exiting visitPortForExternalConnectons")
	;
	
	
// return connetorInstance corresponding to the 'port' owned by the 'part' 	
cached InstanceDeploymentDescription getConnectorInstance(DeploymentPart partDP, InterfacePort port, CCM::CCM_Deployment::DeploymentPlan deployment, DeploymentPlan plan):
	let connectorFragmentSN = partDP.getConnectorFragmentScopedName(port):
	plan.instance.selectFirst( i | i.name.first().matches(connectorFragmentSN));

create PlanConnectionDescription createClientConnectionToExternalServer(
        DeploymentPart clientCompDP, InterfacePort receptacle, 
        DeploymentPart serverCompDP, InterfacePort facet, 
        CCM::CCM_Deployment::DeploymentPlan deployment, DeploymentPlan plan) :
    
    let receptacleConnectorInstance = findOrCreateClientSideConnectorFragment(clientCompDP, receptacle, serverCompDP, facet, plan):
    let rConnectorType = receptacle.connectorType.name:
    let fConnectorType = facet.connectorType.name:
    
    trace0("Connection", "Entering createClientConnectionToExternalServer") ->

    this.name.add(clientCompDP.getScopedName() + "." + receptacle.name + '_' + rConnectorType + "__" + serverCompDP.getScopedName() + "." + facet.name + "_" + fConnectorType  
            + (receptacle.isUsedSynchronously()? "_syncdirect" : "_asyncdirect")) ->
    this.createEndPoint(false, false, getConnectorUsesPortName(receptacle), receptacleConnectorInstance) ->
    this.createExternalEndPoint(getRegisterNamingPropertyVal(serverCompDP, facet), facet, serverCompDP) ->
    plan.connection.add(this) ->
    
    trace1("Connection", "Client to external Server: %s", this.name) ->
    this;

create PlanConnectionDescription createClientServerConnection(
        DeploymentPart clientCompDP, InterfacePort receptacle, 
        DeploymentPart serverCompDP, InterfacePort facet, 
        CCM::CCM_Deployment::DeploymentPlan deployment, DeploymentPlan plan) :
	
	let receptacleConnectorInstance = findOrCreateClientSideConnectorFragment(clientCompDP, receptacle, serverCompDP, facet, plan):
	let facetConnectorInstance = findOrCreateServerSideConnectorFragment(serverCompDP, facet, deployment, plan):
	let rConnectorType = receptacle.connectorType.name:
	let fConnectorType = facet.connectorType.name:
	
	trace0("Connection", "Entering createClientServerConnection") ->
    this.name.add(receptacleConnectorInstance.name.first() + "." + getConnectorUsesPortName(receptacle) + "::" + 
		facetConnectorInstance.name.first() + "." + getConnectorProvidesPortName(facet).first()) ->
	this.createEndPoint(false, false, getConnectorUsesPortName(receptacle), receptacleConnectorInstance) ->
	this.createEndPoint(true, false, getConnectorProvidesPortName(facet).first(), facetConnectorInstance)->
	plan.connection.add(this) ->
	
	trace1("Connection", "Client Server: %s", this.name) ->
	this;

Void visitPartForConnectorFragments(DeploymentPart partDP, CCM::CCM_Deployment::DeploymentPlan zDeployment, DeploymentPlan plan) :
	let part = partDP.modelElement:
	let portsForGeneration = serverSideInterfacePorts(part):
	portsForGeneration.select(port| visitPortForConnectorFragments(partDP, port, zDeployment, plan));

Void visitPortForConnectorFragments(DeploymentPart partDP, InterfacePort port, CCM::CCM_Deployment::DeploymentPlan deployment, DeploymentPlan plan) :
	let part = partDP.modelElement:
	let component = part.definition :
	let assembly_impl = getAssembly(component) :
	
	trace0("Connectors", "Entering visitPortForConnectorFragments") ->
	if( assembly_impl.size > 0 ) then {	
		let delegationConnectorEnd = assembly_impl.connector.select( c | c.end.port.contains(port)).end.reject( c | c.port == port ) :
		// Recursive call with new values for part and port, and same values for everything else.
		delegationConnectorEnd.select(
			dce | visitPortForConnectorFragments(partDP.nestedPart.select( np | np.modelElement == dce.partWithPort).first(), dce.port, deployment, plan ))
	}else if(!port.isConjugated) then {
		partDP.findOrCreateServerSideConnectorFragment(port, deployment, plan)
	}
    -> trace0("Connectors", "Exiting visitPortForConnectorFragments")
	;

cached List[InterfacePort] serverSideInterfacePorts(CCMPart partForComponent):
    partForComponent.definition.ownedPort.typeSelect(InterfacePort)
        .select(ip | ip.porttype.portGeneratesFragment() && !ip.isConjugated);

cached List[InterfacePort] clientSideInterfacePorts(CCMPart partForComponent):
    partForComponent.definition.ownedPort.typeSelect(InterfacePort)
        .select(ip | ip.porttype.portGeneratesFragment() && ip.isConjugated);


create InstanceDeploymentDescription findOrCreateServerSideConnectorFragment(DeploymentPart partDP, InterfacePort port, CCM::CCM_Deployment::DeploymentPlan deployment, DeploymentPlan plan) :
	let portConnectorType = port.connectorType.name:
	let target = deployment.allocation.selectFirst(e | e.deployed.contains(partDP)).deployedOn :
	let node = deployment.allocation.selectFirst(e | e.deployed.contains(target)).deployedOn :
	let name = partDP.getConnectorFragmentScopedName(port) :	//partDP.getScopedName() + "." + port.porttype.name:
	let id = port.porttype.getConnectorImplementationID(portConnectorType, plan):
	
	this.JavaSetAttribute("id", getUUID()) ->
	this.name.add(name) ->
	this.node.add(node.name) ->
	this.source.add(null) ->
	this.implementation.add(id.visitInstanceImpl(this)) ->
	plan.instance.add(this) ->
	
	plan.connection.add(this.createServerSideConnection(partDP, port, plan))	
	->
	
	if(existsUndeployedConnectedPart(partDP, port, deployment)) then{
		this.createRegisterNamingProperty(getRegisterNamingPropertyVal(partDP, port))
	} ->
	
    trace1("Connectors", "ServerSide %s", this.name) ->
    
	addInstanceToLocalityConstraint(this, plan, partDP);


create InstanceDeploymentDescription findOrCreateClientSideConnectorFragment(
        DeploymentPart clientCompDP, InterfacePort receptacle,
        DeploymentPart serverCompDP, InterfacePort facet,
        DeploymentPlan plan ) :
    let clientProcessDP = getTargetPart(clientCompDP):
    let portConnectorType = facet.connectorType.name:
    let node = getTargetPart(clientProcessDP) :
    let name = clientCompDP.getScopedName() + "." + receptacle.name
          + "_" + receptacle.connectorType.name + "_for_"
          + serverCompDP.getScopedName() + "." + facet.name :
    let id = findOrCreateInterfacePortConnector(receptacle.porttype, receptacle.connectorType, plan).id:
    
    trace0("Connectors", "Entering findOrCreateClientSideConnectorFragment") ->
    trace2("Connectors", "client/recept for %s/%s", clientCompDP.name, receptacle.name)->
    trace2("Connectors", "server/facet for %s/%s", serverCompDP.name, facet.name)->
    trace2("Connectors", "process/node %s/%s", clientProcessDP.name, node.name)->
    this.JavaSetAttribute("id", getUUID()) ->
    this.name.add(name) ->
    this.node.add(node.name) ->
    this.source.add(null) ->
    this.implementation.add(id.visitInstanceImpl(this)) ->
    plan.instance.add(this) ->
    
    /// depending on the synchronous/asynchronous capability of the port in addition to the conjugation status, create different types of connections
    
    if(receptacle.isUsedAsynchronously()) then {
        findOrCreateClientSideAsyncConnection(clientCompDP, receptacle, serverCompDP, facet, plan)
    } ->
    findOrCreateClientSideSyncConnection(clientCompDP, receptacle, serverCompDP, facet, plan) ->
    
    if(existsUndeployedConnectedPart(clientCompDP, facet, deployment)) then{
        this.createRegisterNamingProperty(getRegisterNamingPropertyVal(clientCompDP, facet))
    } ->
    
    trace1("Connectors", "ClientSide %s", this.name) ->
    
    addInstanceToLocalityConstraint(this, plan, clientCompDP);
	
cached String getRegisterNamingPropertyVal(DeploymentPart partDP, InterfacePort port):
	partDP.name + "_" + port.name;
	
cached Boolean existsUndeployedConnectedPart(DeploymentPart partDP, InterfacePort port, CCM::CCM_Deployment::DeploymentPlan deployment):
	let terminalConnectedPortDP = getTerminalConnectedPortDP(port, partDP, deployment):	
	terminalConnectedPortDP.exists(cpDP| !cpDP.getParentPart().isDeployed());
	
cached String getConnectorFragmentScopedName(DeploymentPart partDP, InterfacePort port):
	partDP.getScopedName() + "." + port.name;
	
cached boolean portGeneratesFragment(CORBAInterface type) :
	//type.isUsedAsynchronously() || type.isUsedSynchronously();
	!type.isLocal;
	
cached boolean portGeneratesFragment(PortType type) :
	false;
/*
 * Create an AMI4CCM_Connector implementation.
 */
create MonolithicDeploymentDescription findOrCreateInterfacePortConnector(CORBAInterface intf, ConnectorDef connectorType, DeploymentPlan deployment) :
	let artifact = {}:
	let modifiedInterfaceName = {}:
	let componentFactoryParameter = {}:
	let servantEntryPointParameter = {}:
	let artifactRef = {}:
    let portConnectorType = connectorType.name:
	let name = getConnectorName(intf, portConnectorType):
	let executorArtifactParameter = {}:
	let servantArtifactParameter = {}:
	
	{if (portConnectorType == "AMI4CCM_Connector") then {
	    artifact.add(createArtifact(intf, "_ami_exec")) ->
		modifiedInterfaceName.add(intf.getModifiedCorbaScopedName("AMI4CCM_")) ->
		componentFactoryParameter.add(intf.createProperty("COMPONENT_FACTORY", "create_", modifiedInterfaceName.first(), "_Connector_AMI4CCM_Connector_Impl")) ->
		servantEntryPointParameter.add(intf.createProperty("SVNT_ENTRYPT", "create_", modifiedInterfaceName.first(), "_Connector_AMI4CCM_Connector_Servant"))	
	} else if (portConnectorType == "CORBA4CCM_Connector") then {
	    artifact.add(createArtifact(intf, "_cc")) ->
	    componentFactoryParameter.add(intf.createProperty("COMPONENT_FACTORY", "create_", name, "_Impl")) ->
	    servantEntryPointParameter.add(intf.createProperty("SVNT_ENTRYPT", "create_", name, "_Servant"))	   
	}} ->
	
	artifactRef.add(artifact.first().visitImplArtifact()) ->
	executorArtifactParameter.add(intf.createProperty("EXEC_ARTIFACT", "", artifact.first().name.first(), "")) ->
	servantArtifactParameter.add(intf.createProperty("SVNT_ARTIFACT", "", artifact.first().name.first(), "")) ->
	//	
	deployment.artifact.add(artifact.first()) ->
	this.name.add(name) ->
	this.artifact.add(artifactRef.first()) ->
	this.execParameter.add(componentFactoryParameter.first())->
	this.execParameter.add(executorArtifactParameter.first())->
	this.execParameter.add(servantEntryPointParameter.first())->
	this.execParameter.add(servantArtifactParameter.first())->
	this.JavaSetAttribute("id", getUUID()) ->	
	deployment.implementation.add(this);

Void visitPortType(InterfacePort ip, DeploymentPlan plan) :
    findOrCreateInterfacePortConnector(ip.porttype, ip.connectorType, plan);
    	
cached boolean isUsedSynchronously(CORBAInterface self) :
	JAVA com.zeligsoft.domain.dds4ccm.utils.DDS4CCMUtil.isUsedSynchronously(
		org.eclipse.uml2.uml.Interface);	 
	
cached boolean isUsedAsynchronously(CORBAInterface self) :
	JAVA com.zeligsoft.domain.dds4ccm.utils.DDS4CCMUtil.isUsedAsynchronously(
		org.eclipse.uml2.uml.Interface);
		
cached boolean isUsedSynchronously(InterfacePort port) :
	let metaTypeOfPortType = port.porttype.metaType.toString():
	let isNonLocalSync = {}:
	
	{if(metaTypeOfPortType == "CORBADomain::IDL::CORBAInterface") then{
		isNonLocalSync.add(!port.isAsynchronous && !port.type.isLocal)				
	}else{
		isNonLocalSync.add(false) // metaTypeOfPortType == "IDL3Plus::IDL3Plus::ExtendedPortType"
	}} ->
	isNonLocalSync.first(); 
	
cached boolean isUsedAsynchronously(InterfacePort port) :
	let metaTypeOfPortType = port.porttype.metaType.toString():
	let isNonLocalAsync = {}:
	
	{if(metaTypeOfPortType == "CORBADomain::IDL::CORBAInterface") then{
		isNonLocalAsync.add(port.isAsynchronous && !port.type.isLocal)				
	}else{
		isNonLocalAsync.add(false) // metaTypeOfPortType == "IDL3Plus::IDL3Plus::ExtendedPortType"
	}} ->
	isNonLocalAsync.first();	
	
Void visitPortType(PortType o, DeploymentPlan plan) :
	{};

/*
 * Create connections for a deployment part.
 * 
 * @param assemblyPart is a deployment part whose model element is an assembly.
 *
 * @param comp is the component interface of the assembly. Depending on where the assembly deployment
 * part is in the deployment hierarchy, this is accessed differently relative to assemblyPart, so it 
 * is explicitly passed in here. An alternative would be to have a rule to return the interface 
 * passing in a deployment part, but this works well too.
 */
Void createConnections(DeploymentPart assemblyPart, CCM::CCM_Deployment::DeploymentPlan deployment, DeploymentPlan plan, CCMComponent comp) :
	let assembly_impl = getAssembly(comp) :
	let allConnectors = assembly_impl.connector :
	let partWithPortConnectors = allConnectors.select( conn | conn.end.forAll( end | end.partWithPort != null)) :
	let nestedAssemblies = assemblyPart.nestedPart.select( part | isZDLConcept(part.modelElement, "CCM::CCM_Implementation::CCMPart") && getAssembly(part.modelElement.definition).size > 0) :
	partWithPortConnectors.expandEndPointsAndCreateConnections(plan, assemblyPart) ->
	nestedAssemblies.select( asm | asm.createConnections(deployment, plan, asm.modelElement.definition)); 

/*
 * This rule is responsible for taking a CCMConnector and generating ALL the connections for it, 
 * taking into account assembly implementations.
 */
Void expandEndPointsAndCreateConnections(CCMConnector conn, DeploymentPlan plan, DeploymentPart deploymentPart) :
    let sourceEnds = conn.end.select( end | end.port.isConjugated ).expand(deploymentPart):
    let targetEnds = conn.end.select( end | !end.port.isConjugated ).expand(deploymentPart):
	
	if( sourceEnds.size > 0 && targetEnds.size > 0 ) then 
	{
		// For some reason expand() returns a list of lists, with the external list being of size 1.
		// We use .first() to work around that.
		sourceEnds.select( end1 | targetEnds.select( end2 | visit(end1.first(), end2.first(), plan, deploymentPart )))
	};
	
/*
 * Given a ConnectorEnd, return a list of all ConnectorEnds for leaf components that have a compatible 
 * port endpoint. In the case of a ConnectorEnd on a leaf, it will return itself.  
 */
cached List[ConnectorEnd] expand(ConnectorEnd end, DeploymentPart deploymentPart) :
	let retVal = {} :
	let dp = deploymentPart.nestedPart.selectFirst( part | part.modelElement == end.partWithPort) :
	let dpDef = dp.modelElement.definition :
	let asm = getAssembly(dpDef) :
	if( asm.size == 0 ) then
	{
		// Monolithic implementation. Return self.
		retVal.add(end)
	}
	else
	{
		// Assembly implementation. Iterate into the assembly and find every ConnectorEnd connected 
		// to the external port used in the connection. Recursively call this rule for each one and 
		// add the result to the return list. 
		let externalPortConnectors = asm.connector.select( conn | conn.end.port.contains(end.port)) :
		let externalPortConnectorInternalEnds = externalPortConnectors.end.reject( cend | cend.port == end.port) :
		retVal.addAll( externalPortConnectorInternalEnds.expand(dp))
	} ->
	retVal;


/*
 * Given two ConnectorEnds we have to see each pair of deployment parts that represent the
 * endpoints, since the model elements could be present in the deployment more than once.
 *
 * In cases where there are more than one deployment part pointing to the partWithPort, 
 * we will find pairs that have the same parent part and connect those. 
 */
Void visit(ConnectorEnd endpoint1, ConnectorEnd endpoint2, DeploymentPlan deployment, DeploymentPart deploymentPart ) :
	let sourceEnds = findPartWithPortDP(endpoint1.partWithPort, deploymentPart ) :
	let targetEnds = findPartWithPortDP(endpoint2.partWithPort, deploymentPart ) :
	// sourceEnds and targetEnds could have size greater than one. This is the case if
	// a facet/receptacle at the top level resolves down to a multiply nested assembly.
	// In this case we simply generate for every deployment part.
//	sourceEnds.select( ep1 | targetEnds.select( ep2 | if (!endpoint1.port.isConjugated || !endpoint1.port.isAsynchronous || !endpoint1.port.porttype.portGeneratesFragment()) then visit(ep1, endpoint1.port, ep2, endpoint2.port, deployment, deploymentPart )));
	sourceEnds.select( ep1 | targetEnds.select( ep2 | if (!endpoint1.port.isConjugated || !endpoint1.port.porttype.portGeneratesFragment()) then visit(ep1, endpoint1.port, ep2, endpoint2.port, deployment, deploymentPart )));
	
/*
 * Generate a D&C connection given two DeploymentParts representing the endpoints, and another DeploymentPart
 * for context (since the same ConnectorEnds could be part of an assembly used multiple times in a 
 * deployment).
 */
create PlanConnectionDescription visit(DeploymentPart endpoint1, InterfacePort port1, DeploymentPart endpoint2, InterfacePort port2, DeploymentPlan deployment, DeploymentPart deploymentPart) :
	let connName = endpoint1.getScopedName() + "." + port1.name + "::" + endpoint2.getScopedName() + "." + port2.name :
	this.name.add(connName) ->
	// For each ConnectorEnd, we generate a "normal" endpoint if the component involved is deployed, 
	// and an external reference endpoint if it is not. 
	{ endpoint1.isDeployed() ?
		endpoint1.visitPortEndPoint(port1, this, deployment, deploymentPart) :
		endpoint1.visitExternalReference(port1, this)
	} ->
	{ endpoint2.isDeployed() ?
		endpoint2.visitPortEndPoint(port2, this, deployment, deploymentPart) :
		endpoint2.visitExternalReference(port2, this)
	} ->
	port1.type.isLocal && port2.type.isLocal ?
		{ 
		//	this.deployRequirement.add(createLocalInterfaceRequirement()) ->
			if getTargetPart(endpoint1) != getTargetPart(endpoint2) then
				reportError("Connection between deployment parts " + endpoint1.name + "::" + port1.name + " and " + endpoint2.name + "::" + port2.name + " on local interface requires collocation.")
		} : { } ->
	endpoint1.isDeployed() || endpoint2.isDeployed() ?
		deployment.connection.add(this) :
		{} ->
	endpoint1.isDeployed() && !endpoint2.isDeployed() ?
		deployment.instance.selectFirst(e | e.name.select(e | e == endpoint1.getScopedName()).size > 0).addConfigPropertyForRegisterNaming(endpoint1) :
		{} ->
	!endpoint1.isDeployed() && endpoint2.isDeployed() ?
		deployment.instance.selectFirst(e | e.name.select(e | e == endpoint2.getScopedName()).size > 0).addConfigPropertyForRegisterNaming(endpoint2) :
		{};

/*
 * Add required register naming config property for external connection
 */
cached Void addConfigPropertyForRegisterNaming(InstanceDeploymentDescription instance, DeploymentPart part) :
	let property = part.modelElement.zdlAsProperty().type.zdlAsComponent().ownedAttribute.selectFirst(e | e.name == getModelTypeSpecificProperty("REGISTER_NAMING")):
	let propertyValue = part.getPropertyValue(getModelTypeSpecificProperty("REGISTER_NAMING")) :
	if(property != null && propertyValue == "") then {
		let configProperty = new Property :
		let configPropertyValue = new Any :
		let dataValue = new DataValue :
		setAttributeValue(dataValue, getRegisterNamingValueForExternalConnection(part), property.zdlAsProperty().type.toCDPType()) ->
		configPropertyValue.type.add(visitAttributeType(property, configPropertyValue)) ->
		configPropertyValue.value.add(dataValue) ->
		
		configProperty.name.add(getModelTypeSpecificProperty("REGISTER_NAMING")) ->
		configProperty.value.add(configPropertyValue) ->
		instance.configProperty.add(configProperty)
	};

/*
 * Returns whether the deploymentPart is deployed.
 */
cached boolean isDeployed(DeploymentPart deploymentPart ) :
	getTargetPart(deploymentPart) != null;

/*
 * Generate the D&C connection endpoint information for a normal (deployed) component.
 */
create PlanSubcomponentPortEndpoint visitPortEndPoint(DeploymentPart connEnd, InterfacePort port, PlanConnectionDescription connDescription, DeploymentPlan deployment, DeploymentPart deploymentPart) :
	let dpSN = connEnd.getScopedName() :
	let instId = deployment.instance.selectFirst(e | e.name.first().matches(dpSN)).id :
	this.portName.add(port.name) ->
	this.provider.add( port.isConjugated ? "false" : "true" ) ->
	this.kind.add(this.provider.first() == "true" ? CcmComponentPortKind::Facet : 
		( port.zdlAsPort().isMultivalued() ? CcmComponentPortKind::MultiplexReceptacle : CcmComponentPortKind::SimplexReceptacle)	) ->
	this.instance.add(connEnd.visit(instId)) -> 
	connDescription.internalEndpoint.add(this);
	
/*
 * Generate the D&C connection endpoint information for an external reference.
 */
create ExternalReferenceEndpoint visitExternalReference(DeploymentPart connEnd, InterfacePort port, PlanConnectionDescription connDescription) :
	let location = getLocationPrefix(connEnd) :
	this.location.add((location != null && location != "" ? location : "corbaname:rir:/NameService#") + getRegisterNamingValueForExternalConnection(connEnd)) ->
	this.provider.add( port.isConjugated ? "false" : "true" ) ->
	this.portName.add(port.name) ->
	this.supportedType.add("Meaningless") ->
	connDescription.externalReference.add(this);
	
cached String getRegisterNamingValueForExternalConnection(DeploymentPart part) :
	let registerNaming = part.getPropertyValue(getModelTypeSpecificProperty("REGISTER_NAMING")) :
	registerNaming != "" ? registerNaming : part.name;
	
/*
 * Given a CCMPart and the deployment part representing an assembly containing a connection, find the 
 * deployment part(s) that points to the CCMPart as its model element.
 * This calls out to a Java method because the CCMPart could be nested multiple levels below the 
 * assembly's model element, which is a pain to evaluate in Xtend. 
 * 
 */
cached List[DeploymentPart] findPartWithPortDP( CCMPart part, DeploymentPart asmPart ) :
	JAVA com.zeligsoft.domain.idl3plus.utils.IDL3PlusXtendUtils.findPartWithPortDP(
		org.eclipse.uml2.uml.Property,
		org.eclipse.uml2.uml.Property);
		
cached DeploymentPart getTargetPart(DeploymentPart source) :
	JAVA com.zeligsoft.domain.zml.util.ZDeploymentUtil.getDeploymentTargetPart(
		org.eclipse.uml2.uml.Property);
	
ArtifactDeploymentDescription visitImplArtifact(ArtifactDeploymentDescription artifact) :
	let artifactReference = new ArtifactDeploymentDescription :
	artifactReference.JavaSetAttribute("idref", artifact.id) ->
	artifactReference;

	
create ArtifactDeploymentDescription visitArtifactExec(NamedElement inst) :
	this.name.add(inst.getCorbaScopedName() + "_exec") ->
	this.source.add(null) ->
	this.node.add(null) ->
	this.location.add(inst.getCorbaScopedName() + "_exec") ->
	this.JavaSetAttribute("id", getUUID());
	
create ArtifactDeploymentDescription createArtifact(NamedElement inst, String suffix) :
	this.name.add(inst.getCorbaScopedName() + suffix) ->
	this.source.add(null) ->
	this.node.add(null) ->
	this.location.add(inst.getCorbaScopedName() + suffix) ->
	this.JavaSetAttribute("id", getUUID());

	
create ArtifactDeploymentDescription visitArtifactSvnt(NamedElement inst) :
	this.name.add(inst.getCorbaScopedName() + "_svnt") ->
	this.source.add(null) ->
	this.node.add(null) ->
	this.location.add(inst.getCorbaScopedName() + "_svnt") ->
	this.JavaSetAttribute("id", getUUID());


create ArtifactDeploymentDescription visitArtifactExec(ConnectorDef inst) :
	this.name.add(inst.getCorbaScopedName() + "_exec") ->
	this.source.add(null) ->
	this.node.add(null) ->
	this.location.add(getCorbaScopedName(inst).replaceAll("_" + inst.name, "") + "_exec") ->
	this.JavaSetAttribute("id", getUUID());
	
create ArtifactDeploymentDescription visitArtifactSvnt(ConnectorDef inst) :
	this.name.add(inst.getCorbaScopedName() + "_svnt") ->
	this.source.add(null) ->
	this.node.add(null) ->
	this.location.add(getCorbaScopedName(inst).replaceAll("_" + inst.name, "") + "_svnt") ->
	this.JavaSetAttribute("id", getUUID());
	
cached String getCorbaScopedName(DataSpace element ) :
	getCorbaScopedName(element.zdlAsProperty().type);

create Property createProperty(NamedElement inst, String propertySelector, String prefix, String baseName, String suffix) :
    this.name.add(getModelTypeSpecificProperty(propertySelector )) ->
    this.value.add(visitAny(prefix + baseName + suffix));

create Property visitParam1(NamedElement inst) :
	this.name.add(getModelTypeSpecificProperty("COMPONENT_FACTORY")) ->
	this.value.add(visitAny("create_" + inst.getCorbaScopedName() + "_Impl"));
		
create Property visitParam1(CORBAInterface inst) :
	this.name.add(getModelTypeSpecificProperty("COMPONENT_FACTORY")) ->
	this.value.add(visitAny("create_" + inst.getCorbaScopedName().replaceAll(inst.name, "AMI4CCM_" + inst.name) + "_Connector_Impl"));
	
create Property visitParam1(Home inst, MonolithicImplementation impl) :
	this.name.add("home factory") ->
	this.value.add(visitAny("create_" + inst.getCorbaScopedName() + "_Impl"));
	
create Property visitParam2(NamedElement inst) :
	this.name.add(getModelTypeSpecificProperty("EXEC_ARTIFACT")) ->
	this.value.add(visitAny(inst.getCorbaScopedName() + "_exec"));
	
create Property visitParam2(Home inst, MonolithicImplementation impl) :
	this.name.add(getModelTypeSpecificProperty("EXEC_ARTIFACT")) ->
	this.value.add(visitAny(inst.manages.component.getCorbaScopedName() + "_exec"));
	
create Property visitParam3(NamedElement inst) :
	this.name.add(getModelTypeSpecificProperty("SVNT_ENTRYPT")) ->
	this.value.add(visitAny("create_" + inst.getCorbaScopedName() + "_Servant"));

create Property visitParam3(CORBAInterface inst) :
	this.name.add(getModelTypeSpecificProperty("SVNT_ENTRYPT")) ->
	this.value.add(visitAny("create_" + inst.getCorbaScopedName().replaceAll(inst.name, "AMI4CCM_" + inst.name) + "_Connector_AMI4CCM_Connector_Servant"));

create Property visitParam3(Home inst, MonolithicImplementation impl) :
	this.name.add(getModelTypeSpecificProperty("SVNT_ENTRYPT")) ->
	this.value.add(visitAny("create_" + inst.getCorbaScopedName() + "_Servant"));

create Property visitParam4(NamedElement inst) :
	this.name.add(getModelTypeSpecificProperty("SVNT_ARTIFACT")) ->
	this.value.add(visitAny(inst.getCorbaScopedName() + "_svnt"));

create Property visitParam4(Home inst, MonolithicImplementation impl) :
	this.name.add(getModelTypeSpecificProperty("SVNT_ARTIFACT")) ->
	this.value.add(visitAny(inst.manages.component.getCorbaScopedName() + "_svnt"));

create Property visitImplementationTypeParameter(CCMComponent inst ) :
	this.name.add(getModelTypeSpecificProperty("IMPL_TYPE")) ->
	getHome(inst) != null ?
	this.value.add(visitAny(getModelTypeSpecificProperty("CCM_HOMEDCOMPONENT")))
	: this.value.add(visitAny(getModelTypeSpecificProperty("CCM_COMPONENT")));
	
create Property visitImplementationTypeParameter(MonolithicImplementation inst ) :
	this.name.add(getModelTypeSpecificProperty("IMPL_TYPE")) ->
	getHome(inst.interface) != null ?
	this.value.add(visitAny(getModelTypeSpecificProperty("CCM_HOMEDCOMPONENT")))
	: this.value.add(visitAny(getModelTypeSpecificProperty("CCM_COMPONENT")));
	
create Property visitImplementationTypeParameter(ConnectorDef inst ) :
	this.name.add(getModelTypeSpecificProperty("IMPL_TYPE")) ->
	this.value.add(visitAny(getModelTypeSpecificProperty("CCM_CONNECTOR")));
	
create Property visitImplementationTypeParameter(CORBAInterface intf ) :
	this.name.add(getModelTypeSpecificProperty("IMPL_TYPE")) ->
	this.value.add(visitAny(getModelTypeSpecificProperty("CCM_CONNECTOR")));
	
create Property visitImplementationTypeParameter(Home home, MonolithicImplementation impl ) :
	this.name.add(getModelTypeSpecificProperty("IMPL_TYPE")) ->
	this.value.add(visitAny(getModelTypeSpecificProperty("CCM_HOME")));
	
Home getHome(CCMComponent component) :
	JAVA com.zeligsoft.domain.idl3plus.utils.IDL3PlusXtendUtils.getHome(
		org.eclipse.uml2.uml.Component);
		
String getPath(CCM::CCM_Deployment::DeploymentPlan element) :
	JAVA com.zeligsoft.domain.dds4ccm.utils.DDS4CCMGenerationUtils.path(org.eclipse.uml2.uml.NamedElement);
	
String getLocationPrefix(DeploymentPart connEnd) :
    JAVA com.zeligsoft.domain.ngc.ccm.descriptorgeneration.DDS4CCMXtendUtils.getLocationPrefix(org.eclipse.uml2.uml.Element);

String shouldGenerateRegisterNamingTag(DeploymentPart part, CCM::CCM_Target::Property property) :
    JAVA com.zeligsoft.domain.ngc.ccm.descriptorgeneration.DDS4CCMXtendUtils.shouldGenerateRegisterNamingTag(org.eclipse.uml2.uml.Property, org.eclipse.uml2.uml.Property);
    
// This should never cache
Any visitAny(String value) :
	let retVal = new Any :
	retVal.type.add(visitType()) ->
	retVal.value.add(visitValue(value)) ->
	retVal;
	
DataType visitType() :
	let type = new DataType :
	type.kind.add(TcKind::tkString) ->
	type;

// This should never cache	
DataValue visitValue(String value) :
	let retVal = new DataValue :
	retVal.string.add(value) ->
	retVal;

Void createLocalityManagerElements(deploymentplan::DeploymentPlan plan) :
	let artifact = createLocalityManagerArtifact() :
	plan.artifact.add(artifact) ->
	plan.implementation.add(createLocalityManagerImplementation(artifact));
	
create MonolithicDeploymentDescription createLocalityManagerImplementation(ArtifactDeploymentDescription artifact) :
	this.name.add("CompSvr") ->
	this.artifact.add(artifact.visitImplArtifact()) ->
	this.execParameter.add(createImplementationTypeProperty()) ->
	this.JavaSetAttribute("id", "CompSvrImpl");
	
create Property createImplementationTypeProperty() :
	this.name.add(getModelTypeSpecificProperty("IMPL_TYPE")) ->
	this.value.add(visitAny(getModelTypeSpecificProperty("LOCALITYMANAGER")));
	
create ArtifactDeploymentDescription createLocalityManagerArtifact() :
	this.name.add("CompoSvrArtifactName") ->
	this.source.add(null) ->
	this.node.add(null) ->
	this.location.add("locality_manager") ->
	this.JavaSetAttribute("id", "CompSvrArt");
	
create InstanceDeploymentDescription createContainerProcessInstance(DeploymentPart process, CCM::CCM_Deployment::DeploymentPlan zDeployment) :
	let node = zDeployment.allocation.selectFirst(a | a.deployed.contains(process)).deployedOn :
	let properties = process.modelElement.zdlAsComponent().member.typeSelect(CCM::CCM_Target::Property) :
	this.JavaSetAttribute("id", getUUID()) ->
	this.name.add(process.name + "_ComponentServerInstance") ->
	this.node.add(node.zdlAsNamedElement().name) ->
	this.source.add(null) ->
	this.implementation.add(visitInstanceImpl("CompSvrImpl", this)) ->
    properties.visitConfigProperty(this, process) ->
    if(!this.configProperty.name.exists(n | n == getModelTypeSpecificProperty("LM_PROCESSNAME"))) then {
   	    // if this property does not exist then create a default one
    	this.createProcessNameProperty(process)
	};
	
create Property createProcessNameProperty(InstanceDeploymentDescription instance, DeploymentPart process ) :
	this.name.add(getModelTypeSpecificProperty("LM_PROCESSNAME")) ->
	this.value.add(this.createProcessNamePropertyValue(process)) ->
	instance.configProperty.add(this);

create Any createProcessNamePropertyValue(Property property, DeploymentPart process ) :
	let type = new DataType :
	let value = new DataValue :
	type.kind.add(TcKind::tkString) ->
	this.type.add(type) ->
	value.string.add(process.name) ->
	this.value.add(value);

String getModelTypeSpecificProperty(String property):
	let modelType = (String)getGlobalVar("modelType"):
	getModelTypeSpecificProperty(modelType, property);
			
String getModelTypeSpecificProperty(String modelType, String property):
	JAVA com.zeligsoft.domain.dds4ccm.utils.DDS4CCMUtil.getPropertyName(
		java.lang.String, java.lang.String);